{"version":3,"file":"481.js","mappings":"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","sources":["webpack://axolotis-player/./src/lib/modules/portals/PortalLink.ts"],"sourcesContent":["import { ServiceEntity } from \"@aptero/axolotis-player\";\nimport { CodeLoaderComponent } from \"@aptero/axolotis-player/build/types/modules/core/loader/CodeLoaderComponent\";\nimport * as THREE from \"three\";\nimport { WebpackLazyModule } from \"@aptero/axolotis-player/build/types/modules/core/loader/WebpackLoader\";\nimport { WorldEntity } from \"@aptero/axolotis-player/build/types/modules/core/ecs/WorldEntity\";\nimport {ThreeLib} from \"@root/lib/modules/three/ThreeLib\";\nimport { PortalsService } from \"./PortalsService\";\nimport { PlayerService } from \"../controller/PlayerService\";\nimport { WorldService } from \"@aptero/axolotis-player/build/types/modules/core/WorldService\";\nimport { ComponentFactory } from \"@aptero/axolotis-player/build/types/modules/core/ecs/ComponentFactory\";\nimport Component from \"@aptero/axolotis-player/build/types/modules/core/ecs/Component\";\nimport { initHtmlFromUrl } from \"@aptero/axolotis-player\";\n\n//https://barthaweb.com/2020/09/webgl-portal/\n//https://github.com/stemkoski/AR-Examples/blob/master/portal-view.html\n//https://stemkoski.github.io/AR-Examples/portal-view.html\n//https://discourse.threejs.org/t/multiple-scenes-vs-layers/12503/10\n\n\nexport class Factory implements WebpackLazyModule, ComponentFactory<PortalLink> {\n    async createComponent(world: WorldEntity, config: {\n        url:string,\n        in:{x:number,y:number,z:number},\n        out:{x:number,y:number,z:number},\n    }): Promise<PortalLink> {\n        let services = world.getFirstComponentByType<ServiceEntity>(ServiceEntity.name);\n        let codeLoader = await services.getService<CodeLoaderComponent>(\"@root/modules/core/loader/CodeLoaderService\");\n        let three = await services.getService<ThreeLib>(\"@root/modules/three/ThreeLib\");\n        let service = await services.getService<PortalsService>(\"@root/modules/portals/PortalsService\");\n        let playerService = await services.getService<PlayerService>(\"@root/modules/controller/PlayerService\");\n        let worldService = await services.getService<WorldService>(\"@root/modules/core/WorldService\");\n        let portalLink = new PortalLink(service,three,playerService,worldService,{\n            position:new THREE.Vector3(config.in?.x,config.in?.y,config.in?.z)\n        },{\n            position:new THREE.Vector3(config.out?.x,config.out?.y,config.out?.z)\n        });\n        codeLoader.awaitInitialLoading().then(async value => {\n            let world = await initHtmlFromUrl(config.url);\n            portalLink.setTargetWorld(world);\n        });\n        return portalLink;\n    }\n}\n\nconst invisibleLayer = 31;\nconst tmpVisibleLayer = 30;\nconst regularLayer = 0;\n\nexport class PortalLink implements Component{\n    private otherCamera: THREE.PerspectiveCamera;\n    private portalA: THREE.Mesh<THREE.CircleGeometry, THREE.MeshBasicMaterial>;\n    private portalB: THREE.Mesh<THREE.CircleGeometry, THREE.MeshBasicMaterial>;\n    private targetWorld: WorldEntity | null = null;\n    private targetThreeLib: ThreeLib | null = null;\n    private boundingBox: THREE.Box3;\n    private targetLink: PortalLink | null = null;\n    private portalPlane: THREE.Plane;\n    private targetPlayerService: PlayerService | null = null;\n\n    async setTargetWorld(world: WorldEntity) {\n        this.targetWorld = world;\n        let targetWorldService = await this.targetWorld.getFirstComponentByType<ServiceEntity>(ServiceEntity.name);\n        this.targetThreeLib = await targetWorldService.getService<ThreeLib>(\"@root/modules/three/ThreeLib\");\n        this.targetPlayerService = await targetWorldService.getService<PlayerService>(\"@root/modules/controller/PlayerService\");\n        let otherPortals:PortalLink[] = await world.getComponentByType<PortalLink>(PortalLink.name);\n        if(otherPortals.length === 0){\n            console.error(\"no destination portal present\")\n        }\n        for(const op of otherPortals){\n            if(op.inPosition.position.equals(this.outPosition.position)){// && op.key === this.key\n                this.targetLink = op;\n            }\n        }\n        if(this.targetLink) {\n            this.portals.addPortalRenderLoop(() => {\n                this.renderPortal();\n            });\n            this.portals.addPortalLoop(delta => {\n                this.computerPortalEnter();\n            });\n        }else{\n            throw new Error(\"invalid portal init: target portal in wrong state\");\n        }\n    }\n\n    constructor(private portals:PortalsService,private three: ThreeLib,private playerService:PlayerService,private worldService:WorldService,\n                private inPosition:{position:THREE.Vector3,rotation?:THREE.Euler},\n                private outPosition:{position:THREE.Vector3,rotation?:THREE.Euler}) {\n\n        this.otherCamera = new THREE.PerspectiveCamera( three.camera.fov, window.innerWidth / window.innerHeight, this.three.camera.near, this.three.camera.far );\n        three.scene.add(this.otherCamera);\n\n        // Portal A (Portal View) ================================\n        let defaultMaterial = new THREE.MeshBasicMaterial({\n            color: 0xFF0000,\n            side: THREE.DoubleSide,\n            transparent: true\n        });\n\n        this.portalA = new THREE.Mesh(\n            new THREE.CircleGeometry(1, 64),\n            //new THREE.BoxGeometry( 1, 1, 1 ),\n            defaultMaterial.clone()\n        );\n        this.portalA.material.opacity = 0;\n        this.portalA.position.copy(inPosition.position);\n        if(inPosition.rotation) {\n            this.portalA.setRotationFromEuler(inPosition.rotation);\n        }\n        this.portalA.layers.set(invisibleLayer);//invisible layer storage\n        three.scene.add(this.portalA);\n        this.portalA.geometry.computeBoundingBox();\n        this.portalPlane = new THREE.Plane(new THREE.Vector3(0,0,1));//TODO remember to move and oriente the plan to follow the portal\n        //const helper = new THREE.PlaneHelper( this.portalPlane, 1, 0xffff00 );\n        //this.three.scene.add( helper );\n        this.boundingBox = new THREE.Box3();\n        this.boundingBox.copy( this.portalA.geometry.boundingBox|| new THREE.Box3() );\n        let minBox = new THREE.Box3(new THREE.Vector3(-0.2,-0.2,-0.2),new THREE.Vector3(0.2,0.2,0.2));\n        this.boundingBox= this.boundingBox.union(minBox);\n        //const helper = new THREE.Box3Helper( this.boundingBox,0xffff00 as any );\n        //this.three.scene.add( helper );\n        // Portal B (Point of View position and rotation) ================================\n        // material for portals and blockers\n        let defaultMaterial2 = new THREE.MeshBasicMaterial({\n            color: 0xFFFFFF,\n            side: THREE.DoubleSide,\n            transparent: true\n        });\n\n        this.portalB = new THREE.Mesh(\n            new THREE.CircleGeometry(1, 64),\n            defaultMaterial2.clone()\n        );\n        this.portalB.material.opacity = 0;\n        this.portalB.position.copy(outPosition.position);\n        if(outPosition.rotation) {\n            this.portalB.setRotationFromEuler(outPosition.rotation);\n        }\n        three.scene.add(this.portalB);\n\n    }\n\n    tmpPos:THREE.Vector3 = new THREE.Vector3();\n    tmpDir:THREE.Vector3 = new THREE.Vector3();\n    tmpBox:THREE.Box3 = new THREE.Box3();\n    tmpPlane:THREE.Plane = new THREE.Plane();\n    collidingLastFrame:boolean = false;\n    lastDistance:number = 0;\n    gracePeriode = 0;//in FPS\n\n    computerPortalEnter(){\n        if(!this.worldService.isActiveWorld()){\n            return;\n        }\n        if(this.gracePeriode>0){\n            this.gracePeriode--;\n        }\n        //compute collision\n        this.tmpBox.copy(this.boundingBox);\n        this.tmpPlane.copy(this.portalPlane);\n        this.tmpBox.applyMatrix4( this.portalA.matrixWorld );\n        this.tmpPlane.applyMatrix4( this.portalA.matrixWorld );\n        this.playerService.getCurrentPlayer().getHeadPosition(this.tmpPos);\n        this.three.camera.getWorldDirection(this.tmpDir);\n        //this.tmpPos.add(this.tmpDir.multiplyScalar(0.30));\n        const isColliding = this.tmpBox.containsPoint(this.tmpPos);\n        if (isColliding) {\n            if(this.lastDistance !== 0) {\n                // - * + => - / + * - => - => this means we traversed the plan\n                if(this.tmpPlane.distanceToPoint(this.tmpPos)*this.lastDistance<0){\n                    //enter\n                    console.log(\"enter\")\n                    if(this.targetWorld && this.targetLink && this.targetPlayerService && this.gracePeriode==0) {\n                        this.targetLink.gracePeriode = 5;\n                        this.targetLink.collidingLastFrame = true;//sync colliding flag\n                        this.targetLink.lastDistance = this.lastDistance;\n                        this.playerService.getCurrentPlayer().getHeadPosition(this.tmpPos);//right head position before teleport\n                        this.targetPlayerService.getCurrentPlayer().teleportToLocation(this.tmpPos.x,this.tmpPos.y,this.tmpPos.z);\n                        console.log(\"teleport\");\n                        this.worldService.setActiveWorld(this.targetWorld);\n                        this.targetPlayerService.getCurrentPlayer().teleportToLocation(this.tmpPos.x,this.tmpPos.y,this.tmpPos.z);\n                    }\n                }\n            }\n            this.lastDistance = this.tmpPlane.distanceToPoint(this.tmpPos);\n        } else if (!isColliding && this.lastDistance!==0) {\n            //leave\n            this.lastDistance = 0;\n            console.log(\"leave\")\n        }\n        this.collidingLastFrame = isColliding;\n    }\n\n    renderPortal()\n    {\n        if(!this.targetThreeLib){\n            return;\n        }\n        this.portalA.layers.set(tmpVisibleLayer);//Portal to render to layer 1\n\n        // relatively align other camera with main camera\n\n        let relativePosition = this.portalA.worldToLocal( this.three.camera.position.clone() );\n        this.otherCamera.position.copy( this.portalB.localToWorld( relativePosition ) );\n\n        let relativeRotation = this.three.camera.quaternion.clone().multiply( this.portalA.quaternion.clone().invert() );\n        this.otherCamera.quaternion.copy( relativeRotation.multiply(this.portalB.quaternion) );\n\n        // keep camera tilt in sync\n        this.otherCamera.rotation.x = this.three.camera.rotation.x;\n\n        let gl = this.three.renderer.getContext();\n\n        // FIRST PASS\n        // goal: using the stencil buffer, place 1's in position of first portal\n\n        // enable the stencil buffer\n        gl.enable(gl.STENCIL_TEST);\n\n        // layer 1 contains only the first portal\n        this.three.camera.layers.set(tmpVisibleLayer);\n\n        gl.stencilFunc(gl.ALWAYS, 1, 0xff);\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n        gl.stencilMask(0xff);\n\n        // only write to stencil buffer (not color or depth)\n        gl.colorMask(false,false,false,false);\n        gl.depthMask(false);\n\n        this.three.renderer.render( this.three.scene, this.three.camera );\n        //this.three.renderer.render( this.targetThreeLib.scene, this.targetThreeLib.camera );\n\n        // SECOND PASS\n        // goal: draw from the portal camera perspective (which is aligned relative to the second portal)\n        //   in the first portal region (set by the stencil in the previous pass)\n\n        // set up a clipping plane, so that portal camera does not see anything between\n        //   the portal camera and the second portal\n\n        // default normal of a plane is 0,0,1. apply mesh rotation to it.\n\n\n        // determine which side of the plane camera is on, for clipping plane orientation.\n        let portalToCamera = new THREE.Vector3().subVectors( this.three.camera.position.clone(), this.portalA.position.clone() ); //  applyQuaternion( mainMover.quaternion );\n        let normalPortal = new THREE.Vector3(0,0,1).applyQuaternion( this.portalA.quaternion );\n        let clipSide = -Math.sign( portalToCamera.dot(normalPortal) );\n\n        let clipNormal = new THREE.Vector3(0, 0, clipSide).applyQuaternion( this.portalB.quaternion );\n        let clipPoint = this.portalB.position;\n        let clipPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(clipNormal, clipPoint);\n        this.three.renderer.clippingPlanes = [clipPlane];\n\n        gl.colorMask(true,true,true,true);\n        gl.depthMask(true);\n\n        gl.stencilFunc(gl.EQUAL, 1, 0xff);\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\n        this.otherCamera.layers.set(regularLayer);\n        //this.three.renderer.render( this.three.scene, this.otherCamera );//TODO maybe here scene 2\n        this.three.renderer.render( this.targetThreeLib.scene, this.otherCamera );\n\n        // disable clipping planes\n        this.three.renderer.clippingPlanes = [];\n\n        // THIRD PASS\n        // goal: set the depth buffer data for the first portal,\n        //   so that it can be occluded by other objects\n\n        // finished with stencil\n        gl.disable(gl.STENCIL_TEST);\n\n        gl.colorMask(false,false,false,false);\n        gl.depthMask(true);\n        // need to clear the depth buffer, in case of occlusion\n        this.three.renderer.render( this.three.scene, this.three.camera );\n\n        this.three.camera.layers.set(regularLayer); // layer 0 contains everything but portals\n        this.portalA.layers.set(invisibleLayer);//Portal to render to layer 1\n\n    }\n\n    getType(): string {\n        return PortalLink.name;\n    }\n\n}\n"],"names":["Factory","world","config","services","getFirstComponentByType","ServiceEntity","codeLoader","getService","three","service","playerService","worldService","portalLink","PortalLink","position","THREE","in","x","y","z","out","awaitInitialLoading","then","async","initHtmlFromUrl","url","setTargetWorld","this","targetWorld","targetWorldService","targetThreeLib","targetPlayerService","otherPortals","getComponentByType","name","length","console","error","op","inPosition","equals","outPosition","targetLink","Error","portals","addPortalRenderLoop","renderPortal","addPortalLoop","delta","computerPortalEnter","constructor","otherCamera","camera","fov","window","innerWidth","innerHeight","near","far","scene","add","defaultMaterial","color","side","transparent","portalA","clone","material","opacity","copy","rotation","setRotationFromEuler","layers","set","geometry","computeBoundingBox","portalPlane","boundingBox","minBox","union","defaultMaterial2","portalB","isActiveWorld","gracePeriode","tmpBox","tmpPlane","applyMatrix4","matrixWorld","getCurrentPlayer","getHeadPosition","tmpPos","getWorldDirection","tmpDir","isColliding","containsPoint","lastDistance","distanceToPoint","log","collidingLastFrame","teleportToLocation","setActiveWorld","relativePosition","worldToLocal","localToWorld","relativeRotation","quaternion","multiply","invert","gl","renderer","getContext","enable","STENCIL_TEST","stencilFunc","ALWAYS","stencilOp","KEEP","REPLACE","stencilMask","colorMask","depthMask","render","portalToCamera","subVectors","normalPortal","applyQuaternion","clipSide","Math","sign","dot","clipNormal","clipPoint","clipPlane","setFromNormalAndCoplanarPoint","clippingPlanes","EQUAL","disable","getType"],"sourceRoot":""}