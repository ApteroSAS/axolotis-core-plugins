{"version":3,"file":"@aptero/axolotis-core-plugins/portals/PortalLink.fefb2e7e5044988651b1.js","mappings":"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","sources":["webpack://axolotis-core-plugins/./src/lib/modules/portals/PortalLink.ts"],"sourcesContent":["import { ServiceEntity } from \"@aptero/axolotis-player\";\nimport { WorldEntity } from \"@aptero/axolotis-player\";\nimport { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\nimport { PortalsService } from \"./PortalsService\";\nimport { PlayerService } from \"../controller/PlayerService\";\nimport { ComponentFactory } from \"@aptero/axolotis-player/build/types/modules/core/ecs/ComponentFactory\";\nimport Component from \"@aptero/axolotis-player/build/types/modules/core/ecs/Component\";\nimport { initHtmlFromUrl } from \"@aptero/axolotis-player\";\nimport {\n  Box3,\n  CircleGeometry,\n  DoubleSide,\n  Mesh,\n  MeshBasicMaterial,\n  PerspectiveCamera,\n  Plane,\n  Vector3,\n} from \"three\";\nimport {CODE_LOADER_MODULE_NAME, InitialComponentLoader} from \"@aptero/axolotis-player\";\nimport {WebpackLazyModule} from \"@root/lib/generated/webpack/WebpackLoader\";\nimport {WorldService} from \"@root/lib/modules/worlds/WorldService\";\n\n//https://barthaweb.com/2020/09/webgl-portal/\n//https://github.com/stemkoski/AR-Examples/blob/master/portal-view.html\n//https://stemkoski.github.io/AR-Examples/portal-view.html\n//https://discourse.threejs.org/t/multiple-scenes-vs-layers/12503/10\n\n//TODO an iframe per world maybe?\n//https://web.dev/origin-agent-cluster/\n\nexport class Factory\n  implements WebpackLazyModule, ComponentFactory<PortalLink>\n{\n  async createComponent(\n    world: WorldEntity,\n    config: {\n      url: string;\n      in: { x: number; y: number; z: number };\n      out: { x: number; y: number; z: number };\n    }\n  ): Promise<PortalLink> {\n    let services = world.getFirstComponentByType<ServiceEntity>(\n      ServiceEntity.name\n    );\n    let codeLoader = await services.getService<InitialComponentLoader>(\n      CODE_LOADER_MODULE_NAME\n    );\n    let three = await services.getService<ThreeLib>(\n      \"@aptero/axolotis-core-plugins/three/ThreeLib\"\n    );\n    let service = await services.getService<PortalsService>(\n      \"@aptero/axolotis-core-plugins/portals/PortalsService\"\n    );\n    let playerService = await services.getService<PlayerService>(\n      \"@aptero/axolotis-core-plugins/controller/PlayerService\"\n    );\n    let worldService = await services.getService<WorldService>(\n      \"@aptero/axolotis-core-plugins/core/WorldService\"\n    );\n    let portalLink = new PortalLink(\n      service,\n      three,\n      playerService,\n      worldService,\n      {\n        position: new Vector3(config.in?.x, config.in?.y, config.in?.z),\n      },\n      {\n        position: new Vector3(config.out?.x, config.out?.y, config.out?.z),\n      }\n    );\n    codeLoader.awaitInitialLoading().then(async (value) => {\n      let world;\n      if (service.worldExist(config.url)) {\n        world = service.getWorld(config.url);\n      } else {\n        world = await initHtmlFromUrl(config.url);\n        service.notifylWorld(config.url, world);\n      }\n      portalLink.setTargetWorld(world);\n    });\n    return portalLink;\n  }\n}\n\nconst invisibleLayer = 31;\nconst tmpVisibleLayer = 30;\nconst regularLayer = 0;\n\nexport class PortalLink implements Component {\n  private otherCamera: THREE.PerspectiveCamera;\n  private portalA: THREE.Mesh<THREE.CircleGeometry, THREE.MeshBasicMaterial>;\n  private portalB: THREE.Mesh<THREE.CircleGeometry, THREE.MeshBasicMaterial>;\n  private targetWorld: WorldEntity | null = null;\n  private targetThreeLib: ThreeLib | null = null;\n  private boundingBox: THREE.Box3;\n  private targetLink: PortalLink | null = null;\n  private portalPlane: THREE.Plane;\n  private targetPlayerService: PlayerService | null = null;\n\n  async setTargetWorld(world: WorldEntity) {\n    this.targetWorld = world;\n    let targetWorldService =\n      await this.targetWorld.getFirstComponentByType<ServiceEntity>(\n        ServiceEntity.name\n      );\n    this.targetThreeLib = await targetWorldService.getService<ThreeLib>(\n      \"@aptero/axolotis-core-plugins/three/ThreeLib\"\n    );\n    this.targetPlayerService =\n      await targetWorldService.getService<PlayerService>(\n        \"@aptero/axolotis-core-plugins/controller/PlayerService\"\n      );\n    let otherPortals: PortalLink[] = await world.getComponentByType<PortalLink>(\n      PortalLink.name\n    );\n    if (otherPortals.length === 0) {\n      console.error(\"no destination portal present\");\n    }\n    for (const op of otherPortals) {\n      if (op.inPosition.position.equals(this.outPosition.position)) {\n        // && op.key === this.key\n        this.targetLink = op;\n      }\n    }\n    if (this.targetLink) {\n      this.portals.addPortalRenderLoop(() => {\n        this.renderPortal();\n      });\n      this.portals.addPortalLoop((delta) => {\n        this.computerPortalEnter();\n      });\n    } else {\n      throw new Error(\"invalid portal init: target portal in wrong state\");\n    }\n  }\n\n  constructor(\n    private portals: PortalsService,\n    private three: ThreeLib,\n    private playerService: PlayerService,\n    private worldService: WorldService,\n    private inPosition: { position: THREE.Vector3; rotation?: THREE.Euler },\n    private outPosition: { position: THREE.Vector3; rotation?: THREE.Euler }\n  ) {\n    this.otherCamera = new PerspectiveCamera(\n      three.camera.fov,\n      window.innerWidth / window.innerHeight,\n      this.three.camera.near,\n      this.three.camera.far\n    );\n    three.scene.add(this.otherCamera);\n\n    // Portal A (Portal View) ================================\n    let defaultMaterial = new MeshBasicMaterial({\n      color: 0xff0000,\n      side: DoubleSide,\n      transparent: true,\n    });\n\n    this.portalA = new Mesh(\n      new CircleGeometry(1, 64),\n      //new THREE.BoxGeometry( 1, 1, 1 ),\n      defaultMaterial.clone()\n    );\n    this.portalA.material.opacity = 0;\n    this.portalA.position.copy(inPosition.position);\n    if (inPosition.rotation) {\n      this.portalA.setRotationFromEuler(inPosition.rotation);\n    }\n    this.portalA.layers.set(invisibleLayer); //invisible layer storage\n    three.scene.add(this.portalA);\n    this.portalA.geometry.computeBoundingBox();\n    this.portalPlane = new Plane(new Vector3(0, 0, 1)); //TODO remember to move and oriente the plan to follow the portal\n    //const helper = new THREE.PlaneHelper( this.portalPlane, 1, 0xffff00 );\n    //this.three.scene.add( helper );\n    this.boundingBox = new Box3();\n    this.boundingBox.copy(this.portalA.geometry.boundingBox || new Box3());\n    let minBox = new Box3(\n      new Vector3(-0.2, -0.2, -0.2),\n      new Vector3(0.2, 0.2, 0.2)\n    );\n    this.boundingBox = this.boundingBox.union(minBox);\n    //const helper = new THREE.Box3Helper( this.boundingBox,0xffff00 as any );\n    //this.three.scene.add( helper );\n    // Portal B (Point of View position and rotation) ================================\n    // material for portals and blockers\n    let defaultMaterial2 = new MeshBasicMaterial({\n      color: 0xffffff,\n      side: DoubleSide,\n      transparent: true,\n    });\n\n    this.portalB = new Mesh(\n      new CircleGeometry(1, 64),\n      defaultMaterial2.clone()\n    );\n    this.portalB.material.opacity = 0;\n    this.portalB.position.copy(outPosition.position);\n    if (outPosition.rotation) {\n      this.portalB.setRotationFromEuler(outPosition.rotation);\n    }\n    three.scene.add(this.portalB);\n  }\n\n  tmpPos: THREE.Vector3 = new Vector3();\n  tmpDir: THREE.Vector3 = new Vector3();\n  tmpBox: THREE.Box3 = new Box3();\n  tmpPlane: THREE.Plane = new Plane();\n  collidingLastFrame: boolean = false;\n  lastDistance: number = 0;\n  gracePeriode = 0; //in FPS\n\n  computerPortalEnter() {\n    if (!this.worldService.isActiveWorld()) {\n      return;\n    }\n    if (this.gracePeriode > 0) {\n      this.gracePeriode--;\n    }\n    //compute collision\n    this.tmpBox.copy(this.boundingBox);\n    this.tmpPlane.copy(this.portalPlane);\n    this.tmpBox.applyMatrix4(this.portalA.matrixWorld);\n    this.tmpPlane.applyMatrix4(this.portalA.matrixWorld);\n    this.playerService.getCurrentPlayer().getHeadPosition(this.tmpPos);\n    this.three.camera.getWorldDirection(this.tmpDir);\n    //this.tmpPos.add(this.tmpDir.multiplyScalar(0.30));\n    const isColliding = this.tmpBox.containsPoint(this.tmpPos);\n    if (isColliding) {\n      if (this.lastDistance !== 0) {\n        // - * + => - / + * - => - => this means we traversed the plan\n        if (\n          this.tmpPlane.distanceToPoint(this.tmpPos) * this.lastDistance <\n          0\n        ) {\n          //enter\n          console.log(\"enter\");\n          if (\n            this.targetWorld &&\n            this.targetLink &&\n            this.targetPlayerService &&\n            this.gracePeriode == 0\n          ) {\n            this.targetLink.gracePeriode = 5;\n            this.targetLink.collidingLastFrame = true; //sync colliding flag\n            this.targetLink.lastDistance = this.lastDistance;\n            this.playerService.getCurrentPlayer().getHeadPosition(this.tmpPos); //right head position before teleport\n            this.targetPlayerService\n              .getCurrentPlayer()\n              .teleportToLocation(this.tmpPos.x, this.tmpPos.y, this.tmpPos.z);\n            console.log(\"teleport\");\n            this.worldService.setActiveWorld(this.targetWorld);\n            this.targetPlayerService\n              .getCurrentPlayer()\n              .teleportToLocation(this.tmpPos.x, this.tmpPos.y, this.tmpPos.z);\n          }\n        }\n      }\n      this.lastDistance = this.tmpPlane.distanceToPoint(this.tmpPos);\n    } else if (!isColliding && this.lastDistance !== 0) {\n      //leave\n      this.lastDistance = 0;\n      console.log(\"leave\");\n    }\n    this.collidingLastFrame = isColliding;\n  }\n\n  renderPortal() {\n    if (!this.targetThreeLib) {\n      return;\n    }\n    this.portalA.layers.set(tmpVisibleLayer); //Portal to render to layer 1\n\n    // relatively align other camera with main camera\n\n    let relativePosition = this.portalA.worldToLocal(\n      this.three.camera.position.clone()\n    );\n    this.otherCamera.position.copy(this.portalB.localToWorld(relativePosition));\n\n    let relativeRotation = this.three.camera.quaternion\n      .clone()\n      .multiply(this.portalA.quaternion.clone().invert());\n    this.otherCamera.quaternion.copy(\n      relativeRotation.multiply(this.portalB.quaternion)\n    );\n\n    // keep camera tilt in sync\n    this.otherCamera.rotation.x = this.three.camera.rotation.x;\n\n    let gl = this.three.renderer.getContext();\n\n    // FIRST PASS\n    // goal: using the stencil buffer, place 1's in position of first portal\n\n    // enable the stencil buffer\n    gl.enable(gl.STENCIL_TEST);\n\n    // layer 1 contains only the first portal\n    this.three.camera.layers.set(tmpVisibleLayer);\n\n    gl.stencilFunc(gl.ALWAYS, 1, 0xff);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n    gl.stencilMask(0xff);\n\n    // only write to stencil buffer (not color or depth)\n    gl.colorMask(false, false, false, false);\n    gl.depthMask(false);\n\n    this.three.renderer.render(this.three.scene, this.three.camera);\n    //this.three.renderer.render( this.targetThreeLib.scene, this.targetThreeLib.camera );\n\n    // SECOND PASS\n    // goal: draw from the portal camera perspective (which is aligned relative to the second portal)\n    //   in the first portal region (set by the stencil in the previous pass)\n\n    // set up a clipping plane, so that portal camera does not see anything between\n    //   the portal camera and the second portal\n\n    // default normal of a plane is 0,0,1. apply mesh rotation to it.\n\n    // determine which side of the plane camera is on, for clipping plane orientation.\n    let portalToCamera = new Vector3().subVectors(\n      this.three.camera.position.clone(),\n      this.portalA.position.clone()\n    ); //  applyQuaternion( mainMover.quaternion );\n    let normalPortal = new Vector3(0, 0, 1).applyQuaternion(\n      this.portalA.quaternion\n    );\n    let clipSide = -Math.sign(portalToCamera.dot(normalPortal));\n\n    let clipNormal = new Vector3(0, 0, clipSide).applyQuaternion(\n      this.portalB.quaternion\n    );\n    let clipPoint = this.portalB.position;\n    let clipPlane = new Plane().setFromNormalAndCoplanarPoint(\n      clipNormal,\n      clipPoint\n    );\n    this.three.renderer.clippingPlanes = [clipPlane];\n\n    gl.colorMask(true, true, true, true);\n    gl.depthMask(true);\n\n    gl.stencilFunc(gl.EQUAL, 1, 0xff);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\n    this.otherCamera.layers.set(regularLayer);\n    //this.three.renderer.render( this.three.scene, this.otherCamera );//TODO maybe here scene 2\n    this.three.renderer.render(this.targetThreeLib.scene, this.otherCamera);\n\n    // disable clipping planes\n    this.three.renderer.clippingPlanes = [];\n\n    // THIRD PASS\n    // goal: set the depth buffer data for the first portal,\n    //   so that it can be occluded by other objects\n\n    // finished with stencil\n    gl.disable(gl.STENCIL_TEST);\n\n    gl.colorMask(false, false, false, false);\n    gl.depthMask(true);\n    // need to clear the depth buffer, in case of occlusion\n    this.three.renderer.render(this.three.scene, this.three.camera);\n\n    this.three.camera.layers.set(regularLayer); // layer 0 contains everything but portals\n    this.portalA.layers.set(invisibleLayer); //Portal to render to layer 1\n  }\n\n  getType(): string {\n    return PortalLink.name;\n  }\n}\n"],"names":["Factory","world","config","services","getFirstComponentByType","ServiceEntity","codeLoader","getService","CODE_LOADER_MODULE_NAME","three","service","playerService","worldService","portalLink","PortalLink","position","Vector3","in","x","y","z","out","awaitInitialLoading","then","async","worldExist","url","getWorld","initHtmlFromUrl","notifylWorld","setTargetWorld","this","targetWorld","targetWorldService","targetThreeLib","targetPlayerService","otherPortals","getComponentByType","name","length","console","error","op","inPosition","equals","outPosition","targetLink","Error","portals","addPortalRenderLoop","renderPortal","addPortalLoop","delta","computerPortalEnter","constructor","Box3","Plane","otherCamera","PerspectiveCamera","camera","fov","window","innerWidth","innerHeight","near","far","scene","add","defaultMaterial","MeshBasicMaterial","color","side","DoubleSide","transparent","portalA","Mesh","CircleGeometry","clone","material","opacity","copy","rotation","setRotationFromEuler","layers","set","geometry","computeBoundingBox","portalPlane","boundingBox","minBox","union","defaultMaterial2","portalB","isActiveWorld","gracePeriode","tmpBox","tmpPlane","applyMatrix4","matrixWorld","getCurrentPlayer","getHeadPosition","tmpPos","getWorldDirection","tmpDir","isColliding","containsPoint","lastDistance","distanceToPoint","log","collidingLastFrame","teleportToLocation","setActiveWorld","relativePosition","worldToLocal","localToWorld","relativeRotation","quaternion","multiply","invert","gl","renderer","getContext","enable","STENCIL_TEST","stencilFunc","ALWAYS","stencilOp","KEEP","REPLACE","stencilMask","colorMask","depthMask","render","portalToCamera","subVectors","normalPortal","applyQuaternion","clipSide","Math","sign","dot","clipNormal","clipPoint","clipPlane","setFromNormalAndCoplanarPoint","clippingPlanes","EQUAL","disable","getType"],"sourceRoot":""}