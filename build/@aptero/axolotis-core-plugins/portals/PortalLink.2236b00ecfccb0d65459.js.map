{"version":3,"file":"@aptero/axolotis-core-plugins/portals/PortalLink.2236b00ecfccb0d65459.js","mappings":"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","sources":["webpack://axolotis-core-plugins/./src/lib/modules/portals/PortalLink.ts"],"sourcesContent":["import { ServiceEntity } from \"@aptero/axolotis-player\";\nimport { WorldEntity } from \"@aptero/axolotis-player\";\nimport { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\nimport { PortalsService } from \"./PortalsService\";\nimport { PlayerService } from \"../controller/PlayerService\";\nimport { ComponentFactory } from \"@aptero/axolotis-player/build/types/modules/core/ecs/ComponentFactory\";\nimport Component from \"@aptero/axolotis-player/build/types/modules/core/ecs/Component\";\nimport { initHtmlFromUrl } from \"@aptero/axolotis-player\";\nimport {\n  Box3,\n  CircleGeometry,\n  DoubleSide,\n  Mesh,\n  MeshBasicMaterial,\n  PerspectiveCamera,\n  Plane,\n  Vector3,\n} from \"three\";\nimport {\n  CODE_LOADER_MODULE_NAME,\n  InitialComponentLoader,\n} from \"@aptero/axolotis-player\";\nimport { WebpackLazyModule } from \"@root/lib/generated/webpack/WebpackLoader\";\nimport { WorldService } from \"@root/lib/modules/worlds/WorldService\";\nimport {Services} from \"@aptero/axolotis-player\";\n\n//https://barthaweb.com/2020/09/webgl-portal/\n//https://github.com/stemkoski/AR-Examples/blob/master/portal-view.html\n//https://stemkoski.github.io/AR-Examples/portal-view.html\n//https://discourse.threejs.org/t/multiple-scenes-vs-layers/12503/10\n\n//TODO an iframe per world maybe?\n//https://web.dev/origin-agent-cluster/\n\nexport class Factory\n  implements WebpackLazyModule, ComponentFactory<PortalLink>\n{\n  async createComponent(\n    world: WorldEntity,\n    config: {\n      url: string;\n      in: { x: number; y: number; z: number };\n      out: { x: number; y: number; z: number };\n    }\n  ): Promise<PortalLink> {\n    let services = world.getFirstComponentByType<ServiceEntity>(\n      ServiceEntity.name\n    );\n    let codeLoader = await services.getService<InitialComponentLoader>(\n      CODE_LOADER_MODULE_NAME\n    );\n    let three = await services.getService<ThreeLib>(\n      \"@aptero/axolotis-core-plugins/three/ThreeLib\"\n    );\n    let service = await services.getService<PortalsService>(\n      \"@aptero/axolotis-core-plugins/portals/PortalsService\"\n    );\n    let playerService = await services.getService<PlayerService>(\n      \"@aptero/axolotis-core-plugins/controller/PlayerService\"\n    );\n    let worldService = await services.getService<WorldService>(\n      \"@aptero/axolotis-core-plugins/core/WorldService\"\n    );\n    let portalLink = new PortalLink(\n      service,\n      three,\n      playerService,\n      worldService,\n      {\n        position: new Vector3(config.in?.x, config.in?.y, config.in?.z),\n      },\n      {\n        position: new Vector3(config.out?.x, config.out?.y, config.out?.z),\n      }\n    );\n    codeLoader.awaitInitialLoading().then(async (value) => {\n      let world;\n      if (service.worldExist(config.url)) {\n        world = service.getWorld(config.url);\n      } else {\n        world = await initHtmlFromUrl(config.url);\n        service.notifylWorld(config.url, world);\n      }\n      portalLink.setTargetWorld(world);\n    });\n    return portalLink;\n  }\n}\n\nconst invisibleLayer = 31;\nconst tmpVisibleLayer = 30;\nconst regularLayer = 0;\n\nexport class PortalLink implements Component {\n  private otherCamera: THREE.PerspectiveCamera;\n  private portalA: THREE.Mesh<THREE.CircleGeometry, THREE.MeshBasicMaterial>;\n  private portalB: THREE.Mesh<THREE.CircleGeometry, THREE.MeshBasicMaterial>;\n  private targetWorld: WorldEntity | null = null;\n  private targetThreeLib: ThreeLib | null = null;\n  private boundingBox: THREE.Box3;\n  private targetLink: PortalLink | null = null;\n  private portalPlane: THREE.Plane;\n  private targetPlayerService: PlayerService | null = null;\n\n  async setTargetWorld(world: WorldEntity) {\n    this.targetWorld = world;\n    if(!this.targetWorld){\n      throw new Error();\n    }\n    let targetWorldService = await (this.targetWorld as WorldEntity).getFirstComponentByType<Services>(\n          Services.name\n      );\n    this.targetThreeLib = await targetWorldService.getService<ThreeLib>(\n      \"@aptero/axolotis-core-plugins/three/ThreeLib\"\n    );\n    this.targetPlayerService =\n      await targetWorldService.getService<PlayerService>(\n        \"@aptero/axolotis-core-plugins/controller/PlayerService\"\n      );\n    let otherPortals: PortalLink[] = await world.getComponentByType<PortalLink>(\n      PortalLink.name\n    );\n    if (otherPortals.length === 0) {\n      console.error(\"no destination portal present\");\n    }\n    for (const op of otherPortals) {\n      if (op.inPosition.position.equals(this.outPosition.position)) {\n        // && op.key === this.key\n        this.targetLink = op;\n      }\n    }\n    if (this.targetLink) {\n      this.portals.addPortalRenderLoop(() => {\n        this.renderPortal();\n      });\n      this.portals.addPortalLoop((delta) => {\n        this.computerPortalEnter();\n      });\n    } else {\n      throw new Error(\"invalid portal init: target portal in wrong state\");\n    }\n  }\n\n  constructor(\n    private portals: PortalsService,\n    private three: ThreeLib,\n    private playerService: PlayerService,\n    private worldService: WorldService,\n    private inPosition: { position: THREE.Vector3; rotation?: THREE.Euler },\n    private outPosition: { position: THREE.Vector3; rotation?: THREE.Euler }\n  ) {\n    this.otherCamera = new PerspectiveCamera(\n      three.camera.fov,\n      window.innerWidth / window.innerHeight,\n      this.three.camera.near,\n      this.three.camera.far\n    );\n    three.scene.add(this.otherCamera);\n\n    // Portal A (Portal View) ================================\n    let defaultMaterial = new MeshBasicMaterial({\n      color: 0xff0000,\n      side: DoubleSide,\n      transparent: true,\n    });\n\n    this.portalA = new Mesh(\n      new CircleGeometry(1, 64),\n      //new THREE.BoxGeometry( 1, 1, 1 ),\n      defaultMaterial.clone()\n    );\n    this.portalA.material.opacity = 0;\n    this.portalA.position.copy(inPosition.position);\n    if (inPosition.rotation) {\n      this.portalA.setRotationFromEuler(inPosition.rotation);\n    }\n    this.portalA.layers.set(invisibleLayer); //invisible layer storage\n    three.scene.add(this.portalA);\n    this.portalA.geometry.computeBoundingBox();\n    this.portalPlane = new Plane(new Vector3(0, 0, 1)); //TODO remember to move and oriente the plan to follow the portal\n    //const helper = new THREE.PlaneHelper( this.portalPlane, 1, 0xffff00 );\n    //this.three.scene.add( helper );\n    this.boundingBox = new Box3();\n    this.boundingBox.copy(this.portalA.geometry.boundingBox || new Box3());\n    let minBox = new Box3(\n      new Vector3(-0.2, -0.2, -0.2),\n      new Vector3(0.2, 0.2, 0.2)\n    );\n    this.boundingBox = this.boundingBox.union(minBox);\n    //const helper = new THREE.Box3Helper( this.boundingBox,0xffff00 as any );\n    //this.three.scene.add( helper );\n    // Portal B (Point of View position and rotation) ================================\n    // material for portals and blockers\n    let defaultMaterial2 = new MeshBasicMaterial({\n      color: 0xffffff,\n      side: DoubleSide,\n      transparent: true,\n    });\n\n    this.portalB = new Mesh(\n      new CircleGeometry(1, 64),\n      defaultMaterial2.clone()\n    );\n    this.portalB.material.opacity = 0;\n    this.portalB.position.copy(outPosition.position);\n    if (outPosition.rotation) {\n      this.portalB.setRotationFromEuler(outPosition.rotation);\n    }\n    three.scene.add(this.portalB);\n  }\n\n  tmpPos: THREE.Vector3 = new Vector3();\n  tmpDir: THREE.Vector3 = new Vector3();\n  tmpBox: THREE.Box3 = new Box3();\n  tmpPlane: THREE.Plane = new Plane();\n  collidingLastFrame: boolean = false;\n  lastDistance: number = 0;\n  gracePeriode = 0; //in FPS\n\n  computerPortalEnter() {\n    if (!this.worldService.isActiveWorld()) {\n      return;\n    }\n    if (this.gracePeriode > 0) {\n      this.gracePeriode--;\n    }\n    //compute collision\n    this.tmpBox.copy(this.boundingBox);\n    this.tmpPlane.copy(this.portalPlane);\n    this.tmpBox.applyMatrix4(this.portalA.matrixWorld);\n    this.tmpPlane.applyMatrix4(this.portalA.matrixWorld);\n    this.playerService.getCurrentPlayer().getHeadPosition(this.tmpPos);\n    this.three.camera.getWorldDirection(this.tmpDir);\n    //this.tmpPos.add(this.tmpDir.multiplyScalar(0.30));\n    const isColliding = this.tmpBox.containsPoint(this.tmpPos);\n    if (isColliding) {\n      if (this.lastDistance !== 0) {\n        // - * + => - / + * - => - => this means we traversed the plan\n        if (\n          this.tmpPlane.distanceToPoint(this.tmpPos) * this.lastDistance <\n          0\n        ) {\n          //enter\n          console.log(\"enter\");\n          if (\n            this.targetWorld &&\n            this.targetLink &&\n            this.targetPlayerService &&\n            this.gracePeriode == 0\n          ) {\n            this.targetLink.gracePeriode = 5;\n            this.targetLink.collidingLastFrame = true; //sync colliding flag\n            this.targetLink.lastDistance = this.lastDistance;\n            this.playerService.getCurrentPlayer().getHeadPosition(this.tmpPos); //right head position before teleport\n            this.targetPlayerService\n              .getCurrentPlayer()\n              .teleportToLocation(this.tmpPos.x, this.tmpPos.y, this.tmpPos.z);\n            console.log(\"teleport\");\n            this.worldService.setActiveWorld(this.targetWorld);\n            this.targetPlayerService\n              .getCurrentPlayer()\n              .teleportToLocation(this.tmpPos.x, this.tmpPos.y, this.tmpPos.z);\n          }\n        }\n      }\n      this.lastDistance = this.tmpPlane.distanceToPoint(this.tmpPos);\n    } else if (!isColliding && this.lastDistance !== 0) {\n      //leave\n      this.lastDistance = 0;\n      console.log(\"leave\");\n    }\n    this.collidingLastFrame = isColliding;\n  }\n\n  renderPortal() {\n    if (!this.targetThreeLib) {\n      return;\n    }\n    this.portalA.layers.set(tmpVisibleLayer); //Portal to render to layer 1\n\n    // relatively align other camera with main camera\n\n    let relativePosition = this.portalA.worldToLocal(\n      this.three.camera.position.clone()\n    );\n    this.otherCamera.position.copy(this.portalB.localToWorld(relativePosition));\n\n    let relativeRotation = this.three.camera.quaternion\n      .clone()\n      .multiply(this.portalA.quaternion.clone().invert());\n    this.otherCamera.quaternion.copy(\n      relativeRotation.multiply(this.portalB.quaternion)\n    );\n\n    // keep camera tilt in sync\n    this.otherCamera.rotation.x = this.three.camera.rotation.x;\n\n    let gl = this.three.renderer.getContext();\n\n    // FIRST PASS\n    // goal: using the stencil buffer, place 1's in position of first portal\n\n    // enable the stencil buffer\n    gl.enable(gl.STENCIL_TEST);\n\n    // layer 1 contains only the first portal\n    this.three.camera.layers.set(tmpVisibleLayer);\n\n    gl.stencilFunc(gl.ALWAYS, 1, 0xff);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n    gl.stencilMask(0xff);\n\n    // only write to stencil buffer (not color or depth)\n    gl.colorMask(false, false, false, false);\n    gl.depthMask(false);\n\n    this.three.renderer.render(this.three.scene, this.three.camera);\n    //this.three.renderer.render( this.targetThreeLib.scene, this.targetThreeLib.camera );\n\n    // SECOND PASS\n    // goal: draw from the portal camera perspective (which is aligned relative to the second portal)\n    //   in the first portal region (set by the stencil in the previous pass)\n\n    // set up a clipping plane, so that portal camera does not see anything between\n    //   the portal camera and the second portal\n\n    // default normal of a plane is 0,0,1. apply mesh rotation to it.\n\n    // determine which side of the plane camera is on, for clipping plane orientation.\n    let portalToCamera = new Vector3().subVectors(\n      this.three.camera.position.clone(),\n      this.portalA.position.clone()\n    ); //  applyQuaternion( mainMover.quaternion );\n    let normalPortal = new Vector3(0, 0, 1).applyQuaternion(\n      this.portalA.quaternion\n    );\n    let clipSide = -Math.sign(portalToCamera.dot(normalPortal));\n\n    let clipNormal = new Vector3(0, 0, clipSide).applyQuaternion(\n      this.portalB.quaternion\n    );\n    let clipPoint = this.portalB.position;\n    let clipPlane = new Plane().setFromNormalAndCoplanarPoint(\n      clipNormal,\n      clipPoint\n    );\n    this.three.renderer.clippingPlanes = [clipPlane];\n\n    gl.colorMask(true, true, true, true);\n    gl.depthMask(true);\n\n    gl.stencilFunc(gl.EQUAL, 1, 0xff);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\n    this.otherCamera.layers.set(regularLayer);\n    //this.three.renderer.render( this.three.scene, this.otherCamera );//TODO maybe here scene 2\n    this.three.renderer.render(this.targetThreeLib.scene, this.otherCamera);\n\n    // disable clipping planes\n    this.three.renderer.clippingPlanes = [];\n\n    // THIRD PASS\n    // goal: set the depth buffer data for the first portal,\n    //   so that it can be occluded by other objects\n\n    // finished with stencil\n    gl.disable(gl.STENCIL_TEST);\n\n    gl.colorMask(false, false, false, false);\n    gl.depthMask(true);\n    // need to clear the depth buffer, in case of occlusion\n    this.three.renderer.render(this.three.scene, this.three.camera);\n\n    this.three.camera.layers.set(regularLayer); // layer 0 contains everything but portals\n    this.portalA.layers.set(invisibleLayer); //Portal to render to layer 1\n  }\n\n  getType(): string {\n    return PortalLink.name;\n  }\n}\n"],"names":["Factory","world","config","services","getFirstComponentByType","ServiceEntity","codeLoader","getService","CODE_LOADER_MODULE_NAME","three","service","playerService","worldService","portalLink","PortalLink","position","Vector3","in","x","y","z","out","awaitInitialLoading","then","async","worldExist","url","getWorld","initHtmlFromUrl","notifylWorld","setTargetWorld","this","targetWorld","Error","targetWorldService","Services","targetThreeLib","targetPlayerService","otherPortals","getComponentByType","name","length","console","error","op","inPosition","equals","outPosition","targetLink","portals","addPortalRenderLoop","renderPortal","addPortalLoop","delta","computerPortalEnter","constructor","Box3","Plane","otherCamera","PerspectiveCamera","camera","fov","window","innerWidth","innerHeight","near","far","scene","add","defaultMaterial","MeshBasicMaterial","color","side","DoubleSide","transparent","portalA","Mesh","CircleGeometry","clone","material","opacity","copy","rotation","setRotationFromEuler","layers","set","geometry","computeBoundingBox","portalPlane","boundingBox","minBox","union","defaultMaterial2","portalB","isActiveWorld","gracePeriode","tmpBox","tmpPlane","applyMatrix4","matrixWorld","getCurrentPlayer","getHeadPosition","tmpPos","getWorldDirection","tmpDir","isColliding","containsPoint","lastDistance","distanceToPoint","log","collidingLastFrame","teleportToLocation","setActiveWorld","relativePosition","worldToLocal","localToWorld","relativeRotation","quaternion","multiply","invert","gl","renderer","getContext","enable","STENCIL_TEST","stencilFunc","ALWAYS","stencilOp","KEEP","REPLACE","stencilMask","colorMask","depthMask","render","portalToCamera","subVectors","normalPortal","applyQuaternion","clipSide","Math","sign","dot","clipNormal","clipPoint","clipPlane","setFromNormalAndCoplanarPoint","clippingPlanes","EQUAL","disable","getType"],"sourceRoot":""}