/*!
 * 
 *   @aptero/axolotis-core-plugins v1.0.0
 *   https://github.com/ApteroSAS/axolotis-player
 *
 *   Copyright (c) Aptero (https://github.com/ApteroSAS/axolotis-player) and project contributors.
 *
 *   This source code is licensed under the MIT license found in the
 *   LICENSE file in the root directory of this source tree.
 *
 */
"use strict";(self.webpackChunkaxolotis_core_plugins=self.webpackChunkaxolotis_core_plugins||[]).push([[718],{7:function(t,e,i){i.r(e),i.d(e,{Factory:function(){return p},default:function(){return d}});var s=i(477),o=i(988);class n{static roundNumber(t,e){const i=Math.pow(10,e);return Math.round(t*i)/i}static sample(t){return t[Math.floor(Math.random()*t.length)]}static distanceToSquared(t,e){var i=t.x-e.x,s=t.y-e.y,o=t.z-e.z;return i*i+s*s+o*o}static isPointInPoly(t,e){for(var i=!1,s=-1,o=t.length,n=o-1;++s<o;n=s)(t[s].z<=e.z&&e.z<t[n].z||t[n].z<=e.z&&e.z<t[s].z)&&e.x<(t[n].x-t[s].x)*(e.z-t[s].z)/(t[n].z-t[s].z)+t[s].x&&(i=!i);return i}static isVectorInPolygon(t,e,i){var s=1e5,o=-1e5,n=[];return e.vertexIds.forEach((t=>{s=Math.min(i[t].y,s),o=Math.max(i[t].y,o),n.push(i[t])})),!!(t.y<o+.5&&t.y>s-.5&&this.isPointInPoly(n,t))}static triarea2(t,e,i){return(i.x-t.x)*(e.z-t.z)-(e.x-t.x)*(i.z-t.z)}static vequal(t,e){return this.distanceToSquared(t,e)<1e-5}static mergeVertices(t,e=1e-4){e=Math.max(e,Number.EPSILON);for(var i={},o=t.getIndex(),n=t.getAttribute("position"),r=o?o.count:n.count,h=0,c=[],a=[],u=Math.log10(1/e),l=Math.pow(10,u),p=0;p<r;p++){var d=o?o.getX(p):p,v="";v+=~~(n.getX(d)*l)+",",v+=~~(n.getY(d)*l)+",",(v+=~~(n.getZ(d)*l)+",")in i?c.push(i[v]):(a.push(n.getX(d)),a.push(n.getY(d)),a.push(n.getZ(d)),i[v]=h,c.push(h),h++)}const g=new s.BufferAttribute(new Float32Array(a),n.itemSize,n.normalized),m=new s.BufferGeometry;return m.setAttribute("position",g),m.setIndex(c),m}}class r{constructor(t){this.content=[],this.scoreFunction=t}push(t){this.content.push(t),this.sinkDown(this.content.length-1)}pop(){const t=this.content[0],e=this.content.pop();return this.content.length>0&&(this.content[0]=e,this.bubbleUp(0)),t}remove(t){const e=this.content.indexOf(t),i=this.content.pop();e!==this.content.length-1&&(this.content[e]=i,this.scoreFunction(i)<this.scoreFunction(t)?this.sinkDown(e):this.bubbleUp(e))}size(){return this.content.length}rescoreElement(t){this.sinkDown(this.content.indexOf(t))}sinkDown(t){const e=this.content[t];for(;t>0;){const i=(t+1>>1)-1,s=this.content[i];if(!(this.scoreFunction(e)<this.scoreFunction(s)))break;this.content[i]=e,this.content[t]=s,t=i}}bubbleUp(t){const e=this.content.length,i=this.content[t],s=this.scoreFunction(i);for(;;){const o=t+1<<1,n=o-1;let r,h=null;if(n<e&&(r=this.scoreFunction(this.content[n]),r<s&&(h=n)),o<e&&this.scoreFunction(this.content[o])<(null===h?s:r)&&(h=o),null===h)break;this.content[t]=this.content[h],this.content[h]=i,t=h}}}class h{constructor(){this.portals=[]}push(t,e){void 0===e&&(e=t),this.portals.push({left:t,right:e})}stringPull(){const t=this.portals,e=[];let i,s,o,r=0,h=0,c=0;i=t[0].left,s=t[0].left,o=t[0].right,e.push(i);for(let a=1;a<t.length;a++){const u=t[a].left,l=t[a].right;if(n.triarea2(i,o,l)<=0){if(!(n.vequal(i,o)||n.triarea2(i,s,l)>0)){e.push(s),i=s,r=h,s=i,o=i,h=r,c=r,a=r;continue}o=l,c=a}if(n.triarea2(i,s,u)>=0){if(!(n.vequal(i,s)||n.triarea2(i,o,u)<0)){e.push(o),i=o,r=c,s=i,o=i,h=r,c=r,a=r;continue}s=u,h=a}}return 0!==e.length&&n.vequal(e[e.length-1],t[t.length-1].left)||e.push(t[t.length-1].left),this.path=e,e}}class c{constructor(){this.zones={}}static createZone(t,e=1e-4){return class{static buildZone(t,e){const i=this._buildNavigationMesh(t,e),o={};i.vertices.forEach((t=>{t.x=n.roundNumber(t.x,2),t.y=n.roundNumber(t.y,2),t.z=n.roundNumber(t.z,2)})),o.vertices=i.vertices;const r=this._buildPolygonGroups(i);return o.groups=new Array(r.length),r.forEach(((t,e)=>{const i=new Map;t.forEach(((t,e)=>{i.set(t,e)}));const r=new Array(t.length);t.forEach(((t,e)=>{const h=[];t.neighbours.forEach((t=>h.push(i.get(t))));const c=[];t.neighbours.forEach((e=>c.push(this._getSharedVerticesInOrder(t,e))));const a=new s.Vector3(0,0,0);a.add(o.vertices[t.vertexIds[0]]),a.add(o.vertices[t.vertexIds[1]]),a.add(o.vertices[t.vertexIds[2]]),a.divideScalar(3),a.x=n.roundNumber(a.x,2),a.y=n.roundNumber(a.y,2),a.z=n.roundNumber(a.z,2),r[e]={id:e,neighbours:h,vertexIds:t.vertexIds,centroid:a,portals:c}})),o.groups[e]=r})),o}static _buildNavigationMesh(t,e){return t=n.mergeVertices(t,e),this._buildPolygonsFromGeometry(t)}static _spreadGroupId(t){let e=new Set([t]);for(;e.size>0;){const i=e;e=new Set,i.forEach((i=>{i.group=t.group,i.neighbours.forEach((t=>{void 0===t.group&&e.add(t)}))}))}}static _buildPolygonGroups(t){const e=[];return t.polygons.forEach((t=>{void 0!==t.group?e[t.group].push(t):(t.group=e.length,this._spreadGroupId(t),e.push([t]))})),e}static _buildPolygonNeighbours(t,e){const i=new Set,s=e[t.vertexIds[1]],o=e[t.vertexIds[2]];return e[t.vertexIds[0]].forEach((e=>{e!==t&&(s.includes(e)||o.includes(e))&&i.add(e)})),s.forEach((e=>{e!==t&&o.includes(e)&&i.add(e)})),i}static _buildPolygonsFromGeometry(t){const e=[],i=[],o=t.attributes.position,n=t.index,r=[];for(let t=0;t<o.count;t++)i.push((new s.Vector3).fromBufferAttribute(o,t)),r[t]=[];for(let i=0;i<t.index.count;i+=3){const t=n.getX(i),s=n.getX(i+1),o=n.getX(i+2),h={vertexIds:[t,s,o],neighbours:null};e.push(h),r[t].push(h),r[s].push(h),r[o].push(h)}return e.forEach((t=>{t.neighbours=this._buildPolygonNeighbours(t,r)})),{polygons:e,vertices:i}}static _getSharedVerticesInOrder(t,e){const i=t.vertexIds,s=i[0],o=i[1],n=i[2],r=e.vertexIds,h=r.includes(s),c=r.includes(o),a=r.includes(n);return h&&c&&a?Array.from(i):h&&c?[s,o]:c&&a?[o,n]:h&&a?[n,s]:(console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."),[])}}.buildZone(t,e)}setZoneData(t,e){this.zones[t]=e}getRandomNode(t,e,i,o){if(!this.zones[t])return new s.Vector3;i=i||null,o=o||0;const r=[];return this.zones[t].groups[e].forEach((t=>{i&&o?n.distanceToSquared(i,t.centroid)<o*o&&r.push(t.centroid):r.push(t.centroid)})),n.sample(r)||new s.Vector3}getClosestNode(t,e,i,s=!1){const o=this.zones[e].vertices;let r=null,h=1/0;return this.zones[e].groups[i].forEach((e=>{const i=n.distanceToSquared(e.centroid,t);i<h&&(!s||n.isVectorInPolygon(t,e,o))&&(r=e,h=i)})),r}findPath(t,e,i,o){const c=this.zones[i].groups[o],a=this.zones[i].vertices,u=this.getClosestNode(t,i,o,!0),l=this.getClosestNode(e,i,o,!0);if(!u||!l)return null;const p=class{static init(t){for(let e=0;e<t.length;e++){const i=t[e];i.f=0,i.g=0,i.h=0,i.cost=1,i.visited=!1,i.closed=!1,i.parent=null}}static cleanUp(t){for(let e=0;e<t.length;e++){const i=t[e];delete i.f,delete i.g,delete i.h,delete i.cost,delete i.visited,delete i.closed,delete i.parent}}static heap(){return new r((function(t){return t.f}))}static search(t,e,i){this.init(t);const s=this.heap();for(s.push(e);s.size()>0;){const e=s.pop();if(e===i){let t=e;const i=[];for(;t.parent;)i.push(t),t=t.parent;return this.cleanUp(i),i.reverse()}e.closed=!0;const o=this.neighbours(t,e);for(let t=0,n=o.length;t<n;t++){const n=o[t];if(n.closed)continue;const r=e.g+n.cost,h=n.visited;if(!h||r<n.g){if(n.visited=!0,n.parent=e,!n.centroid||!i.centroid)throw new Error("Unexpected state");n.h=n.h||this.heuristic(n.centroid,i.centroid),n.g=r,n.f=n.g+n.h,h?s.rescoreElement(n):s.push(n)}}}return[]}static heuristic(t,e){return n.distanceToSquared(t,e)}static neighbours(t,e){const i=[];for(let s=0;s<e.neighbours.length;s++)i.push(t[e.neighbours[s]]);return i}}.search(c,u,l),d=function(t,e){for(var i=0;i<t.neighbours.length;i++)if(t.neighbours[i]===e.id)return t.portals[i]},v=new h;v.push(t);for(let t=0;t<p.length;t++){const e=p[t],i=p[t+1];if(i){const t=d(e,i);v.push(a[t[0]],a[t[1]])}}v.push(e),v.stringPull();const g=v.path.map((t=>new s.Vector3(t.x,t.y,t.z)));return g.shift(),g}}c.prototype.getGroup=function(){const t=new s.Plane;return function(e,i,s=!1){if(!this.zones[e])return null;let o=null,r=Math.pow(50,2);const h=this.zones[e];for(let e=0;e<h.groups.length;e++){const c=h.groups[e];for(const a of c){if(s&&(t.setFromCoplanarPoints(h.vertices[a.vertexIds[0]],h.vertices[a.vertexIds[1]],h.vertices[a.vertexIds[2]]),Math.abs(t.distanceToPoint(i))<.01)&&n.isPointInPoly([h.vertices[a.vertexIds[0]],h.vertices[a.vertexIds[1]],h.vertices[a.vertexIds[2]]],i))return e;const c=n.distanceToSquared(a.centroid,i);c<r&&(o=e,r=c)}}return o}}(),c.prototype.clampStep=function(){const t=new s.Vector3,e=new s.Plane,i=new s.Triangle,o=new s.Vector3;let n,r,h=new s.Vector3;return function(s,c,a,u,l,p){const d=this.zones[u].vertices,v=this.zones[u].groups[l],g=[a],m={};m[a.id]=0,n=void 0,h.set(0,0,0),r=1/0,e.setFromCoplanarPoints(d[a.vertexIds[0]],d[a.vertexIds[1]],d[a.vertexIds[2]]),e.projectPoint(c,t),o.copy(t);for(let e=g.pop();e;e=g.pop()){i.set(d[e.vertexIds[0]],d[e.vertexIds[1]],d[e.vertexIds[2]]),i.closestPointToPoint(o,t),t.distanceToSquared(o)<r&&(n=e,h.copy(t),r=t.distanceToSquared(o));const s=m[e.id];if(!(s>2))for(let t=0;t<e.neighbours.length;t++){const i=v[e.neighbours[t]];i.id in m||(g.push(i),m[i.id]=s+1)}}return p.copy(h),n}}();new s.Color(15631215).convertSRGBToLinear().getHex(),new s.Color(14469912).convertSRGBToLinear().getHex(),new s.Color(41903).convertSRGBToLinear().getHex(),new s.Color(41903).convertSRGBToLinear().getHex(),new s.Color(14472114).convertSRGBToLinear().getHex(),new s.Color(4417387).convertSRGBToLinear().getHex();function a(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}class u{constructor(){a(this,"pathfinder",void 0),a(this,"mesh",void 0),a(this,"zone","character"),a(this,"navGroup",null),a(this,"navNode",null),a(this,"findPOVPositionAboveNavMesh",(()=>{const t=new s.Vector3,e=new s.Vector3;return(i,s,o)=>(t.copy(i),t.y-=2,e.copy(s),e.y-=2,this.findPositionOnNavMesh(t,e,o),o.y+=2,o)})())}isEnabled(){return this.pathfinder&&this.zone in this.pathfinder.zones}loadMesh(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.zone;this.pathfinder=new c,this.mesh=null,this.zone=e,this.mesh&&(console.error("tried to load multiple nav meshes"),this.removeNavMeshData());const i=t.geometry;i.applyMatrix4(t.matrixWorld),this.pathfinder.setZoneData(e,c.createZone(i)),this.mesh=t}getClosestNode(t){const e=this.pathfinder;return e.zones[this.zone].groups[this.navGroup]?e.getClosestNode(t,this.zone,this.navGroup,!0)||e.getClosestNode(t,this.zone,this.navGroup):null}findPositionOnNavMesh(t,e,i){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const o=this.pathfinder;if(this.zone in o.zones)return this.navGroup=s||null===this.navGroup?o.getGroup(this.zone,e,!0,!0):this.navGroup,this.navNode=s||null===this.navNode||void 0===this.navNode?this.getClosestNode(e):this.navNode,null===this.navNode||void 0===this.navNode?i.copy(e):this.navNode=o.clampStep(t,e,this.navNode,this.zone,this.navGroup,i),i}removeNavMeshData(){this.mesh&&this.mesh.geometry&&this.mesh.geometry.dispose&&this.mesh.geometry.dispose(),this.mesh=null,this.pathfinder.zones={}}}function l(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}class p{async createComponent(t,e){let i=t.getFirstComponentByType(o.Services.name),n=await i.getService("@aptero/axolotis-core-plugins/three/ThreeLib"),r=await i.getService("@aptero/axolotis-core-plugins/controller/pathFindingPlayer/Input"),h=await i.getService("@aptero/axolotis-core-plugins/controller/PlayerService"),c=await i.getService("@aptero/axolotis-core-plugins/frame/FrameLoop"),a=new s.Vector3(e.position&&e.position.x||0,e.position&&e.position.y||0,e.position&&e.position.z||0),u=(new s.Quaternion).setFromAxisAngle(new s.Vector3(0,1,0),.5*-Math.PI),l=new d(a,u,await n,await r,h);return h.declarePlayer(l),l.Initialize(),(await c).addLoop(d.name,(t=>{l.Update(t)})),l}}class d{getType(){return d.name}askFlyMode(){}declareNavMesh(t){this.navMesh.loadMesh(t,"character")}teleportToLocation(t,e,i){this.position.copy(new s.Vector3(t,e,i))}getHeadPosition(t){t.copy(this.position)}constructor(t,e,i,o,n){this.input=o,this.playerService=n,l(this,"camera",void 0),l(this,"timeZeroToMax",void 0),l(this,"decceleration",void 0),l(this,"speed",void 0),l(this,"maxSpeed",void 0),l(this,"mouseSpeed",void 0),l(this,"acceleration",void 0),l(this,"isLocked",void 0),l(this,"angles",void 0),l(this,"pitch",void 0),l(this,"jumpVelocity",void 0),l(this,"yaw",void 0),l(this,"tempVec",void 0),l(this,"moveDir",void 0),l(this,"yOffset",void 0),l(this,"xAxis",void 0),l(this,"yAxis",void 0),l(this,"position",void 0),l(this,"positionOutTmp",new s.Vector3),l(this,"positionOutTmp2",new s.Vector3),l(this,"rotation",void 0),l(this,"velocity",void 0),l(this,"navMesh",void 0),l(this,"OnPointerlockChange",(()=>{document.pointerLockElement?this.isLocked=!0:this.isLocked=!1})),l(this,"OnMouseMove",(t=>{if(!this.isLocked)return;const{movementX:e,movementY:i}=t;this.angles.y-=e*this.mouseSpeed,this.angles.x-=i*this.mouseSpeed,this.angles.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.angles.x)),this.UpdateRotation()})),l(this,"Accelarate",((t,e)=>{const i=this.tempVec.copy(t).multiplyScalar(this.acceleration*e);this.speed.add(i),this.speed.clampLength(0,this.maxSpeed)})),l(this,"Deccelerate",(t=>{const e=this.tempVec.copy(this.speed).multiplyScalar(this.decceleration*t);this.speed.add(e)})),this.position=t,this.rotation=e,this.navMesh=new u,this.camera=i.camera,this.timeZeroToMax=.08,this.maxSpeed=7,this.speed=new s.Vector3,this.acceleration=this.maxSpeed/this.timeZeroToMax,this.decceleration=-7,this.mouseSpeed=.002,this.isLocked=!1,this.angles=new s.Euler,this.pitch=new s.Quaternion,this.yaw=new s.Quaternion,this.jumpVelocity=5,this.yOffset=2,this.tempVec=new s.Vector3,this.moveDir=new s.Vector3,this.xAxis=new s.Vector3(1,0,0),this.yAxis=new s.Vector3(0,1,0),this.velocity=new s.Vector3}Initialize(){this.angles.setFromQuaternion(this.rotation),this.UpdateRotation(),this.input.AddMouseMoveListner(this.OnMouseMove),document.addEventListener("pointerlockchange",this.OnPointerlockChange),this.input.AddClickListner((()=>{this.isLocked||document.body.requestPointerLock()}))}UpdateRotation(){this.pitch.setFromAxisAngle(this.xAxis,this.angles.x),this.yaw.setFromAxisAngle(this.yAxis,this.angles.y),this.rotation.multiplyQuaternions(this.yaw,this.pitch).normalize(),this.camera.quaternion.copy(this.rotation)}Update(t){t*=.001;const e=this.input.GetKeyDown("KeyS")-this.input.GetKeyDown("KeyW"),i=this.input.GetKeyDown("KeyD")-this.input.GetKeyDown("KeyA"),s=this.moveDir.set(i,0,e).normalize();this.Deccelerate(t),this.Accelarate(s,t);const o=this.tempVec.copy(this.speed);o.applyQuaternion(this.yaw),this.velocity.setX(o.x),this.velocity.setZ(o.z),this.velocity.multiplyScalar(t),this.positionOutTmp.x=this.position.x+this.velocity.x,this.positionOutTmp.y=this.position.y+this.velocity.y,this.positionOutTmp.z=this.position.z+this.velocity.z,this.navMesh.isEnabled()?this.navMesh.findPOVPositionAboveNavMesh(this.position,this.positionOutTmp,this.positionOutTmp2):this.positionOutTmp2.copy(this.positionOutTmp),this.camera.position.set(this.positionOutTmp2.x,this.positionOutTmp2.y,this.positionOutTmp2.z),this.position.copy(this.camera.position)}}}}]);
//# sourceMappingURL=NavMeshPlayer.712bfab68a446959eb99.js.map