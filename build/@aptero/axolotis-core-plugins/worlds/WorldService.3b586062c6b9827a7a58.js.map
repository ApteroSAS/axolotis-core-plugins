{"version":3,"file":"@aptero/axolotis-core-plugins/worlds/WorldService.3b586062c6b9827a7a58.js","mappings":";;;;;;;;;;;8RAcO,MAAMA,EACXC,eAEmB,oBAACC,GAClB,OAAO,IAAIC,EACTD,QACMA,EAASE,WACb,uDAEIF,EAASE,WACb,kDAMR,IAAIC,EAA2C,GAC3CC,EAA0C,IAOzCC,EAAAA,EAAAA,kBAAyB,UAAUC,eAEtCD,EAAAA,EAAAA,kBAAyB,UAAUE,OAAS,IAC5CF,EAAAA,EAAAA,kBAAyB,UAAUC,YAAc,QAG5C,MAAME,EACXT,YAAmBU,GAAc,KAAdA,KAAAA,EACnBC,UACE,OAAOF,EAAKC,MAGhB,IAAIE,EAAc,EACX,SAASC,EAAiBC,GAC/B,MAAMN,GAASF,EAAAA,EAAAA,kBAAyB,UAClBQ,EAAYC,wBAA8BN,EAAKC,OAEnEI,EAAYE,aAAmB,IAAIP,EAAK,SAAWG,MAErD,IAAIK,EAAYH,EAAYC,wBAA8BN,EAAKC,MAAMA,KACrEF,EAAOA,OAAOS,GAAaH,EACA,SAAvBN,EAAOD,cACTC,EAAOD,YAAcU,GAIlB,MAAMf,EAGXF,YACEC,EACAiB,EACAC,G,iBACA,G,EAAA,W,EAAA,M,sFACAN,EAAiBZ,EAASmB,YAC1BC,QAAQC,IAAI,QACZ,IAAIC,EAAgB,KACpB,IAAK,MAAMC,KAAOC,KAAKC,YAAa,CAClC,MAAMC,EAAQF,KAAKC,YAAYF,GACfG,EAAMZ,wBAAkCa,EAAAA,SAAAA,OACvC3B,IACfsB,EAAWI,GAGf,IAAKJ,EACH,MAAM,IAAIM,MAEZJ,KAAKE,MAAQJ,EAGbtB,EACGE,WAAmC2B,EAAAA,yBACnCC,MAAKC,MAAAA,UACEC,EAAWC,sBACjB,IAAK,MAAMC,KAAY9B,EACrB8B,OAGN,MAAM3B,GAASF,EAAAA,EAAAA,kBAAyB,UACb,SAAvBE,EAAOD,aACTkB,KAAKW,qBAAqB5B,EAAOD,aAerCI,UACE,OAAOT,EAAaQ,KAGtBgB,YAEE,OADoBpB,EAAAA,EAAAA,kBAAyB,UACxBE,OAGvB6B,iBACE,IAAIC,GAAgBhC,EAAAA,EAAAA,kBAAyB,UAC7C,OAAOmB,KAAKC,YAAYY,EAAc/B,aAGxCgC,gBACE,OAAOd,KAAKE,OAASF,KAAKY,iBAG5BjC,yBAAyB+B,GAA6C,IAAvBK,EAAuB,wDACpEpC,EAAyBqC,KAAKN,GAC1BK,GACFL,IAIJO,gBAAgBP,GAA6C,IAAvBK,EAAuB,wDAC3DnC,EAAwBoC,KAAKN,GACzBK,GACFL,IAIJQ,eAAehB,GACb,IAAK,MAAMH,KAAOC,KAAKC,YACrB,GAAIC,GAASF,KAAKC,YAAYF,GAE5B,YADAC,KAAKW,qBAAqBZ,GAI9B,MAAM,IAAIK,MAGZO,qBAAqB1B,GACnB,IAAI4B,GAAgBhC,EAAAA,EAAAA,kBAAyB,UAC7C,GAAIgC,EAAc/B,cAAgBG,EAAM,CACtC4B,EAAc/B,YAAcG,EAC5B,IAAK,MAAMyB,KAAY/B,EACrB+B","sources":["webpack://axolotis-core-plugins/./src/lib/modules/worlds/WorldService.ts"],"sourcesContent":["import { WebpackLazyModule } from \"@root/lib/generated/webpack/WebpackLoader\";\nimport {\n  Service,\n  InitialComponentLoader,\n  LazyServices,\n  Services,\n  WorldEntity,\n  Component,\n  CODE_LOADER_MODULE_NAME,\n  getGlobalStorage,\n} from \"@aptero/axolotis-player\";\nimport { FrameLoop } from \"@root/lib/modules/frame/FrameLoop\";\nimport { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\n\nexport class Factory implements WebpackLazyModule, Service<WorldService> {\n  constructor() {}\n\n  async createService(services: LazyServices): Promise<WorldService> {\n    return new WorldService(\n      services,\n      await services.getService<FrameLoop>(\n        \"@aptero/axolotis-core-plugins/frame/FrameLoop\"\n      ),\n      await services.getService<ThreeLib>(\n        \"@aptero/axolotis-core-plugins/three/ThreeLib\"\n      )\n    );\n  }\n}\n\nlet addOnWorldChangeCallback: (() => void)[] = []; //do not use events emitter here to avoid surcharing dependencies in the code modules\nlet addOnWorldAddedCallback: (() => void)[] = []; //do not use events emitter here to avoid surcharing dependencies in the code modules\n\ninterface Worlds {\n  activeWorld: string;\n  worlds: { [id: string]: WorldEntity };\n}\n\nif (!getGlobalStorage<Worlds>(\"worlds\").activeWorld) {\n  //initialize world service\n  getGlobalStorage<Worlds>(\"worlds\").worlds = {};\n  getGlobalStorage<Worlds>(\"worlds\").activeWorld = \"NONE\";\n}\n\nexport class Name implements Component {\n  constructor(public name: string) {}\n  getType(): string {\n    return Name.name;\n  }\n}\nlet worldNumber = 0;\nexport function registerNewWorld(worldEntity: WorldEntity) {\n  const worlds = getGlobalStorage<Worlds>(\"worlds\");\n  let componentByType = worldEntity.getFirstComponentByType<Name>(Name.name);\n  if (!componentByType) {\n    worldEntity.addComponent<Name>(new Name(\"World-\" + worldNumber++));\n  }\n  let worldName = worldEntity.getFirstComponentByType<Name>(Name.name).name;\n  worlds.worlds[worldName] = worldEntity;\n  if (worlds.activeWorld === \"NONE\") {\n    worlds.activeWorld = worldName;\n  }\n}\n\nexport class WorldService implements Component {\n  private world: WorldEntity;\n\n  constructor(\n    services: LazyServices,\n    frameLoop: FrameLoop,\n    threeLib: ThreeLib\n  ) {\n    registerNewWorld(services.getWorld());\n    console.log(\"info\");\n    let worldtmp: any = null;\n    for (const key in this.getWorlds()) {\n      const world = this.getWorlds()[key];\n      let wservices = world.getFirstComponentByType<Services>(Services.name);\n      if (wservices == services) {\n        worldtmp = world;\n      }\n    }\n    if (!worldtmp) {\n      throw new Error();\n    }\n    this.world = worldtmp;\n\n    //new world service is new world event\n    services\n      .getService<InitialComponentLoader>(CODE_LOADER_MODULE_NAME)\n      .then(async (codeLoader) => {\n        await codeLoader.awaitInitialLoading();\n        for (const callback of addOnWorldAddedCallback) {\n          callback();\n        }\n      });\n    const worlds = getGlobalStorage<Worlds>(\"worlds\");\n    if (worlds.activeWorld !== \"NONE\") {\n      this.setActiveWorldByName(worlds.activeWorld);\n    }\n\n    /*\n    TODO there is a bug with this portal system\n    this.addOnWorldChangeCallback(() => {\n      window.removeEventListener(\"resize\", threeLib.onWindowResize);\n      frameLoop.removeLoop(ThreeLib.name);\n      if (this.isActiveWorld()) {\n        window.addEventListener(\"resize\", threeLib.onWindowResize, false);\n        frameLoop.addLoop(ThreeLib.name, threeLib.render);\n      }\n    }, true);*/\n  }\n\n  getType(): string {\n    return WorldService.name;\n  }\n\n  getWorlds(): { [id: string]: WorldEntity } {\n    let globalStorage = getGlobalStorage<Worlds>(\"worlds\");\n    return globalStorage.worlds;\n  }\n\n  getActiveWorld() {\n    let globalStorage = getGlobalStorage<Worlds>(\"worlds\");\n    return this.getWorlds()[globalStorage.activeWorld];\n  }\n\n  isActiveWorld() {\n    return this.world == this.getActiveWorld();\n  }\n\n  addOnWorldChangeCallback(callback: () => void, init: boolean = false) {\n    addOnWorldChangeCallback.push(callback);\n    if (init) {\n      callback();\n    }\n  }\n\n  addOnWorldAdded(callback: () => void, init: boolean = false) {\n    addOnWorldAddedCallback.push(callback);\n    if (init) {\n      callback();\n    }\n  }\n\n  setActiveWorld(world: WorldEntity) {\n    for (const key in this.getWorlds()) {\n      if (world == this.getWorlds()[key]) {\n        this.setActiveWorldByName(key);\n        return;\n      }\n    }\n    throw new Error();\n  }\n\n  setActiveWorldByName(name: string) {\n    let globalStorage = getGlobalStorage<Worlds>(\"worlds\");\n    if (globalStorage.activeWorld !== name) {\n      globalStorage.activeWorld = name;\n      for (const callback of addOnWorldChangeCallback) {\n        callback();\n      }\n    }\n  }\n}\n"],"names":["Factory","constructor","services","WorldService","getService","addOnWorldChangeCallback","addOnWorldAddedCallback","getGlobalStorage","activeWorld","worlds","Name","name","getType","worldNumber","registerNewWorld","worldEntity","getFirstComponentByType","addComponent","worldName","frameLoop","threeLib","getWorld","console","log","worldtmp","key","this","getWorlds","world","Services","Error","CODE_LOADER_MODULE_NAME","then","async","codeLoader","awaitInitialLoading","callback","setActiveWorldByName","getActiveWorld","globalStorage","isActiveWorld","init","push","addOnWorldAdded","setActiveWorld"],"sourceRoot":""}