/*!
 * 
 *   @aptero/axolotis-core-plugins v1.0.0
 *   https://github.com/ApteroSAS/axolotis-player
 *
 *   Copyright (c) Aptero (https://github.com/ApteroSAS/axolotis-player) and project contributors.
 *
 *   This source code is licensed under the MIT license found in the
 *   LICENSE file in the root directory of this source tree.
 *
 */
"use strict";(self.webpackChunkaxolotis_core_plugins=self.webpackChunkaxolotis_core_plugins||[]).push([[826],{342:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Factory": function() { return /* binding */ Factory; },\n  "SpokeRoomLoader": function() { return /* binding */ SpokeRoomLoader; }\n});\n\n// EXTERNAL MODULE: ../axolotis-player/build/index.js\nvar build = __webpack_require__(919);\n;// CONCATENATED MODULE: ./src/lib/modules/spoke/SceneLoader.ts\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass SceneLoader {\n  constructor() {\n    _defineProperty(this, "scene", void 0);\n\n    _defineProperty(this, "mesh", void 0);\n\n    _defineProperty(this, "navMesh", void 0);\n  }\n\n  async loadScene(sceneUrl, threeLib) {\n    this.scene = threeLib.scene;\n    this.mesh = await threeLib.loadAssets(sceneUrl);\n    this.mesh = this.mesh.scene;\n    this.mesh.traverse(node => {\n      if (node.isMesh) {\n        if (node.name === "navMesh") {\n          this.navMesh = node;\n        }\n      }\n    });\n    this.scene.add(this.mesh);\n  }\n\n}\n;// CONCATENATED MODULE: ./node_modules/phoenix/priv/static/phoenix.esm.js\n// js/phoenix/utils.js\nvar closure = (value) => {\n  if (typeof value === "function") {\n    return value;\n  } else {\n    let closure2 = function() {\n      return value;\n    };\n    return closure2;\n  }\n};\n\n// js/phoenix/constants.js\nvar globalSelf = typeof self !== "undefined" ? self : null;\nvar phxWindow = typeof window !== "undefined" ? window : null;\nvar global = globalSelf || phxWindow || void 0;\nvar DEFAULT_VSN = "2.0.0";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 1e4;\nvar WS_CLOSE_NORMAL = 1e3;\nvar CHANNEL_STATES = {\n  closed: "closed",\n  errored: "errored",\n  joined: "joined",\n  joining: "joining",\n  leaving: "leaving"\n};\nvar CHANNEL_EVENTS = {\n  close: "phx_close",\n  error: "phx_error",\n  join: "phx_join",\n  reply: "phx_reply",\n  leave: "phx_leave"\n};\nvar TRANSPORTS = {\n  longpoll: "longpoll",\n  websocket: "websocket"\n};\nvar XHR_STATES = {\n  complete: 4\n};\n\n// js/phoenix/push.js\nvar Push = class {\n  constructor(channel, event, payload, timeout) {\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || function() {\n      return {};\n    };\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n  resend(timeout) {\n    this.timeout = timeout;\n    this.reset();\n    this.send();\n  }\n  send() {\n    if (this.hasReceived("timeout")) {\n      return;\n    }\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    });\n  }\n  receive(status, callback) {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp.response);\n    }\n    this.recHooks.push({ status, callback });\n    return this;\n  }\n  reset() {\n    this.cancelRefEvent();\n    this.ref = null;\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n  }\n  matchReceive({ status, response, _ref }) {\n    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));\n  }\n  cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n    this.channel.off(this.refEvent);\n  }\n  cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = null;\n  }\n  startTimeout() {\n    if (this.timeoutTimer) {\n      this.cancelTimeout();\n    }\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n    this.channel.on(this.refEvent, (payload) => {\n      this.cancelRefEvent();\n      this.cancelTimeout();\n      this.receivedResp = payload;\n      this.matchReceive(payload);\n    });\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger("timeout", {});\n    }, this.timeout);\n  }\n  hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n  trigger(status, response) {\n    this.channel.trigger(this.refEvent, { status, response });\n  }\n};\n\n// js/phoenix/timer.js\nvar Timer = class {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n};\n\n// js/phoenix/channel.js\nvar Channel = class {\n  constructor(topic, params, socket) {\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.stateChangeRefs = [];\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n    this.stateChangeRefs.push(this.socket.onOpen(() => {\n      this.rejoinTimer.reset();\n      if (this.isErrored()) {\n        this.rejoin();\n      }\n    }));\n    this.joinPush.receive("ok", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.joinPush.receive("error", () => {\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      if (this.socket.hasLogger())\n        this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError((reason) => {\n      if (this.socket.hasLogger())\n        this.socket.log("channel", `error ${this.topic}`, reason);\n      if (this.isJoining()) {\n        this.joinPush.reset();\n      }\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive("timeout", () => {\n      if (this.socket.hasLogger())\n        this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n      leavePush.send();\n      this.state = CHANNEL_STATES.errored;\n      this.joinPush.reset();\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n  join(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw new Error("tried to join multiple times. \'join\' can only be called a single time per channel instance");\n    } else {\n      this.timeout = timeout;\n      this.joinedOnce = true;\n      this.rejoin();\n      return this.joinPush;\n    }\n  }\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n  onError(callback) {\n    return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));\n  }\n  on(event, callback) {\n    let ref = this.bindingRef++;\n    this.bindings.push({ event, ref, callback });\n    return ref;\n  }\n  off(event, ref) {\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));\n    });\n  }\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n  push(event, payload, timeout = this.timeout) {\n    payload = payload || {};\n    if (!this.joinedOnce) {\n      throw new Error(`tried to push \'${event}\' to \'${this.topic}\' before joining. Use channel.join() before pushing events`);\n    }\n    let pushEvent = new Push(this, event, function() {\n      return payload;\n    }, timeout);\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  leave(timeout = this.timeout) {\n    this.rejoinTimer.reset();\n    this.joinPush.cancelTimeout();\n    this.state = CHANNEL_STATES.leaving;\n    let onClose = () => {\n      if (this.socket.hasLogger())\n        this.socket.log("channel", `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, "leave");\n    };\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n    leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());\n    leavePush.send();\n    if (!this.canPush()) {\n      leavePush.trigger("ok", {});\n    }\n    return leavePush;\n  }\n  onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  isMember(topic, event, payload, joinRef) {\n    if (this.topic !== topic) {\n      return false;\n    }\n    if (joinRef && joinRef !== this.joinRef()) {\n      if (this.socket.hasLogger())\n        this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });\n      return false;\n    } else {\n      return true;\n    }\n  }\n  joinRef() {\n    return this.joinPush.ref;\n  }\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return;\n    }\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  trigger(event, payload, ref, joinRef) {\n    let handledPayload = this.onMessage(event, payload, ref, joinRef);\n    if (payload && !handledPayload) {\n      throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");\n    }\n    let eventBindings = this.bindings.filter((bind) => bind.event === event);\n    for (let i = 0; i < eventBindings.length; i++) {\n      let bind = eventBindings[i];\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\n    }\n  }\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n};\n\n// js/phoenix/ajax.js\nvar Ajax = class {\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n    if (global.XDomainRequest) {\n      let req = new global.XDomainRequest();\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n    } else {\n      let req = new global.XMLHttpRequest();\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n    }\n  }\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n    req.timeout = timeout;\n    req.open(method, endPoint);\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText);\n      callback && callback(response);\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.onprogress = () => {\n    };\n    req.send(body);\n  }\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n    req.open(method, endPoint, true);\n    req.timeout = timeout;\n    req.setRequestHeader("Content-Type", accept);\n    req.onerror = () => {\n      callback && callback(null);\n    };\n    req.onreadystatechange = () => {\n      if (req.readyState === XHR_STATES.complete && callback) {\n        let response = this.parseJSON(req.responseText);\n        callback(response);\n      }\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.send(body);\n  }\n  static parseJSON(resp) {\n    if (!resp || resp === "") {\n      return null;\n    }\n    try {\n      return JSON.parse(resp);\n    } catch (e) {\n      console && console.log("failed to parse JSON response", resp);\n      return null;\n    }\n  }\n  static serialize(obj, parentKey) {\n    let queryStr = [];\n    for (var key in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        continue;\n      }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n      let paramVal = obj[key];\n      if (typeof paramVal === "object") {\n        queryStr.push(this.serialize(paramVal, paramKey));\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));\n      }\n    }\n    return queryStr.join("&");\n  }\n  static appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    let prefix = url.match(/\\?/) ? "&" : "?";\n    return `${url}${prefix}${this.serialize(params)}`;\n  }\n};\n\n// js/phoenix/longpoll.js\nvar LongPoll = class {\n  constructor(endPoint) {\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.onopen = function() {\n    };\n    this.onerror = function() {\n    };\n    this.onmessage = function() {\n    };\n    this.onclose = function() {\n    };\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    this.poll();\n  }\n  normalizeEndpoint(endPoint) {\n    return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);\n  }\n  endpointURL() {\n    return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n  }\n  closeAndRetry() {\n    this.close();\n    this.readyState = SOCKET_STATES.connecting;\n  }\n  ontimeout() {\n    this.onerror("timeout");\n    this.closeAndRetry();\n  }\n  poll() {\n    if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n      return;\n    }\n    Ajax.request("GET", this.endpointURL(), "application/json", null, this.timeout, this.ontimeout.bind(this), (resp) => {\n      if (resp) {\n        var { status, token, messages } = resp;\n        this.token = token;\n      } else {\n        status = 0;\n      }\n      switch (status) {\n        case 200:\n          messages.forEach((msg) => {\n            setTimeout(() => {\n              this.onmessage({ data: msg });\n            }, 0);\n          });\n          this.poll();\n          break;\n        case 204:\n          this.poll();\n          break;\n        case 410:\n          this.readyState = SOCKET_STATES.open;\n          this.onopen();\n          this.poll();\n          break;\n        case 403:\n          this.onerror();\n          this.close();\n          break;\n        case 0:\n        case 500:\n          this.onerror();\n          this.closeAndRetry();\n          break;\n        default:\n          throw new Error(`unhandled poll status ${status}`);\n      }\n    });\n  }\n  send(body) {\n    Ajax.request("POST", this.endpointURL(), "application/json", body, this.timeout, this.onerror.bind(this, "timeout"), (resp) => {\n      if (!resp || resp.status !== 200) {\n        this.onerror(resp && resp.status);\n        this.closeAndRetry();\n      }\n    });\n  }\n  close(_code, _reason) {\n    this.readyState = SOCKET_STATES.closed;\n    this.onclose();\n  }\n};\n\n// js/phoenix/presence.js\nvar Presence = class {\n  constructor(channel, opts = {}) {\n    let events = opts.events || { state: "presence_state", diff: "presence_diff" };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function() {\n      },\n      onLeave: function() {\n      },\n      onSync: function() {\n      }\n    };\n    this.channel.on(events.state, (newState) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      this.joinRef = this.channel.joinRef();\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach((diff) => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel.on(events.diff, (diff) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n  list(by) {\n    return Presence.list(this.state, by);\n  }\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\n  }\n  static syncState(currentState, newState, onJoin, onLeave) {\n    let state = this.clone(currentState);\n    let joins = {};\n    let leaves = {};\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key];\n      if (currentPresence) {\n        let newRefs = newPresence.metas.map((m) => m.phx_ref);\n        let curRefs = currentPresence.metas.map((m) => m.phx_ref);\n        let joinedMetas = newPresence.metas.filter((m) => curRefs.indexOf(m.phx_ref) < 0);\n        let leftMetas = currentPresence.metas.filter((m) => newRefs.indexOf(m.phx_ref) < 0);\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n  }\n  static syncDiff(state, diff, onJoin, onLeave) {\n    let { joins, leaves } = this.clone(diff);\n    if (!onJoin) {\n      onJoin = function() {\n      };\n    }\n    if (!onLeave) {\n      onLeave = function() {\n      };\n    }\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key];\n      state[key] = this.clone(newPresence);\n      if (currentPresence) {\n        let joinedRefs = state[key].metas.map((m) => m.phx_ref);\n        let curMetas = currentPresence.metas.filter((m) => joinedRefs.indexOf(m.phx_ref) < 0);\n        state[key].metas.unshift(...curMetas);\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      let refsToRemove = leftPresence.metas.map((m) => m.phx_ref);\n      currentPresence.metas = currentPresence.metas.filter((p) => {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  }\n  static list(presences, chooser) {\n    if (!chooser) {\n      chooser = function(key, pres) {\n        return pres;\n      };\n    }\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence);\n    });\n  }\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n  }\n  static clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n// js/phoenix/serializer.js\nvar serializer_default = {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: { push: 0, reply: 1, broadcast: 2 },\n  encode(msg, callback) {\n    if (msg.payload.constructor === ArrayBuffer) {\n      return callback(this.binaryEncode(msg));\n    } else {\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n      return callback(JSON.stringify(payload));\n    }\n  },\n  decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this.binaryDecode(rawPayload));\n    } else {\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n      return callback({ join_ref, ref, topic, event, payload });\n    }\n  },\n  binaryEncode(message) {\n    let { join_ref, ref, event, topic, payload } = message;\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n    let view = new DataView(header);\n    let offset = 0;\n    view.setUint8(offset++, this.KINDS.push);\n    view.setUint8(offset++, join_ref.length);\n    view.setUint8(offset++, ref.length);\n    view.setUint8(offset++, topic.length);\n    view.setUint8(offset++, event.length);\n    Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    var combined = new Uint8Array(header.byteLength + payload.byteLength);\n    combined.set(new Uint8Array(header), 0);\n    combined.set(new Uint8Array(payload), header.byteLength);\n    return combined.buffer;\n  },\n  binaryDecode(buffer) {\n    let view = new DataView(buffer);\n    let kind = view.getUint8(0);\n    let decoder = new TextDecoder();\n    switch (kind) {\n      case this.KINDS.push:\n        return this.decodePush(buffer, view, decoder);\n      case this.KINDS.reply:\n        return this.decodeReply(buffer, view, decoder);\n      case this.KINDS.broadcast:\n        return this.decodeBroadcast(buffer, view, decoder);\n    }\n  },\n  decodePush(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let topicSize = view.getUint8(2);\n    let eventSize = view.getUint8(3);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: joinRef, ref: null, topic, event, payload: data };\n  },\n  decodeReply(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let refSize = view.getUint8(2);\n    let topicSize = view.getUint8(3);\n    let eventSize = view.getUint8(4);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n    offset = offset + refSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    let payload = { status: event, response: data };\n    return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };\n  },\n  decodeBroadcast(buffer, view, decoder) {\n    let topicSize = view.getUint8(1);\n    let eventSize = view.getUint8(2);\n    let offset = this.HEADER_LENGTH + 2;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: null, ref: null, topic, event, payload: data };\n  }\n};\n\n// js/phoenix/socket.js\nvar Socket = class {\n  constructor(endPoint, opts = {}) {\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || global.WebSocket || LongPoll;\n    this.establishedConnections = 0;\n    this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n    this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n    this.closeWasClean = false;\n    this.binaryType = opts.binaryType || "arraybuffer";\n    this.connectClock = 1;\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n    let awaitingConnectionOnPageShow = null;\n    if (phxWindow && phxWindow.addEventListener) {\n      phxWindow.addEventListener("pagehide", (_e) => {\n        if (this.conn) {\n          this.disconnect();\n          awaitingConnectionOnPageShow = this.connectClock;\n        }\n      });\n      phxWindow.addEventListener("pageshow", (_e) => {\n        if (awaitingConnectionOnPageShow === this.connectClock) {\n          awaitingConnectionOnPageShow = null;\n          this.connect();\n        }\n      });\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n    this.rejoinAfterMs = (tries) => {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries);\n      } else {\n        return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n      }\n    };\n    this.reconnectAfterMs = (tries) => {\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries);\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n      }\n    };\n    this.logger = opts.logger || null;\n    this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n    this.params = closure(opts.params || {});\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.vsn = opts.vsn || DEFAULT_VSN;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect());\n    }, this.reconnectAfterMs);\n  }\n  replaceTransport(newTransport) {\n    this.disconnect();\n    this.transport = newTransport;\n  }\n  protocol() {\n    return location.protocol.match(/^https/) ? "wss" : "ws";\n  }\n  endPointURL() {\n    let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });\n    if (uri.charAt(0) !== "/") {\n      return uri;\n    }\n    if (uri.charAt(1) === "/") {\n      return `${this.protocol()}:${uri}`;\n    }\n    return `${this.protocol()}://${location.host}${uri}`;\n  }\n  disconnect(callback, code, reason) {\n    this.connectClock++;\n    this.closeWasClean = true;\n    this.reconnectTimer.reset();\n    this.teardown(callback, code, reason);\n  }\n  connect(params) {\n    this.connectClock++;\n    if (params) {\n      console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");\n      this.params = closure(params);\n    }\n    if (this.conn) {\n      return;\n    }\n    this.closeWasClean = false;\n    this.conn = new this.transport(this.endPointURL());\n    this.conn.binaryType = this.binaryType;\n    this.conn.timeout = this.longpollerTimeout;\n    this.conn.onopen = () => this.onConnOpen();\n    this.conn.onerror = (error) => this.onConnError(error);\n    this.conn.onmessage = (event) => this.onConnMessage(event);\n    this.conn.onclose = (event) => this.onConnClose(event);\n  }\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  hasLogger() {\n    return this.logger !== null;\n  }\n  onOpen(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.open.push([ref, callback]);\n    return ref;\n  }\n  onClose(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.close.push([ref, callback]);\n    return ref;\n  }\n  onError(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.error.push([ref, callback]);\n    return ref;\n  }\n  onMessage(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.message.push([ref, callback]);\n    return ref;\n  }\n  onConnOpen() {\n    if (this.hasLogger())\n      this.log("transport", `connected to ${this.endPointURL()}`);\n    this.closeWasClean = false;\n    this.establishedConnections++;\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.resetHeartbeat();\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n  }\n  heartbeatTimeout() {\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      if (this.hasLogger()) {\n        this.log("transport", "heartbeat timeout. Attempting to re-establish connection");\n      }\n      this.abnormalClose("heartbeat timeout");\n    }\n  }\n  resetHeartbeat() {\n    if (this.conn && this.conn.skipHeartbeat) {\n      return;\n    }\n    this.pendingHeartbeatRef = null;\n    clearTimeout(this.heartbeatTimer);\n    setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n  }\n  teardown(callback, code, reason) {\n    if (!this.conn) {\n      return callback && callback();\n    }\n    this.waitForBufferDone(() => {\n      if (this.conn) {\n        if (code) {\n          this.conn.close(code, reason || "");\n        } else {\n          this.conn.close();\n        }\n      }\n      this.waitForSocketClosed(() => {\n        if (this.conn) {\n          this.conn.onclose = function() {\n          };\n          this.conn = null;\n        }\n        callback && callback();\n      });\n    });\n  }\n  waitForBufferDone(callback, tries = 1) {\n    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1);\n    }, 150 * tries);\n  }\n  waitForSocketClosed(callback, tries = 1) {\n    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1);\n    }, 150 * tries);\n  }\n  onConnClose(event) {\n    let closeCode = event && event.code;\n    if (this.hasLogger())\n      this.log("transport", "close", event);\n    this.triggerChanError();\n    clearTimeout(this.heartbeatTimer);\n    if (!this.closeWasClean && closeCode !== 1e3) {\n      this.reconnectTimer.scheduleTimeout();\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n  }\n  onConnError(error) {\n    if (this.hasLogger())\n      this.log("transport", error);\n    let transportBefore = this.transport;\n    let establishedBefore = this.establishedConnections;\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\n      callback(error, transportBefore, establishedBefore);\n    });\n    if (transportBefore === this.transport || establishedBefore > 0) {\n      this.triggerChanError();\n    }\n  }\n  triggerChanError() {\n    this.channels.forEach((channel) => {\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n        channel.trigger(CHANNEL_EVENTS.error);\n      }\n    });\n  }\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return "connecting";\n      case SOCKET_STATES.open:\n        return "open";\n      case SOCKET_STATES.closing:\n        return "closing";\n      default:\n        return "closed";\n    }\n  }\n  isConnected() {\n    return this.connectionState() === "open";\n  }\n  remove(channel) {\n    this.off(channel.stateChangeRefs);\n    this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());\n  }\n  off(refs) {\n    for (let key in this.stateChangeCallbacks) {\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n        return refs.indexOf(ref) === -1;\n      });\n    }\n  }\n  channel(topic, chanParams = {}) {\n    let chan = new Channel(topic, chanParams, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  push(data) {\n    if (this.hasLogger()) {\n      let { topic, event, payload, ref, join_ref } = data;\n      this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n    }\n    if (this.isConnected()) {\n      this.encode(data, (result) => this.conn.send(result));\n    } else {\n      this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));\n    }\n  }\n  makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  sendHeartbeat() {\n    if (this.pendingHeartbeatRef && !this.isConnected()) {\n      return;\n    }\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });\n    this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n  }\n  abnormalClose(reason) {\n    this.closeWasClean = false;\n    if (this.isConnected()) {\n      this.conn.close(WS_CLOSE_NORMAL, reason);\n    }\n  }\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback());\n      this.sendBuffer = [];\n    }\n  }\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, (msg) => {\n      let { topic, event, payload, ref, join_ref } = msg;\n      if (ref && ref === this.pendingHeartbeatRef) {\n        clearTimeout(this.heartbeatTimer);\n        this.pendingHeartbeatRef = null;\n        setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n      }\n      if (this.hasLogger())\n        this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i];\n        if (!channel.isMember(topic, event, payload, join_ref)) {\n          continue;\n        }\n        channel.trigger(event, payload, ref, join_ref);\n      }\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        let [, callback] = this.stateChangeCallbacks.message[i];\n        callback(msg);\n      }\n    });\n  }\n  leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));\n    if (dupChannel) {\n      if (this.hasLogger())\n        this.log("transport", `leaving duplicate topic "${topic}"`);\n      dupChannel.leave();\n    }\n  }\n};\n\n//# sourceMappingURL=phoenix.esm.js.map\n\n;// CONCATENATED MODULE: ./src/lib/modules/spoke/PhoenixUtils.ts\n\nlet configs = {\n  RETICULUM_SOCKET_SERVER_PORT: "443",\n  RETICULUM_SOCKET_SERVER: "alphahub.aptero.co",\n  //TODO\n  RETICULUM_SOCKET_PROTOCOL: "wss:"\n};\nfunction createHubChannelParams() {\n  let authToken = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let permsToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  /*{\n        "profile": {\n        "avatarId": "https://hub.aptero.co/data/avatar/A031/base.glb",\n            "displayName": "Pierre"\n    },\n        "push_subscription_endpoint": null,\n        "auth_token": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJyZXQiLCJleHAiOjE2MjM2Nzc4NzUsImlhdCI6MTYxNjQyMDI3NSwiaXNzIjoicmV0IiwianRpIjoiMTBkMWFkZmYtYjBlMi00N2RkLWFiMTgtMjY3MGY0ZDVhMTFkIiwibmJmIjoxNjE2NDIwMjc0LCJzdWIiOiI2NDA0MDcwNTA5NjYyNjk5NjEiLCJ0eXAiOiJhY2Nlc3MifQ.qp29Ip4AKkpRPtVVOUikytL1u-lGPJidUglsWlW8H9izgdRsoH_c0yZuA04Miwi6K2iN-GsoCr8Kd1fTH0yp2g",\n        "perms_token": null,\n        "context": {\n        "mobile": false,\n            "embed": true\n    },\n        "hub_invite_id": null\n    }*/\n  const params = {\n    profile: {\n      avatarId: "",\n      displayName: ""\n    },\n    push_subscription_endpoint: null,\n    auth_token: null,\n    perms_token: null,\n    bot_access_key: null,\n    context: {\n      mobile: false,\n      embed: true\n    },\n    hub_invite_id: null\n  };\n  return params;\n}\nasync function load(hubid) {\n  const socket = await connectToReticulum();\n  socket.onClose(e => {\n    console.error(e);\n  });\n  const {\n    data,\n    hubPhxChannel,\n    vapiddata\n  } = await new Promise((resolve, reject) => {\n    // Reticulum global channel\n    let retChannel = socket.channel("ret", {\n      hub_id: hubid\n    });\n    retChannel.join().receive("ok", vapiddata => {\n      const hubPhxChannel = socket.channel("hub:" + hubid, createHubChannelParams());\n      hubPhxChannel.join().receive("ok", async data => {\n        resolve({\n          data,\n          hubPhxChannel,\n          vapiddata\n        });\n      }).receive("error", res => {\n        reject(res);\n      });\n    }).receive("error", res => {\n      reject(res);\n    });\n  });\n  return {\n    data,\n    hubPhxChannel,\n    vapiddata\n  };\n}\nlet reticulumMeta = null;\nlet invalidatedReticulumMetaThisSession = false;\nlet directReticulumHostAndPort;\n\nasync function refreshDirectReticulumHostAndPort() {\n  const qs = new URLSearchParams(location.search);\n  let host = qs.get("phx_host");\n  host = host || configs.RETICULUM_SOCKET_SERVER;\n  const port = configs.RETICULUM_SOCKET_SERVER_PORT;\n  directReticulumHostAndPort = {\n    host,\n    port\n  };\n}\n\nasync function invalidateReticulumMeta() {\n  invalidatedReticulumMetaThisSession = true;\n  reticulumMeta = null;\n} //TODO important function\n\nasync function connectToReticulum() {\n  let debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let socketClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Socket;\n  const qs = new URLSearchParams(location.search);\n\n  const getNewSocketUrl = async () => {\n    await refreshDirectReticulumHostAndPort();\n    const {\n      host,\n      port\n    } = directReticulumHostAndPort;\n    const protocol = qs.get("phx_protocol") || configs.RETICULUM_SOCKET_PROTOCOL || (document.location.protocol === "https:" ? "wss:" : "ws:");\n    return "".concat(protocol, "//").concat(host).concat(port ? ":".concat(port) : "");\n  };\n\n  const socketUrl = await getNewSocketUrl();\n  console.log("Phoenix Socket URL: ".concat(socketUrl));\n  const socketSettings = {};\n\n  if (debug) {\n    socketSettings.logger = (kind, msg, data) => {\n      console.log("".concat(kind, ": ").concat(msg), data);\n    };\n  }\n\n  if (params) {\n    socketSettings.params = params;\n  }\n\n  const socket = new socketClass("".concat(socketUrl, "/socket"), socketSettings);\n  socket.connect();\n  socket.onError(async () => {\n    // On error, underlying reticulum node may have died, so rebalance by\n    // fetching a new healthy node to connect to.\n    invalidateReticulumMeta();\n    const endPointPath = new URL(socket.endPoint).pathname;\n    const newSocketUrl = await getNewSocketUrl();\n    const newEndPoint = "".concat(newSocketUrl).concat(endPointPath);\n    console.log("Socket error, changed endpoint to ".concat(newEndPoint));\n    socket.endPoint = newEndPoint;\n  });\n  return socket;\n}\nfunction getPresenceEntryForSession(presences, sessionId) {\n  const entry = Object.entries(presences || {}).find(_ref => {\n    let [k] = _ref;\n    return k === sessionId;\n  }) || [];\n  const presence = entry[1];\n  return presence && presence.metas && presence.metas[0] || {};\n}\nfunction getPresenceContextForSession(presences, sessionId) {\n  return (getPresenceEntryForSession(presences, sessionId) || {}).context || {};\n}\nfunction getPresenceProfileForSession(presences, sessionId) {\n  return (getPresenceEntryForSession(presences, sessionId) || {}).profile || {};\n}\n\nfunction migrateBindings(oldChannel, newChannel) {\n  const doNotDuplicate = ["phx_close", "phx_error", "phx_reply", "presence_state", "presence_diff"];\n\n  const shouldDuplicate = event => {\n    return !event.startsWith("chan_reply_") && !doNotDuplicate.includes(event);\n  };\n\n  for (let i = 0, l = oldChannel.bindings.length; i < l; i++) {\n    const item = oldChannel.bindings[i];\n\n    if (shouldDuplicate(item.event)) {\n      newChannel.bindings.push(item);\n    }\n  }\n\n  newChannel.bindingRef = oldChannel.bindingRef;\n} // Takes the given channel, and creates a new channel with the same bindings\n// with the given socket, joins it, and leaves the old channel after joining.\n//\n// NOTE: This function relies upon phoenix channel object internals, so this\n// function will need to be reviewed if/when we ever update phoenix.js\n\n\nfunction migrateChannelToSocket(oldChannel, socket, params) {\n  const channel = socket.channel(oldChannel.topic, params || oldChannel.params);\n  migrateBindings(oldChannel, channel);\n\n  for (let i = 0, l = oldChannel.pushBuffer.length; i < l; i++) {\n    const item = oldChannel.pushBuffer[i];\n    channel.push(item.event, item.payload, item.timeout);\n  }\n\n  const oldJoinPush = oldChannel.joinPush;\n  const joinPush = channel.join();\n\n  for (let i = 0, l = oldJoinPush.recHooks.length; i < l; i++) {\n    const item = oldJoinPush.recHooks[i];\n    joinPush.receive(item.status, item.callback);\n  }\n\n  return new Promise(resolve => {\n    joinPush.receive("ok", () => {\n      // Clear all event handlers first so no duplicate messages come in.\n      oldChannel.bindings = [];\n      resolve(channel);\n    });\n  });\n}\nfunction migrateToChannel(oldChannel, newChannel) {\n  migrateBindings(oldChannel, newChannel);\n  return new Promise((resolve, reject) => {\n    newChannel.join().receive("ok", data => {\n      oldChannel.leave();\n      oldChannel.bindings = [];\n      resolve(data);\n    }).receive("error", data => {\n      newChannel.leave();\n      reject(data);\n    });\n  });\n}\nfunction discordBridgesForPresences(presences) {\n  const channels = [];\n\n  for (const p of Object.values(presences)) {\n    for (const m of p.metas) {\n      if (m.profile && m.profile.discordBridges) {\n        Array.prototype.push.apply(channels, m.profile.discordBridges.map(b => b.channel.name));\n      }\n    }\n  }\n\n  return channels;\n}\nfunction hasEmbedPresences(presences) {\n  for (const p of Object.values(presences)) {\n    for (const m of p.metas) {\n      if (m.context && m.context.embed) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\nfunction denoisePresence(_ref2) {\n  let {\n    onJoin,\n    onLeave,\n    onChange\n  } = _ref2;\n  return {\n    rawOnJoin: (key, beforeJoin, afterJoin) => {\n      if (beforeJoin === undefined) {\n        onJoin(key, afterJoin.metas[0]);\n      }\n    },\n    rawOnLeave: (key, remaining, removed) => {\n      if (remaining.metas.length === 0) {\n        onLeave(key, removed.metas[0]);\n      } else {\n        onChange(key, removed.metas[removed.metas.length - 1], remaining.metas[remaining.metas.length - 1]);\n      }\n    }\n  };\n}\nfunction presenceEventsForHub(events) {\n  const onJoin = (key, meta) => {\n    events.trigger("hub:join", {\n      key,\n      meta\n    });\n  };\n\n  const onLeave = (key, meta) => {\n    events.trigger("hub:leave", {\n      key,\n      meta\n    });\n  };\n\n  const onChange = (key, previous, current) => {\n    events.trigger("hub:change", {\n      key,\n      previous,\n      current\n    });\n  };\n\n  return {\n    onJoin,\n    onLeave,\n    onChange\n  };\n}\n;// CONCATENATED MODULE: ./src/lib/modules/spoke/SpokeRoomLoader.ts\nfunction SpokeRoomLoader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n//import { ServiceEntity } from "@aptero/axolotis-player/build/types/modules/core/service/ServiceEntity";\n\n\n\nclass SpokeRoomLoader {\n  constructor(threeLib) {\n    this.threeLib = threeLib;\n\n    SpokeRoomLoader_defineProperty(this, "sceneLoader", null);\n  }\n\n  async loadRoom(hubid) {\n    const {\n      data,\n      hubPhxChannel,\n      vapiddata\n    } = await load(hubid);\n    const sceneURL = data.hubs[0].scene.model_url.replace(".bin", ".glb");\n    this.sceneLoader = new SceneLoader();\n    await this.sceneLoader.loadScene(sceneURL, this.threeLib);\n  }\n\n  getType() {\n    return SpokeRoomLoader.name;\n  }\n\n}\nclass Factory {\n  async createComponent(world, config) {\n    let services = world.getFirstComponentByType(build.ServiceEntity.name);\n    let three = await services.getService("@aptero/axolotis-core-plugins/modules/three/ThreeLib");\n    let playerService = await services.getService("@aptero/axolotis-core-plugins/modules/controller/PlayerService");\n    let spokeRoomLoader = new SpokeRoomLoader(three);\n    await spokeRoomLoader.loadRoom(config.room);\n\n    if (spokeRoomLoader.sceneLoader) {\n      playerService.getCurrentPlayer().declareNavMesh(spokeRoomLoader.sceneLoader.navMesh);\n    }\n\n    return spokeRoomLoader;\n  }\n\n}\n/*\nHave to connect to the phoenix websocket\nand get scene url from message from\n["2", "2", "hub:yUXD7A2", "phx_reply", {\n    "response": {\n        "hub_requires_oauth": false,\n        "hubs": [{\n            "allow_promotion": true,\n            "description": null,\n            "embed_token": "c223b27b9e6f48c5591b4b140fe7de6f",\n            "entry_code": 180429,\n            "entry_mode": "allow",\n            "host": "dedicatedwebrtc3.aptero.co",\n            "hub_id": "yUXD7A2",\n            "lobby_count": 0,\n            "member_count": 0,\n            "member_permissions": {\n                "fly": true,\n                "pin_objects": true,\n                "spawn_and_move_media": true,\n                "spawn_camera": true,\n                "spawn_drawing": true,\n                "spawn_emoji": true\n            },\n            "name": "Lightweight Empty Room",\n            "port": "443",\n            "room_size": 50,\n            "scene": {\n                "account_id": null,\n                "allow_promotion": false,\n                "allow_remixing": false,\n                "attribution": null,\n                "attributions": { "content": [], "creator": "" },\n                "description": null,\n                "model_url": "https://alphahub.aptero.co/files/598eeed3-0768-408a-a75b-b0fcb8e907af.bin",\n                "name": "Museum",\n                "parent_scene_id": null,\n                "project_id": "wwDyQ8t",\n                "scene_id": "br4pVT2",\n                "screenshot_url": "https://alphahub.aptero.co/files/38473f11-615f-487d-b20b-f3b6558abea6.jpg",\n                "type": "scene",\n                "url": "https://alphahub.aptero.co/scenes/br4pVT2/museum"\n            },\n            "slug": "lightweight-empty-room",\n            "turn": {\n                "credential": "CWBiIUroBx9x7OITbxMrm54HiJw=",\n                "enabled": true,\n                "transports": [{ "port": 5349 }],\n                "username": "1636140736:coturn"\n            },\n            "user_data": null\n        }],\n        "perms_token": "eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJhY2NvdW50X2lkIjoiNjQwNDA3MDUwOTY2MjY5OTYxIiwiYW1wbGlmeV9hdWRpbyI6dHJ1ZSwiYXVkIjoicmV0X3Blcm1zIiwiY2xvc2VfaHViIjp0cnVlLCJjcmVhdGVfaHViIjp0cnVlLCJlbWJlZF9odWIiOnRydWUsImV4cCI6MTYzNjE0MDkxNiwiZmx5Ijp0cnVlLCJodWJfaWQiOiJ5VVhEN0EyIiwiaWF0IjoxNjM2MTQwNjE2LCJpc3MiOiIiLCJqb2luX2h1YiI6dHJ1ZSwianRpIjoiZjhkNGU2MDMtMWE0NC00MWRmLTg5NWMtNjE3ZGVhYzc5ZDI4Iiwia2lja191c2VycyI6dHJ1ZSwibXV0ZV91c2VycyI6dHJ1ZSwibmJmIjoxNjM2MTQwNjE1LCJwaW5fb2JqZWN0cyI6dHJ1ZSwicG9zdGdyZXN0X3JvbGUiOiJyZXRfYWRtaW4iLCJzcGF3bl9hbmRfbW92ZV9tZWRpYSI6dHJ1ZSwic3Bhd25fY2FtZXJhIjp0cnVlLCJzcGF3bl9kcmF3aW5nIjp0cnVlLCJzcGF3bl9lbW9qaSI6dHJ1ZSwic3ViIjoiNjQwNDA3MDUwOTY2MjY5OTYxX3lVWEQ3QTIiLCJ0d2VldCI6ZmFsc2UsInR5cCI6ImFjY2VzcyIsInVwZGF0ZV9odWIiOnRydWUsInVwZGF0ZV9odWJfcHJvbW90aW9uIjp0cnVlLCJ1cGRhdGVfcm9sZXMiOnRydWV9.qlNJloKYDmc2wSTaKF1eVYKKV_lCuuwzfdRnq3Jc-OP9P5uhKiFzo1i9N6rHBCIfITEwp8fJouD7TNOrBvpwFgxR1JHTgOpgWTdD6ltxRGspbtJRMJQ7qa66WTrVxKup4fI1ah70dFIsHu26GNdUaaNp8503VYuo41Dzs0XnTT1bLjbNM0ugJ_ZaF_d24b1m_7dLKdAn0-aZkoTQSCl3wzNDKLE90B2FJT6Mc7hqeo8d0mhr3yNQSRyJ4xLS0TBG4fvFZQL5H_bRD4Fk-q17jeMAgIAvtquElbs1cYRnQFE3g-PcsRYYRsejWaz4PEJUlZ5MM5tbohM5XoVHdRT8ZA",\n        "session_id": "a3c750b8-6446-4a1e-a638-c516073d8861",\n        "session_token": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJyZXRfc2Vzc2lvbiIsImV4cCI6MTYzNjIyNzAxNiwiaWF0IjoxNjM2MTQwNjE2LCJpc3MiOiIiLCJqdGkiOiIzNDk4Yjg4OC01NjA0LTQxYzctYWFmZC0xMjI5NmU4YmNlYTIiLCJuYmYiOjE2MzYxNDA2MTUsInNlc3Npb25faWQiOiJhM2M3NTBiOC02NDQ2LTRhMWUtYTYzOC1jNTE2MDczZDg4NjEiLCJzdWIiOiJhM2M3NTBiOC02NDQ2LTRhMWUtYTYzOC1jNTE2MDczZDg4NjEiLCJ0eXAiOiJhY2Nlc3MifQ.EbEzkgwNJ8_H4g8vxFI-ch9HprbzNh12xkfj-OrUOkUqTF-j-qEpsF-XFIZozSlCU2cwJVD7RLuxNOuqDVF76g",\n        "subscriptions": { "favorites": true, "web_push": null }\n    }, "status": "ok"\n}];\n\n *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VSxNQUFBQSxhQUFhLENBQ1ZHLGdCQURILEdBRUdDLGNBRkgsQ0FFa0JILGVBQWUsQ0FBQ1gsV0FBaEIsQ0FBNEJySixPQUY5QztBQUdEOztBQUNELFdBQU9nSyxlQUFQO0FBQ0Q7O0FBdEJIO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2F4b2xvdGlzLWNvcmUtcGx1Z2lucy8uL3NyYy9saWIvbW9kdWxlcy9zcG9rZS9TY2VuZUxvYWRlci50cz8zNjg4Iiwid2VicGFjazovL2F4b2xvdGlzLWNvcmUtcGx1Z2lucy8uL25vZGVfbW9kdWxlcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguZXNtLmpzP2VkMTkiLCJ3ZWJwYWNrOi8vYXhvbG90aXMtY29yZS1wbHVnaW5zLy4vc3JjL2xpYi9tb2R1bGVzL3Nwb2tlL1Bob2VuaXhVdGlscy50cz9hNTBhIiwid2VicGFjazovL2F4b2xvdGlzLWNvcmUtcGx1Z2lucy8uL3NyYy9saWIvbW9kdWxlcy9zcG9rZS9TcG9rZVJvb21Mb2FkZXIudHM/ODI2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUaHJlZUxpYiB9IGZyb20gXCJAcm9vdC9saWIvbW9kdWxlcy90aHJlZS9UaHJlZUxpYlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZUxvYWRlciB7XG4gIHByaXZhdGUgc2NlbmU6IGFueTtcbiAgcHJpdmF0ZSBtZXNoOiBhbnk7XG4gIHB1YmxpYyBuYXZNZXNoOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIGFzeW5jIGxvYWRTY2VuZShzY2VuZVVybDogc3RyaW5nLCB0aHJlZUxpYjogVGhyZWVMaWIpIHtcbiAgICB0aGlzLnNjZW5lID0gdGhyZWVMaWIuc2NlbmU7XG4gICAgdGhpcy5tZXNoID0gYXdhaXQgdGhyZWVMaWIubG9hZEFzc2V0cyhzY2VuZVVybCk7XG4gICAgdGhpcy5tZXNoID0gdGhpcy5tZXNoLnNjZW5lO1xuXG4gICAgdGhpcy5tZXNoLnRyYXZlcnNlKChub2RlKSA9PiB7XG4gICAgICBpZiAobm9kZS5pc01lc2gpIHtcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJuYXZNZXNoXCIpIHtcbiAgICAgICAgICB0aGlzLm5hdk1lc2ggPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLm1lc2gpO1xuICB9XG59XG4iLCIvLyBqcy9waG9lbml4L3V0aWxzLmpzXG52YXIgY2xvc3VyZSA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGNsb3N1cmUyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gY2xvc3VyZTI7XG4gIH1cbn07XG5cbi8vIGpzL3Bob2VuaXgvY29uc3RhbnRzLmpzXG52YXIgZ2xvYmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IG51bGw7XG52YXIgcGh4V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IG51bGw7XG52YXIgZ2xvYmFsID0gZ2xvYmFsU2VsZiB8fCBwaHhXaW5kb3cgfHwgdm9pZCAwO1xudmFyIERFRkFVTFRfVlNOID0gXCIyLjAuMFwiO1xudmFyIFNPQ0tFVF9TVEFURVMgPSB7IGNvbm5lY3Rpbmc6IDAsIG9wZW46IDEsIGNsb3Npbmc6IDIsIGNsb3NlZDogMyB9O1xudmFyIERFRkFVTFRfVElNRU9VVCA9IDFlNDtcbnZhciBXU19DTE9TRV9OT1JNQUwgPSAxZTM7XG52YXIgQ0hBTk5FTF9TVEFURVMgPSB7XG4gIGNsb3NlZDogXCJjbG9zZWRcIixcbiAgZXJyb3JlZDogXCJlcnJvcmVkXCIsXG4gIGpvaW5lZDogXCJqb2luZWRcIixcbiAgam9pbmluZzogXCJqb2luaW5nXCIsXG4gIGxlYXZpbmc6IFwibGVhdmluZ1wiXG59O1xudmFyIENIQU5ORUxfRVZFTlRTID0ge1xuICBjbG9zZTogXCJwaHhfY2xvc2VcIixcbiAgZXJyb3I6IFwicGh4X2Vycm9yXCIsXG4gIGpvaW46IFwicGh4X2pvaW5cIixcbiAgcmVwbHk6IFwicGh4X3JlcGx5XCIsXG4gIGxlYXZlOiBcInBoeF9sZWF2ZVwiXG59O1xudmFyIFRSQU5TUE9SVFMgPSB7XG4gIGxvbmdwb2xsOiBcImxvbmdwb2xsXCIsXG4gIHdlYnNvY2tldDogXCJ3ZWJzb2NrZXRcIlxufTtcbnZhciBYSFJfU1RBVEVTID0ge1xuICBjb21wbGV0ZTogNFxufTtcblxuLy8ganMvcGhvZW5peC9wdXNoLmpzXG52YXIgUHVzaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpIHtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH07XG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBudWxsO1xuICAgIHRoaXMucmVjSG9va3MgPSBbXTtcbiAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgfVxuICByZXNlbmQodGltZW91dCkge1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuc2VuZCgpO1xuICB9XG4gIHNlbmQoKSB7XG4gICAgaWYgKHRoaXMuaGFzUmVjZWl2ZWQoXCJ0aW1lb3V0XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgdGhpcy5zZW50ID0gdHJ1ZTtcbiAgICB0aGlzLmNoYW5uZWwuc29ja2V0LnB1c2goe1xuICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgcGF5bG9hZDogdGhpcy5wYXlsb2FkKCksXG4gICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5qb2luUmVmKClcbiAgICB9KTtcbiAgfVxuICByZWNlaXZlKHN0YXR1cywgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5oYXNSZWNlaXZlZChzdGF0dXMpKSB7XG4gICAgICBjYWxsYmFjayh0aGlzLnJlY2VpdmVkUmVzcC5yZXNwb25zZSk7XG4gICAgfVxuICAgIHRoaXMucmVjSG9va3MucHVzaCh7IHN0YXR1cywgY2FsbGJhY2sgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpO1xuICAgIHRoaXMucmVmID0gbnVsbDtcbiAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGw7XG4gICAgdGhpcy5zZW50ID0gZmFsc2U7XG4gIH1cbiAgbWF0Y2hSZWNlaXZlKHsgc3RhdHVzLCByZXNwb25zZSwgX3JlZiB9KSB7XG4gICAgdGhpcy5yZWNIb29rcy5maWx0ZXIoKGgpID0+IGguc3RhdHVzID09PSBzdGF0dXMpLmZvckVhY2goKGgpID0+IGguY2FsbGJhY2socmVzcG9uc2UpKTtcbiAgfVxuICBjYW5jZWxSZWZFdmVudCgpIHtcbiAgICBpZiAoIXRoaXMucmVmRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGFubmVsLm9mZih0aGlzLnJlZkV2ZW50KTtcbiAgfVxuICBjYW5jZWxUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcik7XG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBudWxsO1xuICB9XG4gIHN0YXJ0VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0VGltZXIpIHtcbiAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpO1xuICAgIH1cbiAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQubWFrZVJlZigpO1xuICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwucmVwbHlFdmVudE5hbWUodGhpcy5yZWYpO1xuICAgIHRoaXMuY2hhbm5lbC5vbih0aGlzLnJlZkV2ZW50LCAocGF5bG9hZCkgPT4ge1xuICAgICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWQ7XG4gICAgICB0aGlzLm1hdGNoUmVjZWl2ZShwYXlsb2FkKTtcbiAgICB9KTtcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKFwidGltZW91dFwiLCB7fSk7XG4gICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgfVxuICBoYXNSZWNlaXZlZChzdGF0dXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXM7XG4gIH1cbiAgdHJpZ2dlcihzdGF0dXMsIHJlc3BvbnNlKSB7XG4gICAgdGhpcy5jaGFubmVsLnRyaWdnZXIodGhpcy5yZWZFdmVudCwgeyBzdGF0dXMsIHJlc3BvbnNlIH0pO1xuICB9XG59O1xuXG4vLyBqcy9waG9lbml4L3RpbWVyLmpzXG52YXIgVGltZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCB0aW1lckNhbGMpIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGM7XG4gICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgdGhpcy50cmllcyA9IDA7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy50cmllcyA9IDA7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICB9XG4gIHNjaGVkdWxlVGltZW91dCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxO1xuICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgIH0sIHRoaXMudGltZXJDYWxjKHRoaXMudHJpZXMgKyAxKSk7XG4gIH1cbn07XG5cbi8vIGpzL3Bob2VuaXgvY2hhbm5lbC5qc1xudmFyIENoYW5uZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHRvcGljLCBwYXJhbXMsIHNvY2tldCkge1xuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShwYXJhbXMgfHwge30pO1xuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgICB0aGlzLmJpbmRpbmdSZWYgPSAwO1xuICAgIHRoaXMudGltZW91dCA9IHRoaXMuc29ja2V0LnRpbWVvdXQ7XG4gICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2U7XG4gICAgdGhpcy5qb2luUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmpvaW4sIHRoaXMucGFyYW1zLCB0aGlzLnRpbWVvdXQpO1xuICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzID0gW107XG4gICAgdGhpcy5yZWpvaW5UaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICB0aGlzLnJlam9pbigpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuc29ja2V0LnJlam9pbkFmdGVyTXMpO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25FcnJvcigoKSA9PiB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCkpKTtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcy5wdXNoKHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICBpZiAodGhpcy5pc0Vycm9yZWQoKSkge1xuICAgICAgICB0aGlzLnJlam9pbigpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmVkO1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2goKHB1c2hFdmVudCkgPT4gcHVzaEV2ZW50LnNlbmQoKSk7XG4gICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICB9KTtcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgIGlmICh0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vbkNsb3NlKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgIGlmICh0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSlcbiAgICAgICAgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgY2xvc2UgJHt0aGlzLnRvcGljfSAke3RoaXMuam9pblJlZigpfWApO1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICAgIHRoaXMuc29ja2V0LnJlbW92ZSh0aGlzKTtcbiAgICB9KTtcbiAgICB0aGlzLm9uRXJyb3IoKHJlYXNvbikgPT4ge1xuICAgICAgaWYgKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKVxuICAgICAgICB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKTtcbiAgICAgIGlmICh0aGlzLmlzSm9pbmluZygpKSB7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSlcbiAgICAgICAgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgdGltZW91dCAke3RoaXMudG9waWN9ICgke3RoaXMuam9pblJlZigpfSlgLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpO1xuICAgICAgbGV0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCBjbG9zdXJlKHt9KSwgdGhpcy50aW1lb3V0KTtcbiAgICAgIGxlYXZlUHVzaC5zZW5kKCk7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgIHRoaXMuam9pblB1c2gucmVzZXQoKTtcbiAgICAgIGlmICh0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKHRoaXMucmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZCk7XG4gICAgfSk7XG4gIH1cbiAgam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgaWYgKHRoaXMuam9pbmVkT25jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gam9pbiBtdWx0aXBsZSB0aW1lcy4gJ2pvaW4nIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVqb2luKCk7XG4gICAgICByZXR1cm4gdGhpcy5qb2luUHVzaDtcbiAgICB9XG4gIH1cbiAgb25DbG9zZShjYWxsYmFjaykge1xuICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIGNhbGxiYWNrKTtcbiAgfVxuICBvbkVycm9yKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIChyZWFzb24pID0+IGNhbGxiYWNrKHJlYXNvbikpO1xuICB9XG4gIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGxldCByZWYgPSB0aGlzLmJpbmRpbmdSZWYrKztcbiAgICB0aGlzLmJpbmRpbmdzLnB1c2goeyBldmVudCwgcmVmLCBjYWxsYmFjayB9KTtcbiAgICByZXR1cm4gcmVmO1xuICB9XG4gIG9mZihldmVudCwgcmVmKSB7XG4gICAgdGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICByZXR1cm4gIShiaW5kLmV2ZW50ID09PSBldmVudCAmJiAodHlwZW9mIHJlZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCByZWYgPT09IGJpbmQucmVmKSk7XG4gICAgfSk7XG4gIH1cbiAgY2FuUHVzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLmlzSm9pbmVkKCk7XG4gIH1cbiAgcHVzaChldmVudCwgcGF5bG9hZCwgdGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgIHBheWxvYWQgPSBwYXlsb2FkIHx8IHt9O1xuICAgIGlmICghdGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNgKTtcbiAgICB9XG4gICAgbGV0IHB1c2hFdmVudCA9IG5ldyBQdXNoKHRoaXMsIGV2ZW50LCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH0sIHRpbWVvdXQpO1xuICAgIGlmICh0aGlzLmNhblB1c2goKSkge1xuICAgICAgcHVzaEV2ZW50LnNlbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpO1xuICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHB1c2hFdmVudDtcbiAgfVxuICBsZWF2ZSh0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgIHRoaXMuam9pblB1c2guY2FuY2VsVGltZW91dCgpO1xuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgIGxldCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKVxuICAgICAgICB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBsZWF2ZSAke3RoaXMudG9waWN9YCk7XG4gICAgICB0aGlzLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIFwibGVhdmVcIik7XG4gICAgfTtcbiAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aW1lb3V0KTtcbiAgICBsZWF2ZVB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IG9uQ2xvc2UoKSkucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gb25DbG9zZSgpKTtcbiAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgIGlmICghdGhpcy5jYW5QdXNoKCkpIHtcbiAgICAgIGxlYXZlUHVzaC50cmlnZ2VyKFwib2tcIiwge30pO1xuICAgIH1cbiAgICByZXR1cm4gbGVhdmVQdXNoO1xuICB9XG4gIG9uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpIHtcbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfVxuICBpc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYpIHtcbiAgICBpZiAodGhpcy50b3BpYyAhPT0gdG9waWMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGpvaW5SZWYgJiYgam9pblJlZiAhPT0gdGhpcy5qb2luUmVmKCkpIHtcbiAgICAgIGlmICh0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSlcbiAgICAgICAgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBcImRyb3BwaW5nIG91dGRhdGVkIG1lc3NhZ2VcIiwgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBqb2luUmVmKCkge1xuICAgIHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZjtcbiAgfVxuICByZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgIGlmICh0aGlzLmlzTGVhdmluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc29ja2V0LmxlYXZlT3BlblRvcGljKHRoaXMudG9waWMpO1xuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nO1xuICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpO1xuICB9XG4gIHRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pblJlZikge1xuICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMub25NZXNzYWdlKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpO1xuICAgIGlmIChwYXlsb2FkICYmICFoYW5kbGVkUGF5bG9hZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXCIpO1xuICAgIH1cbiAgICBsZXQgZXZlbnRCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKChiaW5kKSA9PiBiaW5kLmV2ZW50ID09PSBldmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudEJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYmluZCA9IGV2ZW50QmluZGluZ3NbaV07XG4gICAgICBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYsIGpvaW5SZWYgfHwgdGhpcy5qb2luUmVmKCkpO1xuICAgIH1cbiAgfVxuICByZXBseUV2ZW50TmFtZShyZWYpIHtcbiAgICByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YDtcbiAgfVxuICBpc0Nsb3NlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICB9XG4gIGlzRXJyb3JlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgfVxuICBpc0pvaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmVkO1xuICB9XG4gIGlzSm9pbmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgfVxuICBpc0xlYXZpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmxlYXZpbmc7XG4gIH1cbn07XG5cbi8vIGpzL3Bob2VuaXgvYWpheC5qc1xudmFyIEFqYXggPSBjbGFzcyB7XG4gIHN0YXRpYyByZXF1ZXN0KG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaykge1xuICAgIGlmIChnbG9iYWwuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICB0aGlzLnhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB0aGlzLnhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgeGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKSB7XG4gICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQpO1xuICAgIHJlcS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIGlmIChvbnRpbWVvdXQpIHtcbiAgICAgIHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQ7XG4gICAgfVxuICAgIHJlcS5vbnByb2dyZXNzID0gKCkgPT4ge1xuICAgIH07XG4gICAgcmVxLnNlbmQoYm9keSk7XG4gIH1cbiAgc3RhdGljIHhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spIHtcbiAgICByZXEub3BlbihtZXRob2QsIGVuZFBvaW50LCB0cnVlKTtcbiAgICByZXEudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgYWNjZXB0KTtcbiAgICByZXEub25lcnJvciA9ICgpID0+IHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gWEhSX1NUQVRFUy5jb21wbGV0ZSAmJiBjYWxsYmFjaykge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKG9udGltZW91dCkge1xuICAgICAgcmVxLm9udGltZW91dCA9IG9udGltZW91dDtcbiAgICB9XG4gICAgcmVxLnNlbmQoYm9keSk7XG4gIH1cbiAgc3RhdGljIHBhcnNlSlNPTihyZXNwKSB7XG4gICAgaWYgKCFyZXNwIHx8IHJlc3AgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlXCIsIHJlc3ApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzZXJpYWxpemUob2JqLCBwYXJlbnRLZXkpIHtcbiAgICBsZXQgcXVlcnlTdHIgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcGFyYW1LZXkgPSBwYXJlbnRLZXkgPyBgJHtwYXJlbnRLZXl9WyR7a2V5fV1gIDoga2V5O1xuICAgICAgbGV0IHBhcmFtVmFsID0gb2JqW2tleV07XG4gICAgICBpZiAodHlwZW9mIHBhcmFtVmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHF1ZXJ5U3RyLnB1c2godGhpcy5zZXJpYWxpemUocGFyYW1WYWwsIHBhcmFtS2V5KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeVN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwYXJhbUtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXVlcnlTdHIuam9pbihcIiZcIik7XG4gIH1cbiAgc3RhdGljIGFwcGVuZFBhcmFtcyh1cmwsIHBhcmFtcykge1xuICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgbGV0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyBcIiZcIiA6IFwiP1wiO1xuICAgIHJldHVybiBgJHt1cmx9JHtwcmVmaXh9JHt0aGlzLnNlcmlhbGl6ZShwYXJhbXMpfWA7XG4gIH1cbn07XG5cbi8vIGpzL3Bob2VuaXgvbG9uZ3BvbGwuanNcbnZhciBMb25nUG9sbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZW5kUG9pbnQpIHtcbiAgICB0aGlzLmVuZFBvaW50ID0gbnVsbDtcbiAgICB0aGlzLnRva2VuID0gbnVsbDtcbiAgICB0aGlzLnNraXBIZWFydGJlYXQgPSB0cnVlO1xuICAgIHRoaXMub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcbiAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuICAgIHRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcbiAgICB0aGlzLm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuICAgIHRoaXMucG9sbEVuZHBvaW50ID0gdGhpcy5ub3JtYWxpemVFbmRwb2ludChlbmRQb2ludCk7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nO1xuICAgIHRoaXMucG9sbCgpO1xuICB9XG4gIG5vcm1hbGl6ZUVuZHBvaW50KGVuZFBvaW50KSB7XG4gICAgcmV0dXJuIGVuZFBvaW50LnJlcGxhY2UoXCJ3czovL1wiLCBcImh0dHA6Ly9cIikucmVwbGFjZShcIndzczovL1wiLCBcImh0dHBzOi8vXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChcIiguKikvXCIgKyBUUkFOU1BPUlRTLndlYnNvY2tldCksIFwiJDEvXCIgKyBUUkFOU1BPUlRTLmxvbmdwb2xsKTtcbiAgfVxuICBlbmRwb2ludFVSTCgpIHtcbiAgICByZXR1cm4gQWpheC5hcHBlbmRQYXJhbXModGhpcy5wb2xsRW5kcG9pbnQsIHsgdG9rZW46IHRoaXMudG9rZW4gfSk7XG4gIH1cbiAgY2xvc2VBbmRSZXRyeSgpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nO1xuICB9XG4gIG9udGltZW91dCgpIHtcbiAgICB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpO1xuICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgpO1xuICB9XG4gIHBvbGwoKSB7XG4gICAgaWYgKCEodGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLm9wZW4gfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEFqYXgucmVxdWVzdChcIkdFVFwiLCB0aGlzLmVuZHBvaW50VVJMKCksIFwiYXBwbGljYXRpb24vanNvblwiLCBudWxsLCB0aGlzLnRpbWVvdXQsIHRoaXMub250aW1lb3V0LmJpbmQodGhpcyksIChyZXNwKSA9PiB7XG4gICAgICBpZiAocmVzcCkge1xuICAgICAgICB2YXIgeyBzdGF0dXMsIHRva2VuLCBtZXNzYWdlcyB9ID0gcmVzcDtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgMjAwOlxuICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG1zZykgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMub25tZXNzYWdlKHsgZGF0YTogbXNnIH0pO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgIHRoaXMucG9sbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQxMDpcbiAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLm9wZW47XG4gICAgICAgICAgdGhpcy5vbm9wZW4oKTtcbiAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MDM6XG4gICAgICAgICAgdGhpcy5vbmVycm9yKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgNTAwOlxuICAgICAgICAgIHRoaXMub25lcnJvcigpO1xuICAgICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHBvbGwgc3RhdHVzICR7c3RhdHVzfWApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNlbmQoYm9keSkge1xuICAgIEFqYXgucmVxdWVzdChcIlBPU1RcIiwgdGhpcy5lbmRwb2ludFVSTCgpLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgYm9keSwgdGhpcy50aW1lb3V0LCB0aGlzLm9uZXJyb3IuYmluZCh0aGlzLCBcInRpbWVvdXRcIiksIChyZXNwKSA9PiB7XG4gICAgICBpZiAoIXJlc3AgfHwgcmVzcC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aGlzLm9uZXJyb3IocmVzcCAmJiByZXNwLnN0YXR1cyk7XG4gICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsb3NlKF9jb2RlLCBfcmVhc29uKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jbG9zZWQ7XG4gICAgdGhpcy5vbmNsb3NlKCk7XG4gIH1cbn07XG5cbi8vIGpzL3Bob2VuaXgvcHJlc2VuY2UuanNcbnZhciBQcmVzZW5jZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0cyA9IHt9KSB7XG4gICAgbGV0IGV2ZW50cyA9IG9wdHMuZXZlbnRzIHx8IHsgc3RhdGU6IFwicHJlc2VuY2Vfc3RhdGVcIiwgZGlmZjogXCJwcmVzZW5jZV9kaWZmXCIgfTtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXTtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgIHRoaXMuam9pblJlZiA9IG51bGw7XG4gICAgdGhpcy5jYWxsZXIgPSB7XG4gICAgICBvbkpvaW46IGZ1bmN0aW9uKCkge1xuICAgICAgfSxcbiAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgfSxcbiAgICAgIG9uU3luYzogZnVuY3Rpb24oKSB7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmNoYW5uZWwub24oZXZlbnRzLnN0YXRlLCAobmV3U3RhdGUpID0+IHtcbiAgICAgIGxldCB7IG9uSm9pbiwgb25MZWF2ZSwgb25TeW5jIH0gPSB0aGlzLmNhbGxlcjtcbiAgICAgIHRoaXMuam9pblJlZiA9IHRoaXMuY2hhbm5lbC5qb2luUmVmKCk7XG4gICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoZGlmZikgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXTtcbiAgICAgIG9uU3luYygpO1xuICAgIH0pO1xuICAgIHRoaXMuY2hhbm5lbC5vbihldmVudHMuZGlmZiwgKGRpZmYpID0+IHtcbiAgICAgIGxldCB7IG9uSm9pbiwgb25MZWF2ZSwgb25TeW5jIH0gPSB0aGlzLmNhbGxlcjtcbiAgICAgIGlmICh0aGlzLmluUGVuZGluZ1N5bmNTdGF0ZSgpKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgb25TeW5jKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25Kb2luKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2s7XG4gIH1cbiAgb25MZWF2ZShjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjaztcbiAgfVxuICBvblN5bmMoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjaztcbiAgfVxuICBsaXN0KGJ5KSB7XG4gICAgcmV0dXJuIFByZXNlbmNlLmxpc3QodGhpcy5zdGF0ZSwgYnkpO1xuICB9XG4gIGluUGVuZGluZ1N5bmNTdGF0ZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCB0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5qb2luUmVmKCk7XG4gIH1cbiAgc3RhdGljIHN5bmNTdGF0ZShjdXJyZW50U3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmNsb25lKGN1cnJlbnRTdGF0ZSk7XG4gICAgbGV0IGpvaW5zID0ge307XG4gICAgbGV0IGxlYXZlcyA9IHt9O1xuICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgaWYgKCFuZXdTdGF0ZVtrZXldKSB7XG4gICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5tYXAobmV3U3RhdGUsIChrZXksIG5ld1ByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XTtcbiAgICAgIGlmIChjdXJyZW50UHJlc2VuY2UpIHtcbiAgICAgICAgbGV0IG5ld1JlZnMgPSBuZXdQcmVzZW5jZS5tZXRhcy5tYXAoKG0pID0+IG0ucGh4X3JlZik7XG4gICAgICAgIGxldCBjdXJSZWZzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgbGV0IGpvaW5lZE1ldGFzID0gbmV3UHJlc2VuY2UubWV0YXMuZmlsdGVyKChtKSA9PiBjdXJSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApO1xuICAgICAgICBsZXQgbGVmdE1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcigobSkgPT4gbmV3UmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKTtcbiAgICAgICAgaWYgKGpvaW5lZE1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2U7XG4gICAgICAgICAgam9pbnNba2V5XS5tZXRhcyA9IGpvaW5lZE1ldGFzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0TWV0YXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxlYXZlc1trZXldID0gdGhpcy5jbG9uZShjdXJyZW50UHJlc2VuY2UpO1xuICAgICAgICAgIGxlYXZlc1trZXldLm1ldGFzID0gbGVmdE1ldGFzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHsgam9pbnMsIGxlYXZlcyB9LCBvbkpvaW4sIG9uTGVhdmUpO1xuICB9XG4gIHN0YXRpYyBzeW5jRGlmZihzdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKSB7XG4gICAgbGV0IHsgam9pbnMsIGxlYXZlcyB9ID0gdGhpcy5jbG9uZShkaWZmKTtcbiAgICBpZiAoIW9uSm9pbikge1xuICAgICAgb25Kb2luID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIW9uTGVhdmUpIHtcbiAgICAgIG9uTGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV07XG4gICAgICBzdGF0ZVtrZXldID0gdGhpcy5jbG9uZShuZXdQcmVzZW5jZSk7XG4gICAgICBpZiAoY3VycmVudFByZXNlbmNlKSB7XG4gICAgICAgIGxldCBqb2luZWRSZWZzID0gc3RhdGVba2V5XS5tZXRhcy5tYXAoKG0pID0+IG0ucGh4X3JlZik7XG4gICAgICAgIGxldCBjdXJNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIoKG0pID0+IGpvaW5lZFJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMCk7XG4gICAgICAgIHN0YXRlW2tleV0ubWV0YXMudW5zaGlmdCguLi5jdXJNZXRhcyk7XG4gICAgICB9XG4gICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2UsIG5ld1ByZXNlbmNlKTtcbiAgICB9KTtcbiAgICB0aGlzLm1hcChsZWF2ZXMsIChrZXksIGxlZnRQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV07XG4gICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgIGN1cnJlbnRQcmVzZW5jZS5tZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIoKHApID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZnNUb1JlbW92ZS5pbmRleE9mKHAucGh4X3JlZikgPCAwO1xuICAgICAgfSk7XG4gICAgICBvbkxlYXZlKGtleSwgY3VycmVudFByZXNlbmNlLCBsZWZ0UHJlc2VuY2UpO1xuICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIHN0YXRpYyBsaXN0KHByZXNlbmNlcywgY2hvb3Nlcikge1xuICAgIGlmICghY2hvb3Nlcikge1xuICAgICAgY2hvb3NlciA9IGZ1bmN0aW9uKGtleSwgcHJlcykge1xuICAgICAgICByZXR1cm4gcHJlcztcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hcChwcmVzZW5jZXMsIChrZXksIHByZXNlbmNlKSA9PiB7XG4gICAgICByZXR1cm4gY2hvb3NlcihrZXksIHByZXNlbmNlKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgbWFwKG9iaiwgZnVuYykge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcCgoa2V5KSA9PiBmdW5jKGtleSwgb2JqW2tleV0pKTtcbiAgfVxuICBzdGF0aWMgY2xvbmUob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cbn07XG5cbi8vIGpzL3Bob2VuaXgvc2VyaWFsaXplci5qc1xudmFyIHNlcmlhbGl6ZXJfZGVmYXVsdCA9IHtcbiAgSEVBREVSX0xFTkdUSDogMSxcbiAgTUVUQV9MRU5HVEg6IDQsXG4gIEtJTkRTOiB7IHB1c2g6IDAsIHJlcGx5OiAxLCBicm9hZGNhc3Q6IDIgfSxcbiAgZW5jb2RlKG1zZywgY2FsbGJhY2spIHtcbiAgICBpZiAobXNnLnBheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5iaW5hcnlFbmNvZGUobXNnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXlsb2FkID0gW21zZy5qb2luX3JlZiwgbXNnLnJlZiwgbXNnLnRvcGljLCBtc2cuZXZlbnQsIG1zZy5wYXlsb2FkXTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgfVxuICB9LFxuICBkZWNvZGUocmF3UGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBpZiAocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmJpbmFyeURlY29kZShyYXdQYXlsb2FkKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IEpTT04ucGFyc2UocmF3UGF5bG9hZCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soeyBqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWQgfSk7XG4gICAgfVxuICB9LFxuICBiaW5hcnlFbmNvZGUobWVzc2FnZSkge1xuICAgIGxldCB7IGpvaW5fcmVmLCByZWYsIGV2ZW50LCB0b3BpYywgcGF5bG9hZCB9ID0gbWVzc2FnZTtcbiAgICBsZXQgbWV0YUxlbmd0aCA9IHRoaXMuTUVUQV9MRU5HVEggKyBqb2luX3JlZi5sZW5ndGggKyByZWYubGVuZ3RoICsgdG9waWMubGVuZ3RoICsgZXZlbnQubGVuZ3RoO1xuICAgIGxldCBoZWFkZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5IRUFERVJfTEVOR1RIICsgbWV0YUxlbmd0aCk7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaGVhZGVyKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0aGlzLktJTkRTLnB1c2gpO1xuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGpvaW5fcmVmLmxlbmd0aCk7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgcmVmLmxlbmd0aCk7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdG9waWMubGVuZ3RoKTtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBldmVudC5sZW5ndGgpO1xuICAgIEFycmF5LmZyb20oam9pbl9yZWYsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICBBcnJheS5mcm9tKHJlZiwgKGNoYXIpID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuICAgIEFycmF5LmZyb20odG9waWMsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICBBcnJheS5mcm9tKGV2ZW50LCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgdmFyIGNvbWJpbmVkID0gbmV3IFVpbnQ4QXJyYXkoaGVhZGVyLmJ5dGVMZW5ndGggKyBwYXlsb2FkLmJ5dGVMZW5ndGgpO1xuICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShoZWFkZXIpLCAwKTtcbiAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGhlYWRlci5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gY29tYmluZWQuYnVmZmVyO1xuICB9LFxuICBiaW5hcnlEZWNvZGUoYnVmZmVyKSB7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBsZXQga2luZCA9IHZpZXcuZ2V0VWludDgoMCk7XG4gICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5wdXNoOlxuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2Rlcik7XG4gICAgICBjYXNlIHRoaXMuS0lORFMucmVwbHk6XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2Rlcik7XG4gICAgICBjYXNlIHRoaXMuS0lORFMuYnJvYWRjYXN0OlxuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKTtcbiAgICB9XG4gIH0sXG4gIGRlY29kZVB1c2goYnVmZmVyLCB2aWV3LCBkZWNvZGVyKSB7XG4gICAgbGV0IGpvaW5SZWZTaXplID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgzKTtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgdGhpcy5NRVRBX0xFTkdUSCAtIDE7XG4gICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpO1xuICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplO1xuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpO1xuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemU7XG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHsgam9pbl9yZWY6IGpvaW5SZWYsIHJlZjogbnVsbCwgdG9waWMsIGV2ZW50LCBwYXlsb2FkOiBkYXRhIH07XG4gIH0sXG4gIGRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2Rlcikge1xuICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSk7XG4gICAgbGV0IHJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDIpO1xuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDMpO1xuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDQpO1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyB0aGlzLk1FVEFfTEVOR1RIO1xuICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBqb2luUmVmU2l6ZTtcbiAgICBsZXQgcmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcmVmU2l6ZSkpO1xuICAgIG9mZnNldCA9IG9mZnNldCArIHJlZlNpemU7XG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSk7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplO1xuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZTtcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICBsZXQgcGF5bG9hZCA9IHsgc3RhdHVzOiBldmVudCwgcmVzcG9uc2U6IGRhdGEgfTtcbiAgICByZXR1cm4geyBqb2luX3JlZjogam9pblJlZiwgcmVmLCB0b3BpYywgZXZlbnQ6IENIQU5ORUxfRVZFTlRTLnJlcGx5LCBwYXlsb2FkIH07XG4gIH0sXG4gIGRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMjtcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemU7XG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSk7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplO1xuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB7IGpvaW5fcmVmOiBudWxsLCByZWY6IG51bGwsIHRvcGljLCBldmVudCwgcGF5bG9hZDogZGF0YSB9O1xuICB9XG59O1xuXG4vLyBqcy9waG9lbml4L3NvY2tldC5qc1xudmFyIFNvY2tldCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZW5kUG9pbnQsIG9wdHMgPSB7fSkge1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7IG9wZW46IFtdLCBjbG9zZTogW10sIGVycm9yOiBbXSwgbWVzc2FnZTogW10gfTtcbiAgICB0aGlzLmNoYW5uZWxzID0gW107XG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgdGhpcy5yZWYgPSAwO1xuICAgIHRoaXMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVQ7XG4gICAgdGhpcy50cmFuc3BvcnQgPSBvcHRzLnRyYW5zcG9ydCB8fCBnbG9iYWwuV2ViU29ja2V0IHx8IExvbmdQb2xsO1xuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucyA9IDA7XG4gICAgdGhpcy5kZWZhdWx0RW5jb2RlciA9IHNlcmlhbGl6ZXJfZGVmYXVsdC5lbmNvZGUuYmluZChzZXJpYWxpemVyX2RlZmF1bHQpO1xuICAgIHRoaXMuZGVmYXVsdERlY29kZXIgPSBzZXJpYWxpemVyX2RlZmF1bHQuZGVjb2RlLmJpbmQoc2VyaWFsaXplcl9kZWZhdWx0KTtcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZTtcbiAgICB0aGlzLmJpbmFyeVR5cGUgPSBvcHRzLmJpbmFyeVR5cGUgfHwgXCJhcnJheWJ1ZmZlclwiO1xuICAgIHRoaXMuY29ubmVjdENsb2NrID0gMTtcbiAgICBpZiAodGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKSB7XG4gICAgICB0aGlzLmVuY29kZSA9IG9wdHMuZW5jb2RlIHx8IHRoaXMuZGVmYXVsdEVuY29kZXI7XG4gICAgICB0aGlzLmRlY29kZSA9IG9wdHMuZGVjb2RlIHx8IHRoaXMuZGVmYXVsdERlY29kZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5jb2RlID0gdGhpcy5kZWZhdWx0RW5jb2RlcjtcbiAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWZhdWx0RGVjb2RlcjtcbiAgICB9XG4gICAgbGV0IGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSBudWxsO1xuICAgIGlmIChwaHhXaW5kb3cgJiYgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgKF9lKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gdGhpcy5jb25uZWN0Q2xvY2s7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCAoX2UpID0+IHtcbiAgICAgICAgaWYgKGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPT09IHRoaXMuY29ubmVjdENsb2NrKSB7XG4gICAgICAgICAgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBvcHRzLmhlYXJ0YmVhdEludGVydmFsTXMgfHwgM2U0O1xuICAgIHRoaXMucmVqb2luQWZ0ZXJNcyA9ICh0cmllcykgPT4ge1xuICAgICAgaWYgKG9wdHMucmVqb2luQWZ0ZXJNcykge1xuICAgICAgICByZXR1cm4gb3B0cy5yZWpvaW5BZnRlck1zKHRyaWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMWUzLCAyZTMsIDVlM11bdHJpZXMgLSAxXSB8fCAxZTQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgIGlmIChvcHRzLnJlY29ubmVjdEFmdGVyTXMpIHtcbiAgICAgICAgcmV0dXJuIG9wdHMucmVjb25uZWN0QWZ0ZXJNcyh0cmllcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEwLCA1MCwgMTAwLCAxNTAsIDIwMCwgMjUwLCA1MDAsIDFlMywgMmUzXVt0cmllcyAtIDFdIHx8IDVlMztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubG9nZ2VyID0gb3B0cy5sb2dnZXIgfHwgbnVsbDtcbiAgICB0aGlzLmxvbmdwb2xsZXJUaW1lb3V0ID0gb3B0cy5sb25ncG9sbGVyVGltZW91dCB8fCAyZTQ7XG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KTtcbiAgICB0aGlzLmVuZFBvaW50ID0gYCR7ZW5kUG9pbnR9LyR7VFJBTlNQT1JUUy53ZWJzb2NrZXR9YDtcbiAgICB0aGlzLnZzbiA9IG9wdHMudnNuIHx8IERFRkFVTFRfVlNOO1xuICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKTtcbiAgICB9LCB0aGlzLnJlY29ubmVjdEFmdGVyTXMpO1xuICB9XG4gIHJlcGxhY2VUcmFuc3BvcnQobmV3VHJhbnNwb3J0KSB7XG4gICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy50cmFuc3BvcnQgPSBuZXdUcmFuc3BvcnQ7XG4gIH1cbiAgcHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uLnByb3RvY29sLm1hdGNoKC9eaHR0cHMvKSA/IFwid3NzXCIgOiBcIndzXCI7XG4gIH1cbiAgZW5kUG9pbnRVUkwoKSB7XG4gICAgbGV0IHVyaSA9IEFqYXguYXBwZW5kUGFyYW1zKEFqYXguYXBwZW5kUGFyYW1zKHRoaXMuZW5kUG9pbnQsIHRoaXMucGFyYW1zKCkpLCB7IHZzbjogdGhpcy52c24gfSk7XG4gICAgaWYgKHVyaS5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICByZXR1cm4gdXJpO1xuICAgIH1cbiAgICBpZiAodXJpLmNoYXJBdCgxKSA9PT0gXCIvXCIpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9OiR7dXJpfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9Oi8vJHtsb2NhdGlvbi5ob3N0fSR7dXJpfWA7XG4gIH1cbiAgZGlzY29ubmVjdChjYWxsYmFjaywgY29kZSwgcmVhc29uKSB7XG4gICAgdGhpcy5jb25uZWN0Q2xvY2srKztcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSB0cnVlO1xuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKTtcbiAgICB0aGlzLnRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pO1xuICB9XG4gIGNvbm5lY3QocGFyYW1zKSB7XG4gICAgdGhpcy5jb25uZWN0Q2xvY2srKztcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwicGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHBhc3MgOnBhcmFtcyB0byB0aGUgU29ja2V0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2U7XG4gICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kUG9pbnRVUkwoKSk7XG4gICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSB0aGlzLmJpbmFyeVR5cGU7XG4gICAgdGhpcy5jb25uLnRpbWVvdXQgPSB0aGlzLmxvbmdwb2xsZXJUaW1lb3V0O1xuICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLm9uQ29ubk9wZW4oKTtcbiAgICB0aGlzLmNvbm4ub25lcnJvciA9IChlcnJvcikgPT4gdGhpcy5vbkNvbm5FcnJvcihlcnJvcik7XG4gICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IChldmVudCkgPT4gdGhpcy5vbkNvbm5NZXNzYWdlKGV2ZW50KTtcbiAgICB0aGlzLmNvbm4ub25jbG9zZSA9IChldmVudCkgPT4gdGhpcy5vbkNvbm5DbG9zZShldmVudCk7XG4gIH1cbiAgbG9nKGtpbmQsIG1zZywgZGF0YSkge1xuICAgIHRoaXMubG9nZ2VyKGtpbmQsIG1zZywgZGF0YSk7XG4gIH1cbiAgaGFzTG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmxvZ2dlciAhPT0gbnVsbDtcbiAgfVxuICBvbk9wZW4oY2FsbGJhY2spIHtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKCk7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLnB1c2goW3JlZiwgY2FsbGJhY2tdKTtcbiAgICByZXR1cm4gcmVmO1xuICB9XG4gIG9uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKCk7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5wdXNoKFtyZWYsIGNhbGxiYWNrXSk7XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuICBvbkVycm9yKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IucHVzaChbcmVmLCBjYWxsYmFja10pO1xuICAgIHJldHVybiByZWY7XG4gIH1cbiAgb25NZXNzYWdlKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5wdXNoKFtyZWYsIGNhbGxiYWNrXSk7XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuICBvbkNvbm5PcGVuKCkge1xuICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGNvbm5lY3RlZCB0byAke3RoaXMuZW5kUG9pbnRVUkwoKX1gKTtcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZTtcbiAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnMrKztcbiAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpO1xuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKTtcbiAgICB0aGlzLnJlc2V0SGVhcnRiZWF0KCk7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soKSk7XG4gIH1cbiAgaGVhcnRiZWF0VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuaGFzTG9nZ2VyKCkpIHtcbiAgICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWJub3JtYWxDbG9zZShcImhlYXJ0YmVhdCB0aW1lb3V0XCIpO1xuICAgIH1cbiAgfVxuICByZXNldEhlYXJ0YmVhdCgpIHtcbiAgICBpZiAodGhpcy5jb25uICYmIHRoaXMuY29ubi5za2lwSGVhcnRiZWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyk7XG4gIH1cbiAgdGVhcmRvd24oY2FsbGJhY2ssIGNvZGUsIHJlYXNvbikge1xuICAgIGlmICghdGhpcy5jb25uKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgdGhpcy5jb25uLmNsb3NlKGNvZGUsIHJlYXNvbiB8fCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgPSAxKSB7XG4gICAgaWYgKHRyaWVzID09PSA1IHx8ICF0aGlzLmNvbm4gfHwgIXRoaXMuY29ubi5idWZmZXJlZEFtb3VudCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLndhaXRGb3JCdWZmZXJEb25lKGNhbGxiYWNrLCB0cmllcyArIDEpO1xuICAgIH0sIDE1MCAqIHRyaWVzKTtcbiAgfVxuICB3YWl0Rm9yU29ja2V0Q2xvc2VkKGNhbGxiYWNrLCB0cmllcyA9IDEpIHtcbiAgICBpZiAodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCB0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jbG9zZWQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKGNhbGxiYWNrLCB0cmllcyArIDEpO1xuICAgIH0sIDE1MCAqIHRyaWVzKTtcbiAgfVxuICBvbkNvbm5DbG9zZShldmVudCkge1xuICAgIGxldCBjbG9zZUNvZGUgPSBldmVudCAmJiBldmVudC5jb2RlO1xuICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJjbG9zZVwiLCBldmVudCk7XG4gICAgdGhpcy50cmlnZ2VyQ2hhbkVycm9yKCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgIGlmICghdGhpcy5jbG9zZVdhc0NsZWFuICYmIGNsb3NlQ29kZSAhPT0gMWUzKSB7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soZXZlbnQpKTtcbiAgfVxuICBvbkNvbm5FcnJvcihlcnJvcikge1xuICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgZXJyb3IpO1xuICAgIGxldCB0cmFuc3BvcnRCZWZvcmUgPSB0aGlzLnRyYW5zcG9ydDtcbiAgICBsZXQgZXN0YWJsaXNoZWRCZWZvcmUgPSB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnM7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IHtcbiAgICAgIGNhbGxiYWNrKGVycm9yLCB0cmFuc3BvcnRCZWZvcmUsIGVzdGFibGlzaGVkQmVmb3JlKTtcbiAgICB9KTtcbiAgICBpZiAodHJhbnNwb3J0QmVmb3JlID09PSB0aGlzLnRyYW5zcG9ydCB8fCBlc3RhYmxpc2hlZEJlZm9yZSA+IDApIHtcbiAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpO1xuICAgIH1cbiAgfVxuICB0cmlnZ2VyQ2hhbkVycm9yKCkge1xuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4ge1xuICAgICAgaWYgKCEoY2hhbm5lbC5pc0Vycm9yZWQoKSB8fCBjaGFubmVsLmlzTGVhdmluZygpIHx8IGNoYW5uZWwuaXNDbG9zZWQoKSkpIHtcbiAgICAgICAgY2hhbm5lbC50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgc3dpdGNoICh0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnJlYWR5U3RhdGUpIHtcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nOlxuICAgICAgICByZXR1cm4gXCJjb25uZWN0aW5nXCI7XG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMub3BlbjpcbiAgICAgICAgcmV0dXJuIFwib3BlblwiO1xuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNsb3Npbmc6XG4gICAgICAgIHJldHVybiBcImNsb3NpbmdcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcImNsb3NlZFwiO1xuICAgIH1cbiAgfVxuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gXCJvcGVuXCI7XG4gIH1cbiAgcmVtb3ZlKGNoYW5uZWwpIHtcbiAgICB0aGlzLm9mZihjaGFubmVsLnN0YXRlQ2hhbmdlUmVmcyk7XG4gICAgdGhpcy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZmlsdGVyKChjKSA9PiBjLmpvaW5SZWYoKSAhPT0gY2hhbm5lbC5qb2luUmVmKCkpO1xuICB9XG4gIG9mZihyZWZzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XS5maWx0ZXIoKFtyZWZdKSA9PiB7XG4gICAgICAgIHJldHVybiByZWZzLmluZGV4T2YocmVmKSA9PT0gLTE7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcyA9IHt9KSB7XG4gICAgbGV0IGNoYW4gPSBuZXcgQ2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcywgdGhpcyk7XG4gICAgdGhpcy5jaGFubmVscy5wdXNoKGNoYW4pO1xuICAgIHJldHVybiBjaGFuO1xuICB9XG4gIHB1c2goZGF0YSkge1xuICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKSB7XG4gICAgICBsZXQgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWYgfSA9IGRhdGE7XG4gICAgICB0aGlzLmxvZyhcInB1c2hcIiwgYCR7dG9waWN9ICR7ZXZlbnR9ICgke2pvaW5fcmVmfSwgJHtyZWZ9KWAsIHBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aGlzLmVuY29kZShkYXRhLCAocmVzdWx0KSA9PiB0aGlzLmNvbm4uc2VuZChyZXN1bHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goKCkgPT4gdGhpcy5lbmNvZGUoZGF0YSwgKHJlc3VsdCkgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSkpO1xuICAgIH1cbiAgfVxuICBtYWtlUmVmKCkge1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDE7XG4gICAgaWYgKG5ld1JlZiA9PT0gdGhpcy5yZWYpIHtcbiAgICAgIHRoaXMucmVmID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWYgPSBuZXdSZWY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlZi50b1N0cmluZygpO1xuICB9XG4gIHNlbmRIZWFydGJlYXQoKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiAmJiAhdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IHRoaXMubWFrZVJlZigpO1xuICAgIHRoaXMucHVzaCh7IHRvcGljOiBcInBob2VuaXhcIiwgZXZlbnQ6IFwiaGVhcnRiZWF0XCIsIHBheWxvYWQ6IHt9LCByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiB9KTtcbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhlYXJ0YmVhdFRpbWVvdXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKTtcbiAgfVxuICBhYm5vcm1hbENsb3NlKHJlYXNvbikge1xuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRoaXMuY29ubi5jbG9zZShXU19DTE9TRV9OT1JNQUwsIHJlYXNvbik7XG4gICAgfVxuICB9XG4gIGZsdXNoU2VuZEJ1ZmZlcigpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgfVxuICB9XG4gIG9uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSkge1xuICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgKG1zZykgPT4ge1xuICAgICAgbGV0IHsgdG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmIH0gPSBtc2c7XG4gICAgICBpZiAocmVmICYmIHJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgICB0aGlzLmxvZyhcInJlY2VpdmVcIiwgYCR7cGF5bG9hZC5zdGF0dXMgfHwgXCJcIn0gJHt0b3BpY30gJHtldmVudH0gJHtyZWYgJiYgXCIoXCIgKyByZWYgKyBcIilcIiB8fCBcIlwifWAsIHBheWxvYWQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuICAgICAgICBpZiAoIWNoYW5uZWwuaXNNZW1iZXIodG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luX3JlZikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGFubmVsLnRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWYpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IFssIGNhbGxiYWNrXSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZVtpXTtcbiAgICAgICAgY2FsbGJhY2sobXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZWF2ZU9wZW5Ub3BpYyh0b3BpYykge1xuICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKChjKSA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5pc0pvaW5lZCgpIHx8IGMuaXNKb2luaW5nKCkpKTtcbiAgICBpZiAoZHVwQ2hhbm5lbCkge1xuICAgICAgaWYgKHRoaXMuaGFzTG9nZ2VyKCkpXG4gICAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKTtcbiAgICAgIGR1cENoYW5uZWwubGVhdmUoKTtcbiAgICB9XG4gIH1cbn07XG5leHBvcnQge1xuICBDaGFubmVsLFxuICBMb25nUG9sbCxcbiAgUHJlc2VuY2UsXG4gIHNlcmlhbGl6ZXJfZGVmYXVsdCBhcyBTZXJpYWxpemVyLFxuICBTb2NrZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waG9lbml4LmVzbS5qcy5tYXBcbiIsImltcG9ydCB7IFNvY2tldCB9IGZyb20gXCJwaG9lbml4XCI7XG5cbmxldCBjb25maWdzID0ge1xuICBSRVRJQ1VMVU1fU09DS0VUX1NFUlZFUl9QT1JUOiBcIjQ0M1wiLFxuICBSRVRJQ1VMVU1fU09DS0VUX1NFUlZFUjogXCJhbHBoYWh1Yi5hcHRlcm8uY29cIiwgLy9UT0RPXG4gIFJFVElDVUxVTV9TT0NLRVRfUFJPVE9DT0w6IFwid3NzOlwiLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUh1YkNoYW5uZWxQYXJhbXMoXG4gIGF1dGhUb2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGwsXG4gIHBlcm1zVG9rZW46IHN0cmluZyB8IG51bGwgPSBudWxsXG4pIHtcbiAgLyp7XG4gICAgICAgIFwicHJvZmlsZVwiOiB7XG4gICAgICAgIFwiYXZhdGFySWRcIjogXCJodHRwczovL2h1Yi5hcHRlcm8uY28vZGF0YS9hdmF0YXIvQTAzMS9iYXNlLmdsYlwiLFxuICAgICAgICAgICAgXCJkaXNwbGF5TmFtZVwiOiBcIlBpZXJyZVwiXG4gICAgfSxcbiAgICAgICAgXCJwdXNoX3N1YnNjcmlwdGlvbl9lbmRwb2ludFwiOiBudWxsLFxuICAgICAgICBcImF1dGhfdG9rZW5cIjogXCJleUpoYkdjaU9pSklVelV4TWlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKaGRXUWlPaUp5WlhRaUxDSmxlSEFpT2pFMk1qTTJOemM0TnpVc0ltbGhkQ0k2TVRZeE5qUXlNREkzTlN3aWFYTnpJam9pY21WMElpd2lhblJwSWpvaU1UQmtNV0ZrWm1ZdFlqQmxNaTAwTjJSa0xXRmlNVGd0TWpZM01HWTBaRFZoTVRGa0lpd2libUptSWpveE5qRTJOREl3TWpjMExDSnpkV0lpT2lJMk5EQTBNRGN3TlRBNU5qWXlOams1TmpFaUxDSjBlWEFpT2lKaFkyTmxjM01pZlEucXAyOUlwNEFLa3BSUHRWVk9VaWt5dEwxdS1sR1BKaWRVZ2xzV2xXOEg5aXpnZFJzb0hfYzB5WnVBMDRNaXdpNksyaU4tR3NvQ3I4S2QxZlRIMHlwMmdcIixcbiAgICAgICAgXCJwZXJtc190b2tlblwiOiBudWxsLFxuICAgICAgICBcImNvbnRleHRcIjoge1xuICAgICAgICBcIm1vYmlsZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwiZW1iZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAgICAgIFwiaHViX2ludml0ZV9pZFwiOiBudWxsXG4gICAgfSovXG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICBwcm9maWxlOiB7XG4gICAgICBhdmF0YXJJZDogXCJcIixcbiAgICAgIGRpc3BsYXlOYW1lOiBcIlwiLFxuICAgIH0sXG4gICAgcHVzaF9zdWJzY3JpcHRpb25fZW5kcG9pbnQ6IG51bGwsXG4gICAgYXV0aF90b2tlbjogbnVsbCxcbiAgICBwZXJtc190b2tlbjogbnVsbCxcbiAgICBib3RfYWNjZXNzX2tleTogbnVsbCxcbiAgICBjb250ZXh0OiB7XG4gICAgICBtb2JpbGU6IGZhbHNlLFxuICAgICAgZW1iZWQ6IHRydWUsXG4gICAgfSxcbiAgICBodWJfaW52aXRlX2lkOiBudWxsLFxuICB9O1xuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkKFxuICBodWJpZFxuKTogUHJvbWlzZTx7IGRhdGE6IGFueTsgaHViUGh4Q2hhbm5lbDogYW55OyB2YXBpZGRhdGE6IGFueSB9PiB7XG4gIGNvbnN0IHNvY2tldCA9IGF3YWl0IGNvbm5lY3RUb1JldGljdWx1bSgpO1xuICBzb2NrZXQub25DbG9zZSgoZSkgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gIH0pO1xuXG4gIGNvbnN0IHsgZGF0YSwgaHViUGh4Q2hhbm5lbCwgdmFwaWRkYXRhIH0gPSBhd2FpdCBuZXcgUHJvbWlzZShcbiAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBSZXRpY3VsdW0gZ2xvYmFsIGNoYW5uZWxcbiAgICAgIGxldCByZXRDaGFubmVsID0gc29ja2V0LmNoYW5uZWwoYHJldGAsIHsgaHViX2lkOiBodWJpZCB9KTtcbiAgICAgIHJldENoYW5uZWxcbiAgICAgICAgLmpvaW4oKVxuICAgICAgICAucmVjZWl2ZShcIm9rXCIsICh2YXBpZGRhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCBodWJQaHhDaGFubmVsID0gc29ja2V0LmNoYW5uZWwoXG4gICAgICAgICAgICBgaHViOmAgKyBodWJpZCxcbiAgICAgICAgICAgIGNyZWF0ZUh1YkNoYW5uZWxQYXJhbXMoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaHViUGh4Q2hhbm5lbFxuICAgICAgICAgICAgLmpvaW4oKVxuICAgICAgICAgICAgLnJlY2VpdmUoXCJva1wiLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKHsgZGF0YSwgaHViUGh4Q2hhbm5lbCwgdmFwaWRkYXRhIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgKHJlcykgPT4ge1xuICAgICAgICAgICAgICByZWplY3QocmVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAucmVjZWl2ZShcImVycm9yXCIsIChyZXMpID0+IHtcbiAgICAgICAgICByZWplY3QocmVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICApO1xuICByZXR1cm4geyBkYXRhLCBodWJQaHhDaGFubmVsLCB2YXBpZGRhdGEgfTtcbn1cblxubGV0IHJldGljdWx1bU1ldGE6IGFueSA9IG51bGw7XG5sZXQgaW52YWxpZGF0ZWRSZXRpY3VsdW1NZXRhVGhpc1Nlc3Npb24gPSBmYWxzZTtcblxubGV0IGRpcmVjdFJldGljdWx1bUhvc3RBbmRQb3J0O1xuXG5hc3luYyBmdW5jdGlvbiByZWZyZXNoRGlyZWN0UmV0aWN1bHVtSG9zdEFuZFBvcnQoKSB7XG4gIGNvbnN0IHFzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2gpO1xuICBsZXQgaG9zdCA9IHFzLmdldChcInBoeF9ob3N0XCIpO1xuICBob3N0ID0gaG9zdCB8fCBjb25maWdzLlJFVElDVUxVTV9TT0NLRVRfU0VSVkVSO1xuICBjb25zdCBwb3J0ID0gY29uZmlncy5SRVRJQ1VMVU1fU09DS0VUX1NFUlZFUl9QT1JUO1xuICBkaXJlY3RSZXRpY3VsdW1Ib3N0QW5kUG9ydCA9IHsgaG9zdCwgcG9ydCB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW52YWxpZGF0ZVJldGljdWx1bU1ldGEoKSB7XG4gIGludmFsaWRhdGVkUmV0aWN1bHVtTWV0YVRoaXNTZXNzaW9uID0gdHJ1ZTtcbiAgcmV0aWN1bHVtTWV0YSA9IG51bGw7XG59XG5cbi8vVE9ETyBpbXBvcnRhbnQgZnVuY3Rpb25cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25uZWN0VG9SZXRpY3VsdW0oXG4gIGRlYnVnID0gZmFsc2UsXG4gIHBhcmFtcyA9IG51bGwsXG4gIHNvY2tldENsYXNzID0gU29ja2V0XG4pIHtcbiAgY29uc3QgcXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCk7XG5cbiAgY29uc3QgZ2V0TmV3U29ja2V0VXJsID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHJlZnJlc2hEaXJlY3RSZXRpY3VsdW1Ib3N0QW5kUG9ydCgpO1xuICAgIGNvbnN0IHsgaG9zdCwgcG9ydCB9ID0gZGlyZWN0UmV0aWN1bHVtSG9zdEFuZFBvcnQ7XG4gICAgY29uc3QgcHJvdG9jb2wgPVxuICAgICAgcXMuZ2V0KFwicGh4X3Byb3RvY29sXCIpIHx8XG4gICAgICBjb25maWdzLlJFVElDVUxVTV9TT0NLRVRfUFJPVE9DT0wgfHxcbiAgICAgIChkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwid3NzOlwiIDogXCJ3czpcIik7XG5cbiAgICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3R9JHtwb3J0ID8gYDoke3BvcnR9YCA6IFwiXCJ9YDtcbiAgfTtcblxuICBjb25zdCBzb2NrZXRVcmwgPSBhd2FpdCBnZXROZXdTb2NrZXRVcmwoKTtcbiAgY29uc29sZS5sb2coYFBob2VuaXggU29ja2V0IFVSTDogJHtzb2NrZXRVcmx9YCk7XG5cbiAgY29uc3Qgc29ja2V0U2V0dGluZ3M6IGFueSA9IHt9O1xuXG4gIGlmIChkZWJ1Zykge1xuICAgIHNvY2tldFNldHRpbmdzLmxvZ2dlciA9IChraW5kLCBtc2csIGRhdGEpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHBhcmFtcykge1xuICAgIHNvY2tldFNldHRpbmdzLnBhcmFtcyA9IHBhcmFtcztcbiAgfVxuXG4gIGNvbnN0IHNvY2tldCA9IG5ldyBzb2NrZXRDbGFzcyhgJHtzb2NrZXRVcmx9L3NvY2tldGAsIHNvY2tldFNldHRpbmdzKTtcbiAgc29ja2V0LmNvbm5lY3QoKTtcbiAgc29ja2V0Lm9uRXJyb3IoYXN5bmMgKCkgPT4ge1xuICAgIC8vIE9uIGVycm9yLCB1bmRlcmx5aW5nIHJldGljdWx1bSBub2RlIG1heSBoYXZlIGRpZWQsIHNvIHJlYmFsYW5jZSBieVxuICAgIC8vIGZldGNoaW5nIGEgbmV3IGhlYWx0aHkgbm9kZSB0byBjb25uZWN0IHRvLlxuICAgIGludmFsaWRhdGVSZXRpY3VsdW1NZXRhKCk7XG5cbiAgICBjb25zdCBlbmRQb2ludFBhdGggPSBuZXcgVVJMKHNvY2tldC5lbmRQb2ludCkucGF0aG5hbWU7XG4gICAgY29uc3QgbmV3U29ja2V0VXJsID0gYXdhaXQgZ2V0TmV3U29ja2V0VXJsKCk7XG4gICAgY29uc3QgbmV3RW5kUG9pbnQgPSBgJHtuZXdTb2NrZXRVcmx9JHtlbmRQb2ludFBhdGh9YDtcbiAgICBjb25zb2xlLmxvZyhgU29ja2V0IGVycm9yLCBjaGFuZ2VkIGVuZHBvaW50IHRvICR7bmV3RW5kUG9pbnR9YCk7XG4gICAgc29ja2V0LmVuZFBvaW50ID0gbmV3RW5kUG9pbnQ7XG4gIH0pO1xuXG4gIHJldHVybiBzb2NrZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmVzZW5jZUVudHJ5Rm9yU2Vzc2lvbihwcmVzZW5jZXMsIHNlc3Npb25JZCkge1xuICBjb25zdCBlbnRyeSA9XG4gICAgT2JqZWN0LmVudHJpZXMocHJlc2VuY2VzIHx8IHt9KS5maW5kKChba10pID0+IGsgPT09IHNlc3Npb25JZCkgfHwgW107XG4gIGNvbnN0IHByZXNlbmNlOiBhbnkgPSBlbnRyeVsxXTtcbiAgcmV0dXJuIChwcmVzZW5jZSAmJiBwcmVzZW5jZS5tZXRhcyAmJiBwcmVzZW5jZS5tZXRhc1swXSkgfHwge307XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmVzZW5jZUNvbnRleHRGb3JTZXNzaW9uKHByZXNlbmNlcywgc2Vzc2lvbklkKSB7XG4gIHJldHVybiAoZ2V0UHJlc2VuY2VFbnRyeUZvclNlc3Npb24ocHJlc2VuY2VzLCBzZXNzaW9uSWQpIHx8IHt9KS5jb250ZXh0IHx8IHt9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJlc2VuY2VQcm9maWxlRm9yU2Vzc2lvbihwcmVzZW5jZXMsIHNlc3Npb25JZCkge1xuICByZXR1cm4gKGdldFByZXNlbmNlRW50cnlGb3JTZXNzaW9uKHByZXNlbmNlcywgc2Vzc2lvbklkKSB8fCB7fSkucHJvZmlsZSB8fCB7fTtcbn1cblxuZnVuY3Rpb24gbWlncmF0ZUJpbmRpbmdzKG9sZENoYW5uZWwsIG5ld0NoYW5uZWwpIHtcbiAgY29uc3QgZG9Ob3REdXBsaWNhdGUgPSBbXG4gICAgXCJwaHhfY2xvc2VcIixcbiAgICBcInBoeF9lcnJvclwiLFxuICAgIFwicGh4X3JlcGx5XCIsXG4gICAgXCJwcmVzZW5jZV9zdGF0ZVwiLFxuICAgIFwicHJlc2VuY2VfZGlmZlwiLFxuICBdO1xuICBjb25zdCBzaG91bGREdXBsaWNhdGUgPSAoZXZlbnQpID0+IHtcbiAgICByZXR1cm4gIWV2ZW50LnN0YXJ0c1dpdGgoXCJjaGFuX3JlcGx5X1wiKSAmJiAhZG9Ob3REdXBsaWNhdGUuaW5jbHVkZXMoZXZlbnQpO1xuICB9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IG9sZENoYW5uZWwuYmluZGluZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgaXRlbSA9IG9sZENoYW5uZWwuYmluZGluZ3NbaV07XG4gICAgaWYgKHNob3VsZER1cGxpY2F0ZShpdGVtLmV2ZW50KSkge1xuICAgICAgbmV3Q2hhbm5lbC5iaW5kaW5ncy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuICBuZXdDaGFubmVsLmJpbmRpbmdSZWYgPSBvbGRDaGFubmVsLmJpbmRpbmdSZWY7XG59XG5cbi8vIFRha2VzIHRoZSBnaXZlbiBjaGFubmVsLCBhbmQgY3JlYXRlcyBhIG5ldyBjaGFubmVsIHdpdGggdGhlIHNhbWUgYmluZGluZ3Ncbi8vIHdpdGggdGhlIGdpdmVuIHNvY2tldCwgam9pbnMgaXQsIGFuZCBsZWF2ZXMgdGhlIG9sZCBjaGFubmVsIGFmdGVyIGpvaW5pbmcuXG4vL1xuLy8gTk9URTogVGhpcyBmdW5jdGlvbiByZWxpZXMgdXBvbiBwaG9lbml4IGNoYW5uZWwgb2JqZWN0IGludGVybmFscywgc28gdGhpc1xuLy8gZnVuY3Rpb24gd2lsbCBuZWVkIHRvIGJlIHJldmlld2VkIGlmL3doZW4gd2UgZXZlciB1cGRhdGUgcGhvZW5peC5qc1xuZXhwb3J0IGZ1bmN0aW9uIG1pZ3JhdGVDaGFubmVsVG9Tb2NrZXQob2xkQ2hhbm5lbCwgc29ja2V0LCBwYXJhbXMpIHtcbiAgY29uc3QgY2hhbm5lbCA9IHNvY2tldC5jaGFubmVsKG9sZENoYW5uZWwudG9waWMsIHBhcmFtcyB8fCBvbGRDaGFubmVsLnBhcmFtcyk7XG5cbiAgbWlncmF0ZUJpbmRpbmdzKG9sZENoYW5uZWwsIGNoYW5uZWwpO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gb2xkQ2hhbm5lbC5wdXNoQnVmZmVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGl0ZW0gPSBvbGRDaGFubmVsLnB1c2hCdWZmZXJbaV07XG4gICAgY2hhbm5lbC5wdXNoKGl0ZW0uZXZlbnQsIGl0ZW0ucGF5bG9hZCwgaXRlbS50aW1lb3V0KTtcbiAgfVxuXG4gIGNvbnN0IG9sZEpvaW5QdXNoID0gb2xkQ2hhbm5lbC5qb2luUHVzaDtcbiAgY29uc3Qgam9pblB1c2ggPSBjaGFubmVsLmpvaW4oKTtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IG9sZEpvaW5QdXNoLnJlY0hvb2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGl0ZW0gPSBvbGRKb2luUHVzaC5yZWNIb29rc1tpXTtcbiAgICBqb2luUHVzaC5yZWNlaXZlKGl0ZW0uc3RhdHVzLCBpdGVtLmNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGpvaW5QdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICAvLyBDbGVhciBhbGwgZXZlbnQgaGFuZGxlcnMgZmlyc3Qgc28gbm8gZHVwbGljYXRlIG1lc3NhZ2VzIGNvbWUgaW4uXG4gICAgICBvbGRDaGFubmVsLmJpbmRpbmdzID0gW107XG4gICAgICByZXNvbHZlKGNoYW5uZWwpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1pZ3JhdGVUb0NoYW5uZWwob2xkQ2hhbm5lbCwgbmV3Q2hhbm5lbCkge1xuICBtaWdyYXRlQmluZGluZ3Mob2xkQ2hhbm5lbCwgbmV3Q2hhbm5lbCk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBuZXdDaGFubmVsXG4gICAgICAuam9pbigpXG4gICAgICAucmVjZWl2ZShcIm9rXCIsIChkYXRhKSA9PiB7XG4gICAgICAgIG9sZENoYW5uZWwubGVhdmUoKTtcbiAgICAgICAgb2xkQ2hhbm5lbC5iaW5kaW5ncyA9IFtdO1xuICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgfSlcbiAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgbmV3Q2hhbm5lbC5sZWF2ZSgpO1xuICAgICAgICByZWplY3QoZGF0YSk7XG4gICAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNjb3JkQnJpZGdlc0ZvclByZXNlbmNlcyhwcmVzZW5jZXM6IGFueVtdKSB7XG4gIGNvbnN0IGNoYW5uZWxzID0gW107XG4gIGZvciAoY29uc3QgcCBvZiBPYmplY3QudmFsdWVzKHByZXNlbmNlcykpIHtcbiAgICBmb3IgKGNvbnN0IG0gb2YgcC5tZXRhcykge1xuICAgICAgaWYgKG0ucHJvZmlsZSAmJiBtLnByb2ZpbGUuZGlzY29yZEJyaWRnZXMpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoXG4gICAgICAgICAgY2hhbm5lbHMsXG4gICAgICAgICAgbS5wcm9maWxlLmRpc2NvcmRCcmlkZ2VzLm1hcCgoYikgPT4gYi5jaGFubmVsLm5hbWUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGFubmVscztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0VtYmVkUHJlc2VuY2VzKHByZXNlbmNlczogYW55W10pIHtcbiAgZm9yIChjb25zdCBwIG9mIE9iamVjdC52YWx1ZXMocHJlc2VuY2VzKSkge1xuICAgIGZvciAoY29uc3QgbSBvZiBwLm1ldGFzKSB7XG4gICAgICBpZiAobS5jb250ZXh0ICYmIG0uY29udGV4dC5lbWJlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZW5vaXNlUHJlc2VuY2UoeyBvbkpvaW4sIG9uTGVhdmUsIG9uQ2hhbmdlIH0pIHtcbiAgcmV0dXJuIHtcbiAgICByYXdPbkpvaW46IChrZXksIGJlZm9yZUpvaW4sIGFmdGVySm9pbikgPT4ge1xuICAgICAgaWYgKGJlZm9yZUpvaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbkpvaW4oa2V5LCBhZnRlckpvaW4ubWV0YXNbMF0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmF3T25MZWF2ZTogKGtleSwgcmVtYWluaW5nLCByZW1vdmVkKSA9PiB7XG4gICAgICBpZiAocmVtYWluaW5nLm1ldGFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvbkxlYXZlKGtleSwgcmVtb3ZlZC5tZXRhc1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkNoYW5nZShcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcmVtb3ZlZC5tZXRhc1tyZW1vdmVkLm1ldGFzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIHJlbWFpbmluZy5tZXRhc1tyZW1haW5pbmcubWV0YXMubGVuZ3RoIC0gMV1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlc2VuY2VFdmVudHNGb3JIdWIoZXZlbnRzKSB7XG4gIGNvbnN0IG9uSm9pbiA9IChrZXksIG1ldGEpID0+IHtcbiAgICBldmVudHMudHJpZ2dlcihgaHViOmpvaW5gLCB7IGtleSwgbWV0YSB9KTtcbiAgfTtcbiAgY29uc3Qgb25MZWF2ZSA9IChrZXksIG1ldGEpID0+IHtcbiAgICBldmVudHMudHJpZ2dlcihgaHViOmxlYXZlYCwgeyBrZXksIG1ldGEgfSk7XG4gIH07XG4gIGNvbnN0IG9uQ2hhbmdlID0gKGtleSwgcHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICBldmVudHMudHJpZ2dlcihgaHViOmNoYW5nZWAsIHsga2V5LCBwcmV2aW91cywgY3VycmVudCB9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBvbkpvaW4sXG4gICAgb25MZWF2ZSxcbiAgICBvbkNoYW5nZSxcbiAgfTtcbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBhcHRlcm8vYXhvbG90aXMtcGxheWVyL2J1aWxkL3R5cGVzL21vZHVsZXMvY29yZS9lY3MvQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBXZWJwYWNrTGF6eU1vZHVsZSB9IGZyb20gXCJAYXB0ZXJvL2F4b2xvdGlzLXBsYXllci9idWlsZC90eXBlcy9tb2R1bGVzL2NvcmUvbG9hZGVyL1dlYnBhY2tMb2FkZXJcIjtcbmltcG9ydCB7IENvbXBvbmVudEZhY3RvcnkgfSBmcm9tIFwiQGFwdGVyby9heG9sb3Rpcy1wbGF5ZXIvYnVpbGQvdHlwZXMvbW9kdWxlcy9jb3JlL2Vjcy9Db21wb25lbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBXb3JsZEVudGl0eSB9IGZyb20gXCJAYXB0ZXJvL2F4b2xvdGlzLXBsYXllci9idWlsZC90eXBlcy9tb2R1bGVzL2NvcmUvZWNzL1dvcmxkRW50aXR5XCI7XG4vL2ltcG9ydCB7IFNlcnZpY2VFbnRpdHkgfSBmcm9tIFwiQGFwdGVyby9heG9sb3Rpcy1wbGF5ZXIvYnVpbGQvdHlwZXMvbW9kdWxlcy9jb3JlL3NlcnZpY2UvU2VydmljZUVudGl0eVwiO1xuaW1wb3J0IHsgU2VydmljZUVudGl0eSB9IGZyb20gXCJAYXB0ZXJvL2F4b2xvdGlzLXBsYXllclwiO1xuaW1wb3J0IFNjZW5lTG9hZGVyIGZyb20gXCJAcm9vdC9saWIvbW9kdWxlcy9zcG9rZS9TY2VuZUxvYWRlclwiO1xuaW1wb3J0IHsgVGhyZWVMaWIgfSBmcm9tIFwiQHJvb3QvbGliL21vZHVsZXMvdGhyZWUvVGhyZWVMaWJcIjtcbmltcG9ydCB7IFBsYXllclNlcnZpY2UgfSBmcm9tIFwiQHJvb3QvbGliL21vZHVsZXMvY29udHJvbGxlci9QbGF5ZXJTZXJ2aWNlXCI7XG5pbXBvcnQgeyBsb2FkIH0gZnJvbSBcIkByb290L2xpYi9tb2R1bGVzL3Nwb2tlL1Bob2VuaXhVdGlsc1wiO1xuXG5leHBvcnQgY2xhc3MgU3Bva2VSb29tTG9hZGVyIGltcGxlbWVudHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHNjZW5lTG9hZGVyOiBTY2VuZUxvYWRlciB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdGhyZWVMaWI6IFRocmVlTGliKSB7fVxuXG4gIGFzeW5jIGxvYWRSb29tKGh1YmlkKSB7XG4gICAgY29uc3QgeyBkYXRhLCBodWJQaHhDaGFubmVsLCB2YXBpZGRhdGEgfSA9IGF3YWl0IGxvYWQoaHViaWQpO1xuICAgIGNvbnN0IHNjZW5lVVJMID0gZGF0YS5odWJzWzBdLnNjZW5lLm1vZGVsX3VybC5yZXBsYWNlKFwiLmJpblwiLCBcIi5nbGJcIik7XG4gICAgdGhpcy5zY2VuZUxvYWRlciA9IG5ldyBTY2VuZUxvYWRlcigpO1xuICAgIGF3YWl0IHRoaXMuc2NlbmVMb2FkZXIubG9hZFNjZW5lKHNjZW5lVVJMLCB0aGlzLnRocmVlTGliKTtcbiAgfVxuXG4gIGdldFR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gU3Bva2VSb29tTG9hZGVyLm5hbWU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZhY3RvcnlcbiAgaW1wbGVtZW50cyBXZWJwYWNrTGF6eU1vZHVsZSwgQ29tcG9uZW50RmFjdG9yeTxTcG9rZVJvb21Mb2FkZXI+XG57XG4gIGFzeW5jIGNyZWF0ZUNvbXBvbmVudChcbiAgICB3b3JsZDogV29ybGRFbnRpdHksXG4gICAgY29uZmlnOiBhbnlcbiAgKTogUHJvbWlzZTxTcG9rZVJvb21Mb2FkZXI+IHtcbiAgICBsZXQgc2VydmljZXMgPSB3b3JsZC5nZXRGaXJzdENvbXBvbmVudEJ5VHlwZTxTZXJ2aWNlRW50aXR5PihcbiAgICAgIFNlcnZpY2VFbnRpdHkubmFtZVxuICAgICk7XG4gICAgbGV0IHRocmVlID0gYXdhaXQgc2VydmljZXMuZ2V0U2VydmljZTxUaHJlZUxpYj4oXG4gICAgICBcIkBhcHRlcm8vYXhvbG90aXMtY29yZS1wbHVnaW5zL21vZHVsZXMvdGhyZWUvVGhyZWVMaWJcIlxuICAgICk7XG4gICAgbGV0IHBsYXllclNlcnZpY2UgPSBhd2FpdCBzZXJ2aWNlcy5nZXRTZXJ2aWNlPFBsYXllclNlcnZpY2U+KFxuICAgICAgXCJAYXB0ZXJvL2F4b2xvdGlzLWNvcmUtcGx1Z2lucy9tb2R1bGVzL2NvbnRyb2xsZXIvUGxheWVyU2VydmljZVwiXG4gICAgKTtcbiAgICBsZXQgc3Bva2VSb29tTG9hZGVyID0gbmV3IFNwb2tlUm9vbUxvYWRlcih0aHJlZSk7XG4gICAgYXdhaXQgc3Bva2VSb29tTG9hZGVyLmxvYWRSb29tKGNvbmZpZy5yb29tKTtcbiAgICBpZiAoc3Bva2VSb29tTG9hZGVyLnNjZW5lTG9hZGVyKSB7XG4gICAgICBwbGF5ZXJTZXJ2aWNlXG4gICAgICAgIC5nZXRDdXJyZW50UGxheWVyKClcbiAgICAgICAgLmRlY2xhcmVOYXZNZXNoKHNwb2tlUm9vbUxvYWRlci5zY2VuZUxvYWRlci5uYXZNZXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwb2tlUm9vbUxvYWRlcjtcbiAgfVxufVxuXG4vKlxuSGF2ZSB0byBjb25uZWN0IHRvIHRoZSBwaG9lbml4IHdlYnNvY2tldFxuYW5kIGdldCBzY2VuZSB1cmwgZnJvbSBtZXNzYWdlIGZyb21cbltcIjJcIiwgXCIyXCIsIFwiaHViOnlVWEQ3QTJcIiwgXCJwaHhfcmVwbHlcIiwge1xuICAgIFwicmVzcG9uc2VcIjoge1xuICAgICAgICBcImh1Yl9yZXF1aXJlc19vYXV0aFwiOiBmYWxzZSxcbiAgICAgICAgXCJodWJzXCI6IFt7XG4gICAgICAgICAgICBcImFsbG93X3Byb21vdGlvblwiOiB0cnVlLFxuICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBudWxsLFxuICAgICAgICAgICAgXCJlbWJlZF90b2tlblwiOiBcImMyMjNiMjdiOWU2ZjQ4YzU1OTFiNGIxNDBmZTdkZTZmXCIsXG4gICAgICAgICAgICBcImVudHJ5X2NvZGVcIjogMTgwNDI5LFxuICAgICAgICAgICAgXCJlbnRyeV9tb2RlXCI6IFwiYWxsb3dcIixcbiAgICAgICAgICAgIFwiaG9zdFwiOiBcImRlZGljYXRlZHdlYnJ0YzMuYXB0ZXJvLmNvXCIsXG4gICAgICAgICAgICBcImh1Yl9pZFwiOiBcInlVWEQ3QTJcIixcbiAgICAgICAgICAgIFwibG9iYnlfY291bnRcIjogMCxcbiAgICAgICAgICAgIFwibWVtYmVyX2NvdW50XCI6IDAsXG4gICAgICAgICAgICBcIm1lbWJlcl9wZXJtaXNzaW9uc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJmbHlcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInBpbl9vYmplY3RzXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJzcGF3bl9hbmRfbW92ZV9tZWRpYVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwic3Bhd25fY2FtZXJhXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJzcGF3bl9kcmF3aW5nXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJzcGF3bl9lbW9qaVwiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTGlnaHR3ZWlnaHQgRW1wdHkgUm9vbVwiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IFwiNDQzXCIsXG4gICAgICAgICAgICBcInJvb21fc2l6ZVwiOiA1MCxcbiAgICAgICAgICAgIFwic2NlbmVcIjoge1xuICAgICAgICAgICAgICAgIFwiYWNjb3VudF9pZFwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiYWxsb3dfcHJvbW90aW9uXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiYWxsb3dfcmVtaXhpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGlvblwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiYXR0cmlidXRpb25zXCI6IHsgXCJjb250ZW50XCI6IFtdLCBcImNyZWF0b3JcIjogXCJcIiB9LFxuICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcIm1vZGVsX3VybFwiOiBcImh0dHBzOi8vYWxwaGFodWIuYXB0ZXJvLmNvL2ZpbGVzLzU5OGVlZWQzLTA3NjgtNDA4YS1hNzViLWIwZmNiOGU5MDdhZi5iaW5cIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNdXNldW1cIixcbiAgICAgICAgICAgICAgICBcInBhcmVudF9zY2VuZV9pZFwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwicHJvamVjdF9pZFwiOiBcInd3RHlROHRcIixcbiAgICAgICAgICAgICAgICBcInNjZW5lX2lkXCI6IFwiYnI0cFZUMlwiLFxuICAgICAgICAgICAgICAgIFwic2NyZWVuc2hvdF91cmxcIjogXCJodHRwczovL2FscGhhaHViLmFwdGVyby5jby9maWxlcy8zODQ3M2YxMS02MTVmLTQ4N2QtYjIwYi1mM2I2NTU4YWJlYTYuanBnXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2NlbmVcIixcbiAgICAgICAgICAgICAgICBcInVybFwiOiBcImh0dHBzOi8vYWxwaGFodWIuYXB0ZXJvLmNvL3NjZW5lcy9icjRwVlQyL211c2V1bVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzbHVnXCI6IFwibGlnaHR3ZWlnaHQtZW1wdHktcm9vbVwiLFxuICAgICAgICAgICAgXCJ0dXJuXCI6IHtcbiAgICAgICAgICAgICAgICBcImNyZWRlbnRpYWxcIjogXCJDV0JpSVVyb0J4OXg3T0lUYnhNcm01NEhpSnc9XCIsXG4gICAgICAgICAgICAgICAgXCJlbmFibGVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJ0cmFuc3BvcnRzXCI6IFt7IFwicG9ydFwiOiA1MzQ5IH1dLFxuICAgICAgICAgICAgICAgIFwidXNlcm5hbWVcIjogXCIxNjM2MTQwNzM2OmNvdHVyblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ1c2VyX2RhdGFcIjogbnVsbFxuICAgICAgICB9XSxcbiAgICAgICAgXCJwZXJtc190b2tlblwiOiBcImV5SmhiR2NpT2lKU1V6VXhNaUlzSW5SNWNDSTZJa3BYVkNKOS5leUpoWTJOdmRXNTBYMmxrSWpvaU5qUXdOREEzTURVd09UWTJNalk1T1RZeElpd2lZVzF3YkdsbWVWOWhkV1JwYnlJNmRISjFaU3dpWVhWa0lqb2ljbVYwWDNCbGNtMXpJaXdpWTJ4dmMyVmZhSFZpSWpwMGNuVmxMQ0pqY21WaGRHVmZhSFZpSWpwMGNuVmxMQ0psYldKbFpGOW9kV0lpT25SeWRXVXNJbVY0Y0NJNk1UWXpOakUwTURreE5pd2labXg1SWpwMGNuVmxMQ0pvZFdKZmFXUWlPaUo1VlZoRU4wRXlJaXdpYVdGMElqb3hOak0yTVRRd05qRTJMQ0pwYzNNaU9pSWlMQ0pxYjJsdVgyaDFZaUk2ZEhKMVpTd2lhblJwSWpvaVpqaGtOR1UyTURNdE1XRTBOQzAwTVdSbUxUZzVOV010TmpFM1pHVmhZemM1WkRJNElpd2lhMmxqYTE5MWMyVnljeUk2ZEhKMVpTd2liWFYwWlY5MWMyVnljeUk2ZEhKMVpTd2libUptSWpveE5qTTJNVFF3TmpFMUxDSndhVzVmYjJKcVpXTjBjeUk2ZEhKMVpTd2ljRzl6ZEdkeVpYTjBYM0p2YkdVaU9pSnlaWFJmWVdSdGFXNGlMQ0p6Y0dGM2JsOWhibVJmYlc5MlpWOXRaV1JwWVNJNmRISjFaU3dpYzNCaGQyNWZZMkZ0WlhKaElqcDBjblZsTENKemNHRjNibDlrY21GM2FXNW5JanAwY25WbExDSnpjR0YzYmw5bGJXOXFhU0k2ZEhKMVpTd2ljM1ZpSWpvaU5qUXdOREEzTURVd09UWTJNalk1T1RZeFgzbFZXRVEzUVRJaUxDSjBkMlZsZENJNlptRnNjMlVzSW5SNWNDSTZJbUZqWTJWemN5SXNJblZ3WkdGMFpWOW9kV0lpT25SeWRXVXNJblZ3WkdGMFpWOW9kV0pmY0hKdmJXOTBhVzl1SWpwMGNuVmxMQ0oxY0dSaGRHVmZjbTlzWlhNaU9uUnlkV1Y5LnFsTkpsb0tZRG1jMndTVGFLRjFlVllLS1ZfbEN1dXd6ZmRSbnEzSmMtT1A5UDV1aEtpRnpvMWk5TjZySEJDSWZJVEV3cDhmSm91RDdUTk9yQnZwd0ZneFIxSkhUZ09wZ1dUZEQ2bHR4UkdzcGJ0SlJNSlE3cWE2NldUclZ4S3VwNGZJMWFoNzBkRklzSHUyNkdOZFVhYU5wODUwM1ZZdW80MUR6czBYblRUMWJMamJOTTB1Z0pfWmFGX2QyNGIxbV83ZExLZEFuMC1hWmtvVFFTQ2wzd3pOREtMRTkwQjJGSlQ2TWM3aHFlbzhkMG1ocjN5TlFTUnlKNHhMUzBUQkc0ZnZGWlFMNUhfYlJENEZrLXExN2plTUFnSUF2dHF1RWxiczFjWVJuUUZFM2ctUGNzUllZUnNlaldhejRQRUpVbFo1TU01dGJvaE01WG9WSGRSVDhaQVwiLFxuICAgICAgICBcInNlc3Npb25faWRcIjogXCJhM2M3NTBiOC02NDQ2LTRhMWUtYTYzOC1jNTE2MDczZDg4NjFcIixcbiAgICAgICAgXCJzZXNzaW9uX3Rva2VuXCI6IFwiZXlKaGJHY2lPaUpJVXpVeE1pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SmhkV1FpT2lKeVpYUmZjMlZ6YzJsdmJpSXNJbVY0Y0NJNk1UWXpOakl5TnpBeE5pd2lhV0YwSWpveE5qTTJNVFF3TmpFMkxDSnBjM01pT2lJaUxDSnFkR2tpT2lJek5EazRZamc0T0MwMU5qQTBMVFF4WXpjdFlXRm1aQzB4TWpJNU5tVTRZbU5sWVRJaUxDSnVZbVlpT2pFMk16WXhOREEyTVRVc0luTmxjM05wYjI1ZmFXUWlPaUpoTTJNM05UQmlPQzAyTkRRMkxUUmhNV1V0WVRZek9DMWpOVEUyTURjelpEZzROakVpTENKemRXSWlPaUpoTTJNM05UQmlPQzAyTkRRMkxUUmhNV1V0WVRZek9DMWpOVEUyTURjelpEZzROakVpTENKMGVYQWlPaUpoWTJObGMzTWlmUS5FYkV6a2d3Tko4X0g0Zzh2eEZJLWNoOUhwcmJ6TmgxMnhrZmotT3JVT2tVcVRGLWotcUVwc0YtWEZJWm96U2xDVTJjd0pWRDdSTHV4Tk91cURWRjc2Z1wiLFxuICAgICAgICBcInN1YnNjcmlwdGlvbnNcIjogeyBcImZhdm9yaXRlc1wiOiB0cnVlLCBcIndlYl9wdXNoXCI6IG51bGwgfVxuICAgIH0sIFwic3RhdHVzXCI6IFwib2tcIlxufV07XG5cbiAqL1xuIl0sIm5hbWVzIjpbIlNjZW5lTG9hZGVyIiwiY29uc3RydWN0b3IiLCJsb2FkU2NlbmUiLCJzY2VuZVVybCIsInRocmVlTGliIiwic2NlbmUiLCJtZXNoIiwibG9hZEFzc2V0cyIsInRyYXZlcnNlIiwibm9kZSIsImlzTWVzaCIsIm5hbWUiLCJuYXZNZXNoIiwiYWRkIiwiU29ja2V0IiwiY29uZmlncyIsIlJFVElDVUxVTV9TT0NLRVRfU0VSVkVSX1BPUlQiLCJSRVRJQ1VMVU1fU09DS0VUX1NFUlZFUiIsIlJFVElDVUxVTV9TT0NLRVRfUFJPVE9DT0wiLCJjcmVhdGVIdWJDaGFubmVsUGFyYW1zIiwiYXV0aFRva2VuIiwicGVybXNUb2tlbiIsInBhcmFtcyIsInByb2ZpbGUiLCJhdmF0YXJJZCIsImRpc3BsYXlOYW1lIiwicHVzaF9zdWJzY3JpcHRpb25fZW5kcG9pbnQiLCJhdXRoX3Rva2VuIiwicGVybXNfdG9rZW4iLCJib3RfYWNjZXNzX2tleSIsImNvbnRleHQiLCJtb2JpbGUiLCJlbWJlZCIsImh1Yl9pbnZpdGVfaWQiLCJsb2FkIiwiaHViaWQiLCJzb2NrZXQiLCJjb25uZWN0VG9SZXRpY3VsdW0iLCJvbkNsb3NlIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImRhdGEiLCJodWJQaHhDaGFubmVsIiwidmFwaWRkYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZXRDaGFubmVsIiwiY2hhbm5lbCIsImh1Yl9pZCIsImpvaW4iLCJyZWNlaXZlIiwicmVzIiwicmV0aWN1bHVtTWV0YSIsImludmFsaWRhdGVkUmV0aWN1bHVtTWV0YVRoaXNTZXNzaW9uIiwiZGlyZWN0UmV0aWN1bHVtSG9zdEFuZFBvcnQiLCJyZWZyZXNoRGlyZWN0UmV0aWN1bHVtSG9zdEFuZFBvcnQiLCJxcyIsIlVSTFNlYXJjaFBhcmFtcyIsImxvY2F0aW9uIiwic2VhcmNoIiwiaG9zdCIsImdldCIsInBvcnQiLCJpbnZhbGlkYXRlUmV0aWN1bHVtTWV0YSIsImRlYnVnIiwic29ja2V0Q2xhc3MiLCJnZXROZXdTb2NrZXRVcmwiLCJwcm90b2NvbCIsImRvY3VtZW50Iiwic29ja2V0VXJsIiwibG9nIiwic29ja2V0U2V0dGluZ3MiLCJsb2dnZXIiLCJraW5kIiwibXNnIiwiY29ubmVjdCIsIm9uRXJyb3IiLCJlbmRQb2ludFBhdGgiLCJVUkwiLCJlbmRQb2ludCIsInBhdGhuYW1lIiwibmV3U29ja2V0VXJsIiwibmV3RW5kUG9pbnQiLCJnZXRQcmVzZW5jZUVudHJ5Rm9yU2Vzc2lvbiIsInByZXNlbmNlcyIsInNlc3Npb25JZCIsImVudHJ5IiwiT2JqZWN0IiwiZW50cmllcyIsImZpbmQiLCJrIiwicHJlc2VuY2UiLCJtZXRhcyIsImdldFByZXNlbmNlQ29udGV4dEZvclNlc3Npb24iLCJnZXRQcmVzZW5jZVByb2ZpbGVGb3JTZXNzaW9uIiwibWlncmF0ZUJpbmRpbmdzIiwib2xkQ2hhbm5lbCIsIm5ld0NoYW5uZWwiLCJkb05vdER1cGxpY2F0ZSIsInNob3VsZER1cGxpY2F0ZSIsImV2ZW50Iiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwiaSIsImwiLCJiaW5kaW5ncyIsImxlbmd0aCIsIml0ZW0iLCJwdXNoIiwiYmluZGluZ1JlZiIsIm1pZ3JhdGVDaGFubmVsVG9Tb2NrZXQiLCJ0b3BpYyIsInB1c2hCdWZmZXIiLCJwYXlsb2FkIiwidGltZW91dCIsIm9sZEpvaW5QdXNoIiwiam9pblB1c2giLCJyZWNIb29rcyIsInN0YXR1cyIsImNhbGxiYWNrIiwibWlncmF0ZVRvQ2hhbm5lbCIsImxlYXZlIiwiZGlzY29yZEJyaWRnZXNGb3JQcmVzZW5jZXMiLCJjaGFubmVscyIsInAiLCJ2YWx1ZXMiLCJtIiwiZGlzY29yZEJyaWRnZXMiLCJBcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwibWFwIiwiYiIsImhhc0VtYmVkUHJlc2VuY2VzIiwiZGVub2lzZVByZXNlbmNlIiwib25Kb2luIiwib25MZWF2ZSIsIm9uQ2hhbmdlIiwicmF3T25Kb2luIiwia2V5IiwiYmVmb3JlSm9pbiIsImFmdGVySm9pbiIsInVuZGVmaW5lZCIsInJhd09uTGVhdmUiLCJyZW1haW5pbmciLCJyZW1vdmVkIiwicHJlc2VuY2VFdmVudHNGb3JIdWIiLCJldmVudHMiLCJtZXRhIiwidHJpZ2dlciIsInByZXZpb3VzIiwiY3VycmVudCIsIlNlcnZpY2VFbnRpdHkiLCJTcG9rZVJvb21Mb2FkZXIiLCJsb2FkUm9vbSIsInNjZW5lVVJMIiwiaHVicyIsIm1vZGVsX3VybCIsInJlcGxhY2UiLCJzY2VuZUxvYWRlciIsImdldFR5cGUiLCJGYWN0b3J5IiwiY3JlYXRlQ29tcG9uZW50Iiwid29ybGQiLCJjb25maWciLCJzZXJ2aWNlcyIsImdldEZpcnN0Q29tcG9uZW50QnlUeXBlIiwidGhyZWUiLCJnZXRTZXJ2aWNlIiwicGxheWVyU2VydmljZSIsInNwb2tlUm9vbUxvYWRlciIsInJvb20iLCJnZXRDdXJyZW50UGxheWVyIiwiZGVjbGFyZU5hdk1lc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///342\n')}}]);