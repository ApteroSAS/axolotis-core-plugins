{"version":3,"file":"@aptero/axolotis-core-plugins/modules/portals/PortalLink.37c685281b2fb9dccfb6.js","mappings":"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","sources":["webpack://axolotis-core-plugins/./src/lib/modules/portals/PortalLink.ts"],"sourcesContent":["import { ServiceEntity } from \"@aptero/axolotis-player\";\r\nimport { CodeLoaderComponent } from \"@aptero/axolotis-player/build/types/modules/core/loader/CodeLoaderComponent\";\r\nimport { WebpackLazyModule } from \"@aptero/axolotis-player/build/types/modules/core/loader/WebpackLoader\";\r\nimport { WorldEntity } from \"@aptero/axolotis-player/build/types/modules/core/ecs/WorldEntity\";\r\nimport { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\r\nimport { PortalsService } from \"./PortalsService\";\r\nimport { PlayerService } from \"../controller/PlayerService\";\r\nimport { WorldService } from \"@aptero/axolotis-player/build/types/modules/core/WorldService\";\r\nimport { ComponentFactory } from \"@aptero/axolotis-player/build/types/modules/core/ecs/ComponentFactory\";\r\nimport Component from \"@aptero/axolotis-player/build/types/modules/core/ecs/Component\";\r\nimport { initHtmlFromUrl } from \"@aptero/axolotis-player\";\r\nimport {Box3, CircleGeometry, DoubleSide, Mesh, MeshBasicMaterial, PerspectiveCamera, Plane, Vector3} from \"three\";\r\n\r\n//https://barthaweb.com/2020/09/webgl-portal/\r\n//https://github.com/stemkoski/AR-Examples/blob/master/portal-view.html\r\n//https://stemkoski.github.io/AR-Examples/portal-view.html\r\n//https://discourse.threejs.org/t/multiple-scenes-vs-layers/12503/10\r\n\r\n//TODO an iframe per world maybe?\r\n//https://web.dev/origin-agent-cluster/\r\n\r\nexport class Factory\r\n  implements WebpackLazyModule, ComponentFactory<PortalLink>\r\n{\r\n  async createComponent(\r\n    world: WorldEntity,\r\n    config: {\r\n      url: string;\r\n      in: { x: number; y: number; z: number };\r\n      out: { x: number; y: number; z: number };\r\n    }\r\n  ): Promise<PortalLink> {\r\n    let services = world.getFirstComponentByType<ServiceEntity>(\r\n      ServiceEntity.name\r\n    );\r\n    let codeLoader = await services.getService<CodeLoaderComponent>(\r\n      \"@aptero/axolotis-player/modules/core/loader/CodeLoaderService\"\r\n    );\r\n    let three = await services.getService<ThreeLib>(\r\n      \"@aptero/axolotis-core-plugins/modules/three/ThreeLib\"\r\n    );\r\n    let service = await services.getService<PortalsService>(\r\n      \"@aptero/axolotis-core-plugins/modules/portals/PortalsService\"\r\n    );\r\n    let playerService = await services.getService<PlayerService>(\r\n      \"@aptero/axolotis-core-plugins/modules/controller/PlayerService\"\r\n    );\r\n    let worldService = await services.getService<WorldService>(\r\n      \"@aptero/axolotis-player/modules/core/WorldService\"\r\n    );\r\n    let portalLink = new PortalLink(\r\n      service,\r\n      three,\r\n      playerService,\r\n      worldService,\r\n      {\r\n        position: new Vector3(config.in?.x, config.in?.y, config.in?.z),\r\n      },\r\n      {\r\n        position: new Vector3(\r\n          config.out?.x,\r\n          config.out?.y,\r\n          config.out?.z\r\n        ),\r\n      }\r\n    );\r\n    codeLoader.awaitInitialLoading().then(async (value) => {\r\n      let world;\r\n      if (service.worldExist(config.url)) {\r\n        world = service.getWorld(config.url);\r\n      } else {\r\n        world = await initHtmlFromUrl(config.url);\r\n        service.notifylWorld(config.url, world);\r\n      }\r\n      portalLink.setTargetWorld(world);\r\n    });\r\n    return portalLink;\r\n  }\r\n}\r\n\r\nconst invisibleLayer = 31;\r\nconst tmpVisibleLayer = 30;\r\nconst regularLayer = 0;\r\n\r\nexport class PortalLink implements Component {\r\n  private otherCamera: THREE.PerspectiveCamera;\r\n  private portalA: THREE.Mesh<THREE.CircleGeometry, THREE.MeshBasicMaterial>;\r\n  private portalB: THREE.Mesh<THREE.CircleGeometry, THREE.MeshBasicMaterial>;\r\n  private targetWorld: WorldEntity | null = null;\r\n  private targetThreeLib: ThreeLib | null = null;\r\n  private boundingBox: THREE.Box3;\r\n  private targetLink: PortalLink | null = null;\r\n  private portalPlane: THREE.Plane;\r\n  private targetPlayerService: PlayerService | null = null;\r\n\r\n  async setTargetWorld(world: WorldEntity) {\r\n    this.targetWorld = world;\r\n    let targetWorldService =\r\n      await this.targetWorld.getFirstComponentByType<ServiceEntity>(\r\n        ServiceEntity.name\r\n      );\r\n    this.targetThreeLib = await targetWorldService.getService<ThreeLib>(\r\n      \"@aptero/axolotis-core-plugins/modules/three/ThreeLib\"\r\n    );\r\n    this.targetPlayerService =\r\n      await targetWorldService.getService<PlayerService>(\r\n        \"@aptero/axolotis-core-plugins/modules/controller/PlayerService\"\r\n      );\r\n    let otherPortals: PortalLink[] = await world.getComponentByType<PortalLink>(\r\n      PortalLink.name\r\n    );\r\n    if (otherPortals.length === 0) {\r\n      console.error(\"no destination portal present\");\r\n    }\r\n    for (const op of otherPortals) {\r\n      if (op.inPosition.position.equals(this.outPosition.position)) {\r\n        // && op.key === this.key\r\n        this.targetLink = op;\r\n      }\r\n    }\r\n    if (this.targetLink) {\r\n      this.portals.addPortalRenderLoop(() => {\r\n        this.renderPortal();\r\n      });\r\n      this.portals.addPortalLoop((delta) => {\r\n        this.computerPortalEnter();\r\n      });\r\n    } else {\r\n      throw new Error(\"invalid portal init: target portal in wrong state\");\r\n    }\r\n  }\r\n\r\n  constructor(\r\n    private portals: PortalsService,\r\n    private three: ThreeLib,\r\n    private playerService: PlayerService,\r\n    private worldService: WorldService,\r\n    private inPosition: { position: THREE.Vector3; rotation?: THREE.Euler },\r\n    private outPosition: { position: THREE.Vector3; rotation?: THREE.Euler }\r\n  ) {\r\n    this.otherCamera = new PerspectiveCamera(\r\n      three.camera.fov,\r\n      window.innerWidth / window.innerHeight,\r\n      this.three.camera.near,\r\n      this.three.camera.far\r\n    );\r\n    three.scene.add(this.otherCamera);\r\n\r\n    // Portal A (Portal View) ================================\r\n    let defaultMaterial = new MeshBasicMaterial({\r\n      color: 0xff0000,\r\n      side: DoubleSide,\r\n      transparent: true,\r\n    });\r\n\r\n    this.portalA = new Mesh(\r\n      new CircleGeometry(1, 64),\r\n      //new THREE.BoxGeometry( 1, 1, 1 ),\r\n      defaultMaterial.clone()\r\n    );\r\n    this.portalA.material.opacity = 0;\r\n    this.portalA.position.copy(inPosition.position);\r\n    if (inPosition.rotation) {\r\n      this.portalA.setRotationFromEuler(inPosition.rotation);\r\n    }\r\n    this.portalA.layers.set(invisibleLayer); //invisible layer storage\r\n    three.scene.add(this.portalA);\r\n    this.portalA.geometry.computeBoundingBox();\r\n    this.portalPlane = new Plane(new Vector3(0, 0, 1)); //TODO remember to move and oriente the plan to follow the portal\r\n    //const helper = new THREE.PlaneHelper( this.portalPlane, 1, 0xffff00 );\r\n    //this.three.scene.add( helper );\r\n    this.boundingBox = new Box3();\r\n    this.boundingBox.copy(\r\n      this.portalA.geometry.boundingBox || new Box3()\r\n    );\r\n    let minBox = new Box3(\r\n      new Vector3(-0.2, -0.2, -0.2),\r\n      new Vector3(0.2, 0.2, 0.2)\r\n    );\r\n    this.boundingBox = this.boundingBox.union(minBox);\r\n    //const helper = new THREE.Box3Helper( this.boundingBox,0xffff00 as any );\r\n    //this.three.scene.add( helper );\r\n    // Portal B (Point of View position and rotation) ================================\r\n    // material for portals and blockers\r\n    let defaultMaterial2 = new MeshBasicMaterial({\r\n      color: 0xffffff,\r\n      side: DoubleSide,\r\n      transparent: true,\r\n    });\r\n\r\n    this.portalB = new Mesh(\r\n      new CircleGeometry(1, 64),\r\n      defaultMaterial2.clone()\r\n    );\r\n    this.portalB.material.opacity = 0;\r\n    this.portalB.position.copy(outPosition.position);\r\n    if (outPosition.rotation) {\r\n      this.portalB.setRotationFromEuler(outPosition.rotation);\r\n    }\r\n    three.scene.add(this.portalB);\r\n  }\r\n\r\n  tmpPos: THREE.Vector3 = new Vector3();\r\n  tmpDir: THREE.Vector3 = new Vector3();\r\n  tmpBox: THREE.Box3 = new Box3();\r\n  tmpPlane: THREE.Plane = new Plane();\r\n  collidingLastFrame: boolean = false;\r\n  lastDistance: number = 0;\r\n  gracePeriode = 0; //in FPS\r\n\r\n  computerPortalEnter() {\r\n    if (!this.worldService.isActiveWorld()) {\r\n      return;\r\n    }\r\n    if (this.gracePeriode > 0) {\r\n      this.gracePeriode--;\r\n    }\r\n    //compute collision\r\n    this.tmpBox.copy(this.boundingBox);\r\n    this.tmpPlane.copy(this.portalPlane);\r\n    this.tmpBox.applyMatrix4(this.portalA.matrixWorld);\r\n    this.tmpPlane.applyMatrix4(this.portalA.matrixWorld);\r\n    this.playerService.getCurrentPlayer().getHeadPosition(this.tmpPos);\r\n    this.three.camera.getWorldDirection(this.tmpDir);\r\n    //this.tmpPos.add(this.tmpDir.multiplyScalar(0.30));\r\n    const isColliding = this.tmpBox.containsPoint(this.tmpPos);\r\n    if (isColliding) {\r\n      if (this.lastDistance !== 0) {\r\n        // - * + => - / + * - => - => this means we traversed the plan\r\n        if (\r\n          this.tmpPlane.distanceToPoint(this.tmpPos) * this.lastDistance <\r\n          0\r\n        ) {\r\n          //enter\r\n          console.log(\"enter\");\r\n          if (\r\n            this.targetWorld &&\r\n            this.targetLink &&\r\n            this.targetPlayerService &&\r\n            this.gracePeriode == 0\r\n          ) {\r\n            this.targetLink.gracePeriode = 5;\r\n            this.targetLink.collidingLastFrame = true; //sync colliding flag\r\n            this.targetLink.lastDistance = this.lastDistance;\r\n            this.playerService.getCurrentPlayer().getHeadPosition(this.tmpPos); //right head position before teleport\r\n            this.targetPlayerService\r\n              .getCurrentPlayer()\r\n              .teleportToLocation(this.tmpPos.x, this.tmpPos.y, this.tmpPos.z);\r\n            console.log(\"teleport\");\r\n            this.worldService.setActiveWorld(this.targetWorld);\r\n            this.targetPlayerService\r\n              .getCurrentPlayer()\r\n              .teleportToLocation(this.tmpPos.x, this.tmpPos.y, this.tmpPos.z);\r\n          }\r\n        }\r\n      }\r\n      this.lastDistance = this.tmpPlane.distanceToPoint(this.tmpPos);\r\n    } else if (!isColliding && this.lastDistance !== 0) {\r\n      //leave\r\n      this.lastDistance = 0;\r\n      console.log(\"leave\");\r\n    }\r\n    this.collidingLastFrame = isColliding;\r\n  }\r\n\r\n  renderPortal() {\r\n    if (!this.targetThreeLib) {\r\n      return;\r\n    }\r\n    this.portalA.layers.set(tmpVisibleLayer); //Portal to render to layer 1\r\n\r\n    // relatively align other camera with main camera\r\n\r\n    let relativePosition = this.portalA.worldToLocal(\r\n      this.three.camera.position.clone()\r\n    );\r\n    this.otherCamera.position.copy(this.portalB.localToWorld(relativePosition));\r\n\r\n    let relativeRotation = this.three.camera.quaternion\r\n      .clone()\r\n      .multiply(this.portalA.quaternion.clone().invert());\r\n    this.otherCamera.quaternion.copy(\r\n      relativeRotation.multiply(this.portalB.quaternion)\r\n    );\r\n\r\n    // keep camera tilt in sync\r\n    this.otherCamera.rotation.x = this.three.camera.rotation.x;\r\n\r\n    let gl = this.three.renderer.getContext();\r\n\r\n    // FIRST PASS\r\n    // goal: using the stencil buffer, place 1's in position of first portal\r\n\r\n    // enable the stencil buffer\r\n    gl.enable(gl.STENCIL_TEST);\r\n\r\n    // layer 1 contains only the first portal\r\n    this.three.camera.layers.set(tmpVisibleLayer);\r\n\r\n    gl.stencilFunc(gl.ALWAYS, 1, 0xff);\r\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\r\n    gl.stencilMask(0xff);\r\n\r\n    // only write to stencil buffer (not color or depth)\r\n    gl.colorMask(false, false, false, false);\r\n    gl.depthMask(false);\r\n\r\n    this.three.renderer.render(this.three.scene, this.three.camera);\r\n    //this.three.renderer.render( this.targetThreeLib.scene, this.targetThreeLib.camera );\r\n\r\n    // SECOND PASS\r\n    // goal: draw from the portal camera perspective (which is aligned relative to the second portal)\r\n    //   in the first portal region (set by the stencil in the previous pass)\r\n\r\n    // set up a clipping plane, so that portal camera does not see anything between\r\n    //   the portal camera and the second portal\r\n\r\n    // default normal of a plane is 0,0,1. apply mesh rotation to it.\r\n\r\n    // determine which side of the plane camera is on, for clipping plane orientation.\r\n    let portalToCamera = new Vector3().subVectors(\r\n      this.three.camera.position.clone(),\r\n      this.portalA.position.clone()\r\n    ); //  applyQuaternion( mainMover.quaternion );\r\n    let normalPortal = new Vector3(0, 0, 1).applyQuaternion(\r\n      this.portalA.quaternion\r\n    );\r\n    let clipSide = -Math.sign(portalToCamera.dot(normalPortal));\r\n\r\n    let clipNormal = new Vector3(0, 0, clipSide).applyQuaternion(\r\n      this.portalB.quaternion\r\n    );\r\n    let clipPoint = this.portalB.position;\r\n    let clipPlane = new Plane().setFromNormalAndCoplanarPoint(\r\n      clipNormal,\r\n      clipPoint\r\n    );\r\n    this.three.renderer.clippingPlanes = [clipPlane];\r\n\r\n    gl.colorMask(true, true, true, true);\r\n    gl.depthMask(true);\r\n\r\n    gl.stencilFunc(gl.EQUAL, 1, 0xff);\r\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\r\n\r\n    this.otherCamera.layers.set(regularLayer);\r\n    //this.three.renderer.render( this.three.scene, this.otherCamera );//TODO maybe here scene 2\r\n    this.three.renderer.render(this.targetThreeLib.scene, this.otherCamera);\r\n\r\n    // disable clipping planes\r\n    this.three.renderer.clippingPlanes = [];\r\n\r\n    // THIRD PASS\r\n    // goal: set the depth buffer data for the first portal,\r\n    //   so that it can be occluded by other objects\r\n\r\n    // finished with stencil\r\n    gl.disable(gl.STENCIL_TEST);\r\n\r\n    gl.colorMask(false, false, false, false);\r\n    gl.depthMask(true);\r\n    // need to clear the depth buffer, in case of occlusion\r\n    this.three.renderer.render(this.three.scene, this.three.camera);\r\n\r\n    this.three.camera.layers.set(regularLayer); // layer 0 contains everything but portals\r\n    this.portalA.layers.set(invisibleLayer); //Portal to render to layer 1\r\n  }\r\n\r\n  getType(): string {\r\n    return PortalLink.name;\r\n  }\r\n}\r\n"],"names":["Factory","world","config","services","getFirstComponentByType","ServiceEntity","codeLoader","getService","three","service","playerService","worldService","portalLink","PortalLink","position","Vector3","in","x","y","z","out","awaitInitialLoading","then","async","worldExist","url","getWorld","initHtmlFromUrl","notifylWorld","setTargetWorld","this","targetWorld","targetWorldService","targetThreeLib","targetPlayerService","otherPortals","getComponentByType","name","length","console","error","op","inPosition","equals","outPosition","targetLink","Error","portals","addPortalRenderLoop","renderPortal","addPortalLoop","delta","computerPortalEnter","constructor","Box3","Plane","otherCamera","PerspectiveCamera","camera","fov","window","innerWidth","innerHeight","near","far","scene","add","defaultMaterial","MeshBasicMaterial","color","side","DoubleSide","transparent","portalA","Mesh","CircleGeometry","clone","material","opacity","copy","rotation","setRotationFromEuler","layers","set","geometry","computeBoundingBox","portalPlane","boundingBox","minBox","union","defaultMaterial2","portalB","isActiveWorld","gracePeriode","tmpBox","tmpPlane","applyMatrix4","matrixWorld","getCurrentPlayer","getHeadPosition","tmpPos","getWorldDirection","tmpDir","isColliding","containsPoint","lastDistance","distanceToPoint","log","collidingLastFrame","teleportToLocation","setActiveWorld","relativePosition","worldToLocal","localToWorld","relativeRotation","quaternion","multiply","invert","gl","renderer","getContext","enable","STENCIL_TEST","stencilFunc","ALWAYS","stencilOp","KEEP","REPLACE","stencilMask","colorMask","depthMask","render","portalToCamera","subVectors","normalPortal","applyQuaternion","clipSide","Math","sign","dot","clipNormal","clipPoint","clipPlane","setFromNormalAndCoplanarPoint","clippingPlanes","EQUAL","disable","getType"],"sourceRoot":""}