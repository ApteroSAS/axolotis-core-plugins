{"version":3,"file":"@aptero/axolotis-core-plugins/modules/portals/PortalLink.js","mappings":";;;;;;;;;;;6VAqBO,MAAMA,EAGU,sBACnBC,EACAC,GAKqB,gBACrB,IAAIC,EAAWF,EAAMG,wBACnBC,EAAAA,cAAAA,MAEEC,QAAmBH,EAASI,WAC9B,iEAEEC,QAAcL,EAASI,WACzB,wDAEEE,QAAgBN,EAASI,WAC3B,gEAEEG,QAAsBP,EAASI,WACjC,kEAEEI,QAAqBR,EAASI,WAChC,qDAEEK,EAAa,IAAIC,EACnBJ,EACAD,EACAE,EACAC,EACA,CACEG,SAAU,IAAIC,EAAAA,IAAJ,UAAkBb,EAAOc,UAAzB,aAAkB,EAAWC,EAA7B,UAAgCf,EAAOc,UAAvC,aAAgC,EAAWE,EAA3C,UAA8ChB,EAAOc,UAArD,aAA8C,EAAWG,IAErE,CACEL,SAAU,IAAIC,EAAAA,IAAJ,UACRb,EAAOkB,WADC,aACR,EAAYH,EADJ,UAERf,EAAOkB,WAFC,aAER,EAAYF,EAFJ,UAGRhB,EAAOkB,WAHC,aAGR,EAAYD,KAclB,OAVAb,EAAWe,sBAAsBC,MAAKC,MAAAA,IACpC,IAAItB,EACAQ,EAAQe,WAAWtB,EAAOuB,KAC5BxB,EAAQQ,EAAQiB,SAASxB,EAAOuB,MAEhCxB,QAAc0B,EAAAA,EAAAA,iBAAgBzB,EAAOuB,KACrChB,EAAQmB,aAAa1B,EAAOuB,IAAKxB,IAEnCW,EAAWiB,eAAe5B,MAErBW,GAQJ,MAAMC,EAWS,qBAACZ,GACnB6B,KAAKC,YAAc9B,EACnB,IAAI+B,QACIF,KAAKC,YAAY3B,wBACrBC,EAAAA,cAAAA,MAEJyB,KAAKG,qBAAuBD,EAAmBzB,WAC7C,wDAEFuB,KAAKI,0BACGF,EAAmBzB,WACvB,kEAEJ,IAAI4B,QAAmClC,EAAMmC,mBAC3CvB,EAAWwB,MAEe,IAAxBF,EAAaG,QACfC,QAAQC,MAAM,iCAEhB,IAAK,MAAMC,KAAMN,EACXM,EAAGC,WAAW5B,SAAS6B,OAAOb,KAAKc,YAAY9B,YAEjDgB,KAAKe,WAAaJ,GAGtB,IAAIX,KAAKe,WAQP,MAAM,IAAIC,MAAM,qDAPhBhB,KAAKiB,QAAQC,qBAAoB,KAC/BlB,KAAKmB,kBAEPnB,KAAKiB,QAAQG,eAAeC,IAC1BrB,KAAKsB,yBAOXC,YACUN,EACAvC,EACAE,EACAC,EACA+B,EACAE,GACR,KANQG,QAAAA,EAMR,KALQvC,MAAAA,EAKR,KAJQE,cAAAA,EAIR,KAHQC,aAAAA,EAGR,KAFQ+B,WAAAA,EAER,KADQE,YAAAA,EACR,oGAnDwC,MAmDxC,wBAlDwC,MAkDxC,iDAhDsC,MAgDtC,0DA9CkD,MA8ClD,gBA+DsB,IAAI7B,EAAAA,KA/D1B,gBAgEsB,IAAIA,EAAAA,KAhE1B,gBAiEmB,IAAIA,EAAAA,KAjEvB,kBAkEsB,IAAIA,EAAAA,KAlE1B,6BAmE4B,GAnE5B,sBAoEqB,GApErB,sBAqEa,GApEbe,KAAKwB,YAAc,IAAIvC,EAAAA,IACrBP,EAAM+C,OAAOC,IACbC,OAAOC,WAAaD,OAAOE,YAC3B7B,KAAKtB,MAAM+C,OAAOK,KAClB9B,KAAKtB,MAAM+C,OAAOM,KAEpBrD,EAAMsD,MAAMC,IAAIjC,KAAKwB,aAGrB,IAAIU,EAAkB,IAAIjD,EAAAA,IAAwB,CAChDkD,MAAO,SACPC,KAAMnD,EAAAA,IACNoD,aAAa,IAGfrC,KAAKsC,QAAU,IAAIrD,EAAAA,IACjB,IAAIA,EAAAA,IAAqB,EAAG,IAE5BiD,EAAgBK,SAElBvC,KAAKsC,QAAQE,SAASC,QAAU,EAChCzC,KAAKsC,QAAQtD,SAAS0D,KAAK9B,EAAW5B,UAClC4B,EAAW+B,UACb3C,KAAKsC,QAAQM,qBAAqBhC,EAAW+B,UAE/C3C,KAAKsC,QAAQO,OAAOC,IArFD,IAsFnBpE,EAAMsD,MAAMC,IAAIjC,KAAKsC,SACrBtC,KAAKsC,QAAQS,SAASC,qBACtBhD,KAAKiD,YAAc,IAAIhE,EAAAA,IAAY,IAAIA,EAAAA,IAAc,EAAG,EAAG,IAG3De,KAAKkD,YAAc,IAAIjE,EAAAA,IACvBe,KAAKkD,YAAYR,KACf1C,KAAKsC,QAAQS,SAASG,aAAe,IAAIjE,EAAAA,KAE3C,IAAIkE,EAAS,IAAIlE,EAAAA,IACf,IAAIA,EAAAA,KAAe,IAAM,IAAM,IAC/B,IAAIA,EAAAA,IAAc,GAAK,GAAK,KAE9Be,KAAKkD,YAAclD,KAAKkD,YAAYE,MAAMD,GAK1C,IAAIE,EAAmB,IAAIpE,EAAAA,IAAwB,CACjDkD,MAAO,SACPC,KAAMnD,EAAAA,IACNoD,aAAa,IAGfrC,KAAKsD,QAAU,IAAIrE,EAAAA,IACjB,IAAIA,EAAAA,IAAqB,EAAG,IAC5BoE,EAAiBd,SAEnBvC,KAAKsD,QAAQd,SAASC,QAAU,EAChCzC,KAAKsD,QAAQtE,SAAS0D,KAAK5B,EAAY9B,UACnC8B,EAAY6B,UACd3C,KAAKsD,QAAQV,qBAAqB9B,EAAY6B,UAEhDjE,EAAMsD,MAAMC,IAAIjC,KAAKsD,SAWvBhC,sBACE,IAAKtB,KAAKnB,aAAa0E,gBACrB,OAEEvD,KAAKwD,aAAe,GACtBxD,KAAKwD,eAGPxD,KAAKyD,OAAOf,KAAK1C,KAAKkD,aACtBlD,KAAK0D,SAAShB,KAAK1C,KAAKiD,aACxBjD,KAAKyD,OAAOE,aAAa3D,KAAKsC,QAAQsB,aACtC5D,KAAK0D,SAASC,aAAa3D,KAAKsC,QAAQsB,aACxC5D,KAAKpB,cAAciF,mBAAmBC,gBAAgB9D,KAAK+D,QAC3D/D,KAAKtB,MAAM+C,OAAOuC,kBAAkBhE,KAAKiE,QAEzC,MAAMC,EAAclE,KAAKyD,OAAOU,cAAcnE,KAAK+D,QAC/CG,GACwB,IAAtBlE,KAAKoE,cAGLpE,KAAK0D,SAASW,gBAAgBrE,KAAK+D,QAAU/D,KAAKoE,aAClD,IAGA3D,QAAQ6D,IAAI,SAEVtE,KAAKC,aACLD,KAAKe,YACLf,KAAKI,qBACgB,GAArBJ,KAAKwD,eAELxD,KAAKe,WAAWyC,aAAe,EAC/BxD,KAAKe,WAAWwD,oBAAqB,EACrCvE,KAAKe,WAAWqD,aAAepE,KAAKoE,aACpCpE,KAAKpB,cAAciF,mBAAmBC,gBAAgB9D,KAAK+D,QAC3D/D,KAAKI,oBACFyD,mBACAW,mBAAmBxE,KAAK+D,OAAO5E,EAAGa,KAAK+D,OAAO3E,EAAGY,KAAK+D,OAAO1E,GAChEoB,QAAQ6D,IAAI,YACZtE,KAAKnB,aAAa4F,eAAezE,KAAKC,aACtCD,KAAKI,oBACFyD,mBACAW,mBAAmBxE,KAAK+D,OAAO5E,EAAGa,KAAK+D,OAAO3E,EAAGY,KAAK+D,OAAO1E,KAItEW,KAAKoE,aAAepE,KAAK0D,SAASW,gBAAgBrE,KAAK+D,SAC7CG,GAAqC,IAAtBlE,KAAKoE,eAE9BpE,KAAKoE,aAAe,EACpB3D,QAAQ6D,IAAI,UAEdtE,KAAKuE,mBAAqBL,EAG5B/C,eACE,IAAKnB,KAAKG,eACR,OAEFH,KAAKsC,QAAQO,OAAOC,IA5LA,IAgMpB,IAAI4B,EAAmB1E,KAAKsC,QAAQqC,aAClC3E,KAAKtB,MAAM+C,OAAOzC,SAASuD,SAE7BvC,KAAKwB,YAAYxC,SAAS0D,KAAK1C,KAAKsD,QAAQsB,aAAaF,IAEzD,IAAIG,EAAmB7E,KAAKtB,MAAM+C,OAAOqD,WACtCvC,QACAwC,SAAS/E,KAAKsC,QAAQwC,WAAWvC,QAAQyC,UAC5ChF,KAAKwB,YAAYsD,WAAWpC,KAC1BmC,EAAiBE,SAAS/E,KAAKsD,QAAQwB,aAIzC9E,KAAKwB,YAAYmB,SAASxD,EAAIa,KAAKtB,MAAM+C,OAAOkB,SAASxD,EAEzD,IAAI8F,EAAKjF,KAAKtB,MAAMwG,SAASC,aAM7BF,EAAGG,OAAOH,EAAGI,cAGbrF,KAAKtB,MAAM+C,OAAOoB,OAAOC,IAxNL,IA0NpBmC,EAAGK,YAAYL,EAAGM,OAAQ,EAAG,KAC7BN,EAAGO,UAAUP,EAAGQ,KAAMR,EAAGQ,KAAMR,EAAGS,SAClCT,EAAGU,YAAY,KAGfV,EAAGW,WAAU,GAAO,GAAO,GAAO,GAClCX,EAAGY,WAAU,GAEb7F,KAAKtB,MAAMwG,SAASY,OAAO9F,KAAKtB,MAAMsD,MAAOhC,KAAKtB,MAAM+C,QAaxD,IAAIsE,GAAiB,IAAI9G,EAAAA,KAAgB+G,WACvChG,KAAKtB,MAAM+C,OAAOzC,SAASuD,QAC3BvC,KAAKsC,QAAQtD,SAASuD,SAEpB0D,EAAe,IAAIhH,EAAAA,IAAc,EAAG,EAAG,GAAGiH,gBAC5ClG,KAAKsC,QAAQwC,YAEXqB,GAAYC,KAAKC,KAAKN,EAAeO,IAAIL,IAEzCM,EAAa,IAAItH,EAAAA,IAAc,EAAG,EAAGkH,GAAUD,gBACjDlG,KAAKsD,QAAQwB,YAEX0B,EAAYxG,KAAKsD,QAAQtE,SACzByH,GAAY,IAAIxH,EAAAA,KAAcyH,8BAChCH,EACAC,GAEFxG,KAAKtB,MAAMwG,SAASyB,eAAiB,CAACF,GAEtCxB,EAAGW,WAAU,GAAM,GAAM,GAAM,GAC/BX,EAAGY,WAAU,GAEbZ,EAAGK,YAAYL,EAAG2B,MAAO,EAAG,KAC5B3B,EAAGO,UAAUP,EAAGQ,KAAMR,EAAGQ,KAAMR,EAAGQ,MAElCzF,KAAKwB,YAAYqB,OAAOC,IAvQP,GAyQjB9C,KAAKtB,MAAMwG,SAASY,OAAO9F,KAAKG,eAAe6B,MAAOhC,KAAKwB,aAG3DxB,KAAKtB,MAAMwG,SAASyB,eAAiB,GAOrC1B,EAAG4B,QAAQ5B,EAAGI,cAEdJ,EAAGW,WAAU,GAAO,GAAO,GAAO,GAClCX,EAAGY,WAAU,GAEb7F,KAAKtB,MAAMwG,SAASY,OAAO9F,KAAKtB,MAAMsD,MAAOhC,KAAKtB,MAAM+C,QAExDzB,KAAKtB,MAAM+C,OAAOoB,OAAOC,IA1RR,GA2RjB9C,KAAKsC,QAAQO,OAAOC,IA7RD,IAgSrBgE,UACE,OAAO/H,EAAWwB","sources":["webpack://axolotis-core-plugins/./src/lib/modules/portals/PortalLink.ts"],"sourcesContent":["import { ServiceEntity } from \"@aptero/axolotis-player\";\nimport { CodeLoaderComponent } from \"@aptero/axolotis-player/build/types/modules/core/loader/CodeLoaderComponent\";\nimport * as THREE from \"three\";\nimport { WebpackLazyModule } from \"@aptero/axolotis-player/build/types/modules/core/loader/WebpackLoader\";\nimport { WorldEntity } from \"@aptero/axolotis-player/build/types/modules/core/ecs/WorldEntity\";\nimport { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\nimport { PortalsService } from \"./PortalsService\";\nimport { PlayerService } from \"../controller/PlayerService\";\nimport { WorldService } from \"@aptero/axolotis-player/build/types/modules/core/WorldService\";\nimport { ComponentFactory } from \"@aptero/axolotis-player/build/types/modules/core/ecs/ComponentFactory\";\nimport Component from \"@aptero/axolotis-player/build/types/modules/core/ecs/Component\";\nimport { initHtmlFromUrl } from \"@aptero/axolotis-player\";\n\n//https://barthaweb.com/2020/09/webgl-portal/\n//https://github.com/stemkoski/AR-Examples/blob/master/portal-view.html\n//https://stemkoski.github.io/AR-Examples/portal-view.html\n//https://discourse.threejs.org/t/multiple-scenes-vs-layers/12503/10\n\n//TODO an iframe per world maybe?\n//https://web.dev/origin-agent-cluster/\n\nexport class Factory\n  implements WebpackLazyModule, ComponentFactory<PortalLink>\n{\n  async createComponent(\n    world: WorldEntity,\n    config: {\n      url: string;\n      in: { x: number; y: number; z: number };\n      out: { x: number; y: number; z: number };\n    }\n  ): Promise<PortalLink> {\n    let services = world.getFirstComponentByType<ServiceEntity>(\n      ServiceEntity.name\n    );\n    let codeLoader = await services.getService<CodeLoaderComponent>(\n      \"@aptero/axolotis-player/modules/core/loader/CodeLoaderService\"\n    );\n    let three = await services.getService<ThreeLib>(\n      \"@aptero/axolotis-core-plugins/modules/three/ThreeLib\"\n    );\n    let service = await services.getService<PortalsService>(\n      \"@aptero/axolotis-core-plugins/modules/portals/PortalsService\"\n    );\n    let playerService = await services.getService<PlayerService>(\n      \"@aptero/axolotis-core-plugins/modules/controller/PlayerService\"\n    );\n    let worldService = await services.getService<WorldService>(\n      \"@aptero/axolotis-player/modules/core/WorldService\"\n    );\n    let portalLink = new PortalLink(\n      service,\n      three,\n      playerService,\n      worldService,\n      {\n        position: new THREE.Vector3(config.in?.x, config.in?.y, config.in?.z),\n      },\n      {\n        position: new THREE.Vector3(\n          config.out?.x,\n          config.out?.y,\n          config.out?.z\n        ),\n      }\n    );\n    codeLoader.awaitInitialLoading().then(async (value) => {\n      let world;\n      if (service.worldExist(config.url)) {\n        world = service.getWorld(config.url);\n      } else {\n        world = await initHtmlFromUrl(config.url);\n        service.notifylWorld(config.url, world);\n      }\n      portalLink.setTargetWorld(world);\n    });\n    return portalLink;\n  }\n}\n\nconst invisibleLayer = 31;\nconst tmpVisibleLayer = 30;\nconst regularLayer = 0;\n\nexport class PortalLink implements Component {\n  private otherCamera: THREE.PerspectiveCamera;\n  private portalA: THREE.Mesh<THREE.CircleGeometry, THREE.MeshBasicMaterial>;\n  private portalB: THREE.Mesh<THREE.CircleGeometry, THREE.MeshBasicMaterial>;\n  private targetWorld: WorldEntity | null = null;\n  private targetThreeLib: ThreeLib | null = null;\n  private boundingBox: THREE.Box3;\n  private targetLink: PortalLink | null = null;\n  private portalPlane: THREE.Plane;\n  private targetPlayerService: PlayerService | null = null;\n\n  async setTargetWorld(world: WorldEntity) {\n    this.targetWorld = world;\n    let targetWorldService =\n      await this.targetWorld.getFirstComponentByType<ServiceEntity>(\n        ServiceEntity.name\n      );\n    this.targetThreeLib = await targetWorldService.getService<ThreeLib>(\n      \"@aptero/axolotis-core-plugins/modules/three/ThreeLib\"\n    );\n    this.targetPlayerService =\n      await targetWorldService.getService<PlayerService>(\n        \"@aptero/axolotis-core-plugins/modules/controller/PlayerService\"\n      );\n    let otherPortals: PortalLink[] = await world.getComponentByType<PortalLink>(\n      PortalLink.name\n    );\n    if (otherPortals.length === 0) {\n      console.error(\"no destination portal present\");\n    }\n    for (const op of otherPortals) {\n      if (op.inPosition.position.equals(this.outPosition.position)) {\n        // && op.key === this.key\n        this.targetLink = op;\n      }\n    }\n    if (this.targetLink) {\n      this.portals.addPortalRenderLoop(() => {\n        this.renderPortal();\n      });\n      this.portals.addPortalLoop((delta) => {\n        this.computerPortalEnter();\n      });\n    } else {\n      throw new Error(\"invalid portal init: target portal in wrong state\");\n    }\n  }\n\n  constructor(\n    private portals: PortalsService,\n    private three: ThreeLib,\n    private playerService: PlayerService,\n    private worldService: WorldService,\n    private inPosition: { position: THREE.Vector3; rotation?: THREE.Euler },\n    private outPosition: { position: THREE.Vector3; rotation?: THREE.Euler }\n  ) {\n    this.otherCamera = new THREE.PerspectiveCamera(\n      three.camera.fov,\n      window.innerWidth / window.innerHeight,\n      this.three.camera.near,\n      this.three.camera.far\n    );\n    three.scene.add(this.otherCamera);\n\n    // Portal A (Portal View) ================================\n    let defaultMaterial = new THREE.MeshBasicMaterial({\n      color: 0xff0000,\n      side: THREE.DoubleSide,\n      transparent: true,\n    });\n\n    this.portalA = new THREE.Mesh(\n      new THREE.CircleGeometry(1, 64),\n      //new THREE.BoxGeometry( 1, 1, 1 ),\n      defaultMaterial.clone()\n    );\n    this.portalA.material.opacity = 0;\n    this.portalA.position.copy(inPosition.position);\n    if (inPosition.rotation) {\n      this.portalA.setRotationFromEuler(inPosition.rotation);\n    }\n    this.portalA.layers.set(invisibleLayer); //invisible layer storage\n    three.scene.add(this.portalA);\n    this.portalA.geometry.computeBoundingBox();\n    this.portalPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1)); //TODO remember to move and oriente the plan to follow the portal\n    //const helper = new THREE.PlaneHelper( this.portalPlane, 1, 0xffff00 );\n    //this.three.scene.add( helper );\n    this.boundingBox = new THREE.Box3();\n    this.boundingBox.copy(\n      this.portalA.geometry.boundingBox || new THREE.Box3()\n    );\n    let minBox = new THREE.Box3(\n      new THREE.Vector3(-0.2, -0.2, -0.2),\n      new THREE.Vector3(0.2, 0.2, 0.2)\n    );\n    this.boundingBox = this.boundingBox.union(minBox);\n    //const helper = new THREE.Box3Helper( this.boundingBox,0xffff00 as any );\n    //this.three.scene.add( helper );\n    // Portal B (Point of View position and rotation) ================================\n    // material for portals and blockers\n    let defaultMaterial2 = new THREE.MeshBasicMaterial({\n      color: 0xffffff,\n      side: THREE.DoubleSide,\n      transparent: true,\n    });\n\n    this.portalB = new THREE.Mesh(\n      new THREE.CircleGeometry(1, 64),\n      defaultMaterial2.clone()\n    );\n    this.portalB.material.opacity = 0;\n    this.portalB.position.copy(outPosition.position);\n    if (outPosition.rotation) {\n      this.portalB.setRotationFromEuler(outPosition.rotation);\n    }\n    three.scene.add(this.portalB);\n  }\n\n  tmpPos: THREE.Vector3 = new THREE.Vector3();\n  tmpDir: THREE.Vector3 = new THREE.Vector3();\n  tmpBox: THREE.Box3 = new THREE.Box3();\n  tmpPlane: THREE.Plane = new THREE.Plane();\n  collidingLastFrame: boolean = false;\n  lastDistance: number = 0;\n  gracePeriode = 0; //in FPS\n\n  computerPortalEnter() {\n    if (!this.worldService.isActiveWorld()) {\n      return;\n    }\n    if (this.gracePeriode > 0) {\n      this.gracePeriode--;\n    }\n    //compute collision\n    this.tmpBox.copy(this.boundingBox);\n    this.tmpPlane.copy(this.portalPlane);\n    this.tmpBox.applyMatrix4(this.portalA.matrixWorld);\n    this.tmpPlane.applyMatrix4(this.portalA.matrixWorld);\n    this.playerService.getCurrentPlayer().getHeadPosition(this.tmpPos);\n    this.three.camera.getWorldDirection(this.tmpDir);\n    //this.tmpPos.add(this.tmpDir.multiplyScalar(0.30));\n    const isColliding = this.tmpBox.containsPoint(this.tmpPos);\n    if (isColliding) {\n      if (this.lastDistance !== 0) {\n        // - * + => - / + * - => - => this means we traversed the plan\n        if (\n          this.tmpPlane.distanceToPoint(this.tmpPos) * this.lastDistance <\n          0\n        ) {\n          //enter\n          console.log(\"enter\");\n          if (\n            this.targetWorld &&\n            this.targetLink &&\n            this.targetPlayerService &&\n            this.gracePeriode == 0\n          ) {\n            this.targetLink.gracePeriode = 5;\n            this.targetLink.collidingLastFrame = true; //sync colliding flag\n            this.targetLink.lastDistance = this.lastDistance;\n            this.playerService.getCurrentPlayer().getHeadPosition(this.tmpPos); //right head position before teleport\n            this.targetPlayerService\n              .getCurrentPlayer()\n              .teleportToLocation(this.tmpPos.x, this.tmpPos.y, this.tmpPos.z);\n            console.log(\"teleport\");\n            this.worldService.setActiveWorld(this.targetWorld);\n            this.targetPlayerService\n              .getCurrentPlayer()\n              .teleportToLocation(this.tmpPos.x, this.tmpPos.y, this.tmpPos.z);\n          }\n        }\n      }\n      this.lastDistance = this.tmpPlane.distanceToPoint(this.tmpPos);\n    } else if (!isColliding && this.lastDistance !== 0) {\n      //leave\n      this.lastDistance = 0;\n      console.log(\"leave\");\n    }\n    this.collidingLastFrame = isColliding;\n  }\n\n  renderPortal() {\n    if (!this.targetThreeLib) {\n      return;\n    }\n    this.portalA.layers.set(tmpVisibleLayer); //Portal to render to layer 1\n\n    // relatively align other camera with main camera\n\n    let relativePosition = this.portalA.worldToLocal(\n      this.three.camera.position.clone()\n    );\n    this.otherCamera.position.copy(this.portalB.localToWorld(relativePosition));\n\n    let relativeRotation = this.three.camera.quaternion\n      .clone()\n      .multiply(this.portalA.quaternion.clone().invert());\n    this.otherCamera.quaternion.copy(\n      relativeRotation.multiply(this.portalB.quaternion)\n    );\n\n    // keep camera tilt in sync\n    this.otherCamera.rotation.x = this.three.camera.rotation.x;\n\n    let gl = this.three.renderer.getContext();\n\n    // FIRST PASS\n    // goal: using the stencil buffer, place 1's in position of first portal\n\n    // enable the stencil buffer\n    gl.enable(gl.STENCIL_TEST);\n\n    // layer 1 contains only the first portal\n    this.three.camera.layers.set(tmpVisibleLayer);\n\n    gl.stencilFunc(gl.ALWAYS, 1, 0xff);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n    gl.stencilMask(0xff);\n\n    // only write to stencil buffer (not color or depth)\n    gl.colorMask(false, false, false, false);\n    gl.depthMask(false);\n\n    this.three.renderer.render(this.three.scene, this.three.camera);\n    //this.three.renderer.render( this.targetThreeLib.scene, this.targetThreeLib.camera );\n\n    // SECOND PASS\n    // goal: draw from the portal camera perspective (which is aligned relative to the second portal)\n    //   in the first portal region (set by the stencil in the previous pass)\n\n    // set up a clipping plane, so that portal camera does not see anything between\n    //   the portal camera and the second portal\n\n    // default normal of a plane is 0,0,1. apply mesh rotation to it.\n\n    // determine which side of the plane camera is on, for clipping plane orientation.\n    let portalToCamera = new THREE.Vector3().subVectors(\n      this.three.camera.position.clone(),\n      this.portalA.position.clone()\n    ); //  applyQuaternion( mainMover.quaternion );\n    let normalPortal = new THREE.Vector3(0, 0, 1).applyQuaternion(\n      this.portalA.quaternion\n    );\n    let clipSide = -Math.sign(portalToCamera.dot(normalPortal));\n\n    let clipNormal = new THREE.Vector3(0, 0, clipSide).applyQuaternion(\n      this.portalB.quaternion\n    );\n    let clipPoint = this.portalB.position;\n    let clipPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(\n      clipNormal,\n      clipPoint\n    );\n    this.three.renderer.clippingPlanes = [clipPlane];\n\n    gl.colorMask(true, true, true, true);\n    gl.depthMask(true);\n\n    gl.stencilFunc(gl.EQUAL, 1, 0xff);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\n    this.otherCamera.layers.set(regularLayer);\n    //this.three.renderer.render( this.three.scene, this.otherCamera );//TODO maybe here scene 2\n    this.three.renderer.render(this.targetThreeLib.scene, this.otherCamera);\n\n    // disable clipping planes\n    this.three.renderer.clippingPlanes = [];\n\n    // THIRD PASS\n    // goal: set the depth buffer data for the first portal,\n    //   so that it can be occluded by other objects\n\n    // finished with stencil\n    gl.disable(gl.STENCIL_TEST);\n\n    gl.colorMask(false, false, false, false);\n    gl.depthMask(true);\n    // need to clear the depth buffer, in case of occlusion\n    this.three.renderer.render(this.three.scene, this.three.camera);\n\n    this.three.camera.layers.set(regularLayer); // layer 0 contains everything but portals\n    this.portalA.layers.set(invisibleLayer); //Portal to render to layer 1\n  }\n\n  getType(): string {\n    return PortalLink.name;\n  }\n}\n"],"names":["Factory","world","config","services","getFirstComponentByType","ServiceEntity","codeLoader","getService","three","service","playerService","worldService","portalLink","PortalLink","position","THREE","in","x","y","z","out","awaitInitialLoading","then","async","worldExist","url","getWorld","initHtmlFromUrl","notifylWorld","setTargetWorld","this","targetWorld","targetWorldService","targetThreeLib","targetPlayerService","otherPortals","getComponentByType","name","length","console","error","op","inPosition","equals","outPosition","targetLink","Error","portals","addPortalRenderLoop","renderPortal","addPortalLoop","delta","computerPortalEnter","constructor","otherCamera","camera","fov","window","innerWidth","innerHeight","near","far","scene","add","defaultMaterial","color","side","transparent","portalA","clone","material","opacity","copy","rotation","setRotationFromEuler","layers","set","geometry","computeBoundingBox","portalPlane","boundingBox","minBox","union","defaultMaterial2","portalB","isActiveWorld","gracePeriode","tmpBox","tmpPlane","applyMatrix4","matrixWorld","getCurrentPlayer","getHeadPosition","tmpPos","getWorldDirection","tmpDir","isColliding","containsPoint","lastDistance","distanceToPoint","log","collidingLastFrame","teleportToLocation","setActiveWorld","relativePosition","worldToLocal","localToWorld","relativeRotation","quaternion","multiply","invert","gl","renderer","getContext","enable","STENCIL_TEST","stencilFunc","ALWAYS","stencilOp","KEEP","REPLACE","stencilMask","colorMask","depthMask","render","portalToCamera","subVectors","normalPortal","applyQuaternion","clipSide","Math","sign","dot","clipNormal","clipPoint","clipPlane","setFromNormalAndCoplanarPoint","clippingPlanes","EQUAL","disable","getType"],"sourceRoot":""}