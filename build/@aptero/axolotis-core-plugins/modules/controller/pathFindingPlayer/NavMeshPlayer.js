/*!
 * 
 *   @aptero/axolotis-core-plugins v1.0.0
 *   https://github.com/ApteroSAS/axolotis-player
 *
 *   Copyright (c) Aptero (https://github.com/ApteroSAS/axolotis-player) and project contributors.
 *
 *   This source code is licensed under the MIT license found in the
 *   LICENSE file in the root directory of this source tree.
 *
 */
"use strict";(self.webpackChunkaxolotis_core_plugins=self.webpackChunkaxolotis_core_plugins||[]).push([[625],{7:function(t,e,s){s.r(e),s.d(e,{Factory:function(){return p},default:function(){return d}});var i=s(212),o=s(919);class n{static roundNumber(t,e){const s=Math.pow(10,e);return Math.round(t*s)/s}static sample(t){return t[Math.floor(Math.random()*t.length)]}static distanceToSquared(t,e){var s=t.x-e.x,i=t.y-e.y,o=t.z-e.z;return s*s+i*i+o*o}static isPointInPoly(t,e){for(var s=!1,i=-1,o=t.length,n=o-1;++i<o;n=i)(t[i].z<=e.z&&e.z<t[n].z||t[n].z<=e.z&&e.z<t[i].z)&&e.x<(t[n].x-t[i].x)*(e.z-t[i].z)/(t[n].z-t[i].z)+t[i].x&&(s=!s);return s}static isVectorInPolygon(t,e,s){var i=1e5,o=-1e5,n=[];return e.vertexIds.forEach((t=>{i=Math.min(s[t].y,i),o=Math.max(s[t].y,o),n.push(s[t])})),!!(t.y<o+.5&&t.y>i-.5&&this.isPointInPoly(n,t))}static triarea2(t,e,s){return(s.x-t.x)*(e.z-t.z)-(e.x-t.x)*(s.z-t.z)}static vequal(t,e){return this.distanceToSquared(t,e)<1e-5}static mergeVertices(t,e=1e-4){e=Math.max(e,Number.EPSILON);for(var s={},o=t.getIndex(),n=t.getAttribute("position"),r=o?o.count:n.count,h=0,a=[],c=[],u=Math.log10(1/e),l=Math.pow(10,u),p=0;p<r;p++){var d=o?o.getX(p):p,v="";v+=~~(n.getX(d)*l)+",",v+=~~(n.getY(d)*l)+",",(v+=~~(n.getZ(d)*l)+",")in s?a.push(s[v]):(c.push(n.getX(d)),c.push(n.getY(d)),c.push(n.getZ(d)),s[v]=h,a.push(h),h++)}const g=new i.TlE(new Float32Array(c),n.itemSize,n.normalized),m=new i.u9r;return m.setAttribute("position",g),m.setIndex(a),m}}class r{constructor(t){this.content=[],this.scoreFunction=t}push(t){this.content.push(t),this.sinkDown(this.content.length-1)}pop(){const t=this.content[0],e=this.content.pop();return this.content.length>0&&(this.content[0]=e,this.bubbleUp(0)),t}remove(t){const e=this.content.indexOf(t),s=this.content.pop();e!==this.content.length-1&&(this.content[e]=s,this.scoreFunction(s)<this.scoreFunction(t)?this.sinkDown(e):this.bubbleUp(e))}size(){return this.content.length}rescoreElement(t){this.sinkDown(this.content.indexOf(t))}sinkDown(t){const e=this.content[t];for(;t>0;){const s=(t+1>>1)-1,i=this.content[s];if(!(this.scoreFunction(e)<this.scoreFunction(i)))break;this.content[s]=e,this.content[t]=i,t=s}}bubbleUp(t){const e=this.content.length,s=this.content[t],i=this.scoreFunction(s);for(;;){const o=t+1<<1,n=o-1;let r,h=null;if(n<e&&(r=this.scoreFunction(this.content[n]),r<i&&(h=n)),o<e&&this.scoreFunction(this.content[o])<(null===h?i:r)&&(h=o),null===h)break;this.content[t]=this.content[h],this.content[h]=s,t=h}}}class h{constructor(){this.portals=[]}push(t,e){void 0===e&&(e=t),this.portals.push({left:t,right:e})}stringPull(){const t=this.portals,e=[];let s,i,o,r=0,h=0,a=0;s=t[0].left,i=t[0].left,o=t[0].right,e.push(s);for(let c=1;c<t.length;c++){const u=t[c].left,l=t[c].right;if(n.triarea2(s,o,l)<=0){if(!(n.vequal(s,o)||n.triarea2(s,i,l)>0)){e.push(i),s=i,r=h,i=s,o=s,h=r,a=r,c=r;continue}o=l,a=c}if(n.triarea2(s,i,u)>=0){if(!(n.vequal(s,i)||n.triarea2(s,o,u)<0)){e.push(o),s=o,r=a,i=s,o=s,h=r,a=r,c=r;continue}i=u,h=c}}return 0!==e.length&&n.vequal(e[e.length-1],t[t.length-1].left)||e.push(t[t.length-1].left),this.path=e,e}}class a{constructor(){this.zones={}}static createZone(t,e=1e-4){return class{static buildZone(t,e){const s=this._buildNavigationMesh(t,e),o={};s.vertices.forEach((t=>{t.x=n.roundNumber(t.x,2),t.y=n.roundNumber(t.y,2),t.z=n.roundNumber(t.z,2)})),o.vertices=s.vertices;const r=this._buildPolygonGroups(s);return o.groups=new Array(r.length),r.forEach(((t,e)=>{const s=new Map;t.forEach(((t,e)=>{s.set(t,e)}));const r=new Array(t.length);t.forEach(((t,e)=>{const h=[];t.neighbours.forEach((t=>h.push(s.get(t))));const a=[];t.neighbours.forEach((e=>a.push(this._getSharedVerticesInOrder(t,e))));const c=new i.Pa4(0,0,0);c.add(o.vertices[t.vertexIds[0]]),c.add(o.vertices[t.vertexIds[1]]),c.add(o.vertices[t.vertexIds[2]]),c.divideScalar(3),c.x=n.roundNumber(c.x,2),c.y=n.roundNumber(c.y,2),c.z=n.roundNumber(c.z,2),r[e]={id:e,neighbours:h,vertexIds:t.vertexIds,centroid:c,portals:a}})),o.groups[e]=r})),o}static _buildNavigationMesh(t,e){return t=n.mergeVertices(t,e),this._buildPolygonsFromGeometry(t)}static _spreadGroupId(t){let e=new Set([t]);for(;e.size>0;){const s=e;e=new Set,s.forEach((s=>{s.group=t.group,s.neighbours.forEach((t=>{void 0===t.group&&e.add(t)}))}))}}static _buildPolygonGroups(t){const e=[];return t.polygons.forEach((t=>{void 0!==t.group?e[t.group].push(t):(t.group=e.length,this._spreadGroupId(t),e.push([t]))})),e}static _buildPolygonNeighbours(t,e){const s=new Set,i=e[t.vertexIds[1]],o=e[t.vertexIds[2]];return e[t.vertexIds[0]].forEach((e=>{e!==t&&(i.includes(e)||o.includes(e))&&s.add(e)})),i.forEach((e=>{e!==t&&o.includes(e)&&s.add(e)})),s}static _buildPolygonsFromGeometry(t){const e=[],s=[],o=t.attributes.position,n=t.index,r=[];for(let t=0;t<o.count;t++)s.push((new i.Pa4).fromBufferAttribute(o,t)),r[t]=[];for(let s=0;s<t.index.count;s+=3){const t=n.getX(s),i=n.getX(s+1),o=n.getX(s+2),h={vertexIds:[t,i,o],neighbours:null};e.push(h),r[t].push(h),r[i].push(h),r[o].push(h)}return e.forEach((t=>{t.neighbours=this._buildPolygonNeighbours(t,r)})),{polygons:e,vertices:s}}static _getSharedVerticesInOrder(t,e){const s=t.vertexIds,i=s[0],o=s[1],n=s[2],r=e.vertexIds,h=r.includes(i),a=r.includes(o),c=r.includes(n);return h&&a&&c?Array.from(s):h&&a?[i,o]:a&&c?[o,n]:h&&c?[n,i]:(console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."),[])}}.buildZone(t,e)}setZoneData(t,e){this.zones[t]=e}getRandomNode(t,e,s,o){if(!this.zones[t])return new i.Pa4;s=s||null,o=o||0;const r=[];return this.zones[t].groups[e].forEach((t=>{s&&o?n.distanceToSquared(s,t.centroid)<o*o&&r.push(t.centroid):r.push(t.centroid)})),n.sample(r)||new i.Pa4}getClosestNode(t,e,s,i=!1){const o=this.zones[e].vertices;let r=null,h=1/0;return this.zones[e].groups[s].forEach((e=>{const s=n.distanceToSquared(e.centroid,t);s<h&&(!i||n.isVectorInPolygon(t,e,o))&&(r=e,h=s)})),r}findPath(t,e,s,o){const a=this.zones[s].groups[o],c=this.zones[s].vertices,u=this.getClosestNode(t,s,o,!0),l=this.getClosestNode(e,s,o,!0);if(!u||!l)return null;const p=class{static init(t){for(let e=0;e<t.length;e++){const s=t[e];s.f=0,s.g=0,s.h=0,s.cost=1,s.visited=!1,s.closed=!1,s.parent=null}}static cleanUp(t){for(let e=0;e<t.length;e++){const s=t[e];delete s.f,delete s.g,delete s.h,delete s.cost,delete s.visited,delete s.closed,delete s.parent}}static heap(){return new r((function(t){return t.f}))}static search(t,e,s){this.init(t);const i=this.heap();for(i.push(e);i.size()>0;){const e=i.pop();if(e===s){let t=e;const s=[];for(;t.parent;)s.push(t),t=t.parent;return this.cleanUp(s),s.reverse()}e.closed=!0;const o=this.neighbours(t,e);for(let t=0,n=o.length;t<n;t++){const n=o[t];if(n.closed)continue;const r=e.g+n.cost,h=n.visited;if(!h||r<n.g){if(n.visited=!0,n.parent=e,!n.centroid||!s.centroid)throw new Error("Unexpected state");n.h=n.h||this.heuristic(n.centroid,s.centroid),n.g=r,n.f=n.g+n.h,h?i.rescoreElement(n):i.push(n)}}}return[]}static heuristic(t,e){return n.distanceToSquared(t,e)}static neighbours(t,e){const s=[];for(let i=0;i<e.neighbours.length;i++)s.push(t[e.neighbours[i]]);return s}}.search(a,u,l),d=function(t,e){for(var s=0;s<t.neighbours.length;s++)if(t.neighbours[s]===e.id)return t.portals[s]},v=new h;v.push(t);for(let t=0;t<p.length;t++){const e=p[t],s=p[t+1];if(s){const t=d(e,s);v.push(c[t[0]],c[t[1]])}}v.push(e),v.stringPull();const g=v.path.map((t=>new i.Pa4(t.x,t.y,t.z)));return g.shift(),g}}a.prototype.getGroup=function(){const t=new i.JOQ;return function(e,s,i=!1){if(!this.zones[e])return null;let o=null,r=Math.pow(50,2);const h=this.zones[e];for(let e=0;e<h.groups.length;e++){const a=h.groups[e];for(const c of a){if(i&&(t.setFromCoplanarPoints(h.vertices[c.vertexIds[0]],h.vertices[c.vertexIds[1]],h.vertices[c.vertexIds[2]]),Math.abs(t.distanceToPoint(s))<.01)&&n.isPointInPoly([h.vertices[c.vertexIds[0]],h.vertices[c.vertexIds[1]],h.vertices[c.vertexIds[2]]],s))return e;const a=n.distanceToSquared(c.centroid,s);a<r&&(o=e,r=a)}}return o}}(),a.prototype.clampStep=function(){const t=new i.Pa4,e=new i.JOQ,s=new i.CJI,o=new i.Pa4;let n,r,h=new i.Pa4;return function(i,a,c,u,l,p){const d=this.zones[u].vertices,v=this.zones[u].groups[l],g=[c],m={};m[c.id]=0,n=void 0,h.set(0,0,0),r=1/0,e.setFromCoplanarPoints(d[c.vertexIds[0]],d[c.vertexIds[1]],d[c.vertexIds[2]]),e.projectPoint(a,t),o.copy(t);for(let e=g.pop();e;e=g.pop()){s.set(d[e.vertexIds[0]],d[e.vertexIds[1]],d[e.vertexIds[2]]),s.closestPointToPoint(o,t),t.distanceToSquared(o)<r&&(n=e,h.copy(t),r=t.distanceToSquared(o));const i=m[e.id];if(!(i>2))for(let t=0;t<e.neighbours.length;t++){const s=v[e.neighbours[t]];s.id in m||(g.push(s),m[s.id]=i+1)}}return p.copy(h),n}}();new i.Ilk(15631215).convertSRGBToLinear().getHex(),new i.Ilk(14469912).convertSRGBToLinear().getHex(),new i.Ilk(41903).convertSRGBToLinear().getHex(),new i.Ilk(41903).convertSRGBToLinear().getHex(),new i.Ilk(14472114).convertSRGBToLinear().getHex(),new i.Ilk(4417387).convertSRGBToLinear().getHex();function c(t,e,s){return e in t?Object.defineProperty(t,e,{value:s,enumerable:!0,configurable:!0,writable:!0}):t[e]=s,t}class u{constructor(){c(this,"pathfinder",void 0),c(this,"mesh",void 0),c(this,"zone","character"),c(this,"navGroup",null),c(this,"navNode",null),c(this,"findPOVPositionAboveNavMesh",(()=>{const t=new i.Pa4,e=new i.Pa4;return(s,i,o)=>(t.copy(s),t.y-=2,e.copy(i),e.y-=2,this.findPositionOnNavMesh(t,e,o),o.y+=2,o)})())}isEnabled(){return this.pathfinder&&this.zone in this.pathfinder.zones}loadMesh(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.zone;this.pathfinder=new a,this.mesh=null,this.zone=e,this.mesh&&(console.error("tried to load multiple nav meshes"),this.removeNavMeshData());const s=t.geometry;s.applyMatrix4(t.matrixWorld),this.pathfinder.setZoneData(e,a.createZone(s)),this.mesh=t}getClosestNode(t){const e=this.pathfinder;return e.zones[this.zone].groups[this.navGroup]?e.getClosestNode(t,this.zone,this.navGroup,!0)||e.getClosestNode(t,this.zone,this.navGroup):null}findPositionOnNavMesh(t,e,s){let i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const o=this.pathfinder;if(this.zone in o.zones)return this.navGroup=i||null===this.navGroup?o.getGroup(this.zone,e,!0,!0):this.navGroup,this.navNode=i||null===this.navNode||void 0===this.navNode?this.getClosestNode(e):this.navNode,null===this.navNode||void 0===this.navNode?s.copy(e):this.navNode=o.clampStep(t,e,this.navNode,this.zone,this.navGroup,s),s}removeNavMeshData(){this.mesh&&this.mesh.geometry&&this.mesh.geometry.dispose&&this.mesh.geometry.dispose(),this.mesh=null,this.pathfinder.zones={}}}function l(t,e,s){return e in t?Object.defineProperty(t,e,{value:s,enumerable:!0,configurable:!0,writable:!0}):t[e]=s,t}class p{async createComponent(t,e){let s=t.getFirstComponentByType(o.ServiceEntity.name),n=await s.getService("@aptero/axolotis-core-plugins/modules/three/ThreeLib"),r=await s.getService("@aptero/axolotis-core-plugins/modules/controller/pathFindingPlayer/Input"),h=await s.getService("@aptero/axolotis-core-plugins/modules/controller/PlayerService"),a=await s.getService("@aptero/axolotis-player/modules/FrameLoop"),c=new i.Pa4(e.position&&e.position.x||0,e.position&&e.position.y||0,e.position&&e.position.z||0),u=(new i._fP).setFromAxisAngle(new i.Pa4(0,1,0),.5*-Math.PI),l=new d(c,u,await n,await r,h);return h.declarePlayer(l),l.Initialize(),(await a).addLoop(d.name,(t=>{l.Update(t)})),l}}class d{getType(){return d.name}askFlyMode(){}declareNavMesh(t){this.navMesh.loadMesh(t,"character")}teleportToLocation(t,e,s){this.position.copy(new i.Pa4(t,e,s))}getHeadPosition(t){t.copy(this.position)}constructor(t,e,s,o,n){this.input=o,this.playerService=n,l(this,"camera",void 0),l(this,"timeZeroToMax",void 0),l(this,"decceleration",void 0),l(this,"speed",void 0),l(this,"maxSpeed",void 0),l(this,"mouseSpeed",void 0),l(this,"acceleration",void 0),l(this,"isLocked",void 0),l(this,"angles",void 0),l(this,"pitch",void 0),l(this,"jumpVelocity",void 0),l(this,"yaw",void 0),l(this,"tempVec",void 0),l(this,"moveDir",void 0),l(this,"yOffset",void 0),l(this,"xAxis",void 0),l(this,"yAxis",void 0),l(this,"position",void 0),l(this,"positionOutTmp",new i.Pa4),l(this,"positionOutTmp2",new i.Pa4),l(this,"rotation",void 0),l(this,"velocity",void 0),l(this,"navMesh",void 0),l(this,"OnPointerlockChange",(()=>{document.pointerLockElement?this.isLocked=!0:this.isLocked=!1})),l(this,"OnMouseMove",(t=>{if(!this.isLocked)return;const{movementX:e,movementY:s}=t;this.angles.y-=e*this.mouseSpeed,this.angles.x-=s*this.mouseSpeed,this.angles.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.angles.x)),this.UpdateRotation()})),l(this,"Accelarate",((t,e)=>{const s=this.tempVec.copy(t).multiplyScalar(this.acceleration*e);this.speed.add(s),this.speed.clampLength(0,this.maxSpeed)})),l(this,"Deccelerate",(t=>{const e=this.tempVec.copy(this.speed).multiplyScalar(this.decceleration*t);this.speed.add(e)})),this.position=t,this.rotation=e,this.navMesh=new u,this.camera=s.camera,this.timeZeroToMax=.08,this.maxSpeed=7,this.speed=new i.Pa4,this.acceleration=this.maxSpeed/this.timeZeroToMax,this.decceleration=-7,this.mouseSpeed=.002,this.isLocked=!1,this.angles=new i.USm,this.pitch=new i._fP,this.yaw=new i._fP,this.jumpVelocity=5,this.yOffset=2,this.tempVec=new i.Pa4,this.moveDir=new i.Pa4,this.xAxis=new i.Pa4(1,0,0),this.yAxis=new i.Pa4(0,1,0),this.velocity=new i.Pa4}Initialize(){this.angles.setFromQuaternion(this.rotation),this.UpdateRotation(),this.input.AddMouseMoveListner(this.OnMouseMove),document.addEventListener("pointerlockchange",this.OnPointerlockChange),this.input.AddClickListner((()=>{this.isLocked||document.body.requestPointerLock()}))}UpdateRotation(){this.pitch.setFromAxisAngle(this.xAxis,this.angles.x),this.yaw.setFromAxisAngle(this.yAxis,this.angles.y),this.rotation.multiplyQuaternions(this.yaw,this.pitch).normalize(),this.camera.quaternion.copy(this.rotation)}Update(t){t*=.001;const e=this.input.GetKeyDown("KeyS")-this.input.GetKeyDown("KeyW"),s=this.input.GetKeyDown("KeyD")-this.input.GetKeyDown("KeyA"),i=this.moveDir.set(s,0,e).normalize();this.Deccelerate(t),this.Accelarate(i,t);const o=this.tempVec.copy(this.speed);o.applyQuaternion(this.yaw),this.velocity.setX(o.x),this.velocity.setZ(o.z),this.velocity.multiplyScalar(t),this.positionOutTmp.x=this.position.x+this.velocity.x,this.positionOutTmp.y=this.position.y+this.velocity.y,this.positionOutTmp.z=this.position.z+this.velocity.z,this.navMesh.isEnabled()?this.navMesh.findPOVPositionAboveNavMesh(this.position,this.positionOutTmp,this.positionOutTmp2):this.positionOutTmp2.copy(this.positionOutTmp),this.camera.position.set(this.positionOutTmp2.x,this.positionOutTmp2.y,this.positionOutTmp2.z),this.position.copy(this.camera.position)}}}}]);
//# sourceMappingURL=NavMeshPlayer.js.map