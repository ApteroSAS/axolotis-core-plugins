/*!
 * 
 *   @aptero/axolotis-core-plugins v1.0.0
 *   https://github.com/ApteroSAS/axolotis-player
 *
 *   Copyright (c) Aptero (https://github.com/ApteroSAS/axolotis-player) and project contributors.
 *
 *   This source code is licensed under the MIT license found in the
 *   LICENSE file in the root directory of this source tree.
 *
 */
"use strict";(self.webpackChunkaxolotis_core_plugins=self.webpackChunkaxolotis_core_plugins||[]).push([[625],{7:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Factory": function() { return /* binding */ Factory; },\n  "default": function() { return /* binding */ NavMeshPlayer; }\n});\n\n// EXTERNAL MODULE: ./node_modules/three/build/three.module.js\nvar three_module = __webpack_require__(212);\n// EXTERNAL MODULE: ../axolotis-player/build/index.js\nvar build = __webpack_require__(919);\n;// CONCATENATED MODULE: ./node_modules/three-pathfinding/dist/three-pathfinding.module.js\nclass p{static roundNumber(t,e){const r=Math.pow(10,e);return Math.round(t*r)/r}static sample(t){return t[Math.floor(Math.random()*t.length)]}static distanceToSquared(t,e){var r=t.x-e.x,s=t.y-e.y,n=t.z-e.z;return r*r+s*s+n*n}static isPointInPoly(t,e){for(var r=!1,s=-1,n=t.length,o=n-1;++s<n;o=s)(t[s].z<=e.z&&e.z<t[o].z||t[o].z<=e.z&&e.z<t[s].z)&&e.x<(t[o].x-t[s].x)*(e.z-t[s].z)/(t[o].z-t[s].z)+t[s].x&&(r=!r);return r}static isVectorInPolygon(t,e,r){var s=1e5,n=-1e5,o=[];return e.vertexIds.forEach(t=>{s=Math.min(r[t].y,s),n=Math.max(r[t].y,n),o.push(r[t])}),!!(t.y<n+.5&&t.y>s-.5&&this.isPointInPoly(o,t))}static triarea2(t,e,r){return(r.x-t.x)*(e.z-t.z)-(e.x-t.x)*(r.z-t.z)}static vequal(t,e){return this.distanceToSquared(t,e)<1e-5}static mergeVertices(r,s=1e-4){s=Math.max(s,Number.EPSILON);for(var n={},o=r.getIndex(),i=r.getAttribute("position"),h=o?o.count:i.count,c=0,a=[],u=[],l=Math.log10(1/s),d=Math.pow(10,l),p=0;p<h;p++){var g=o?o.getX(p):p,f="";f+=~~(i.getX(g)*d)+",",f+=~~(i.getY(g)*d)+",",(f+=~~(i.getZ(g)*d)+",")in n?a.push(n[f]):(u.push(i.getX(g)),u.push(i.getY(g)),u.push(i.getZ(g)),n[f]=c,a.push(c),c++)}const v=new three_module.BufferAttribute(new Float32Array(u),i.itemSize,i.normalized),b=new three_module.BufferGeometry;return b.setAttribute("position",v),b.setIndex(a),b}}class g{constructor(t){this.content=[],this.scoreFunction=t}push(t){this.content.push(t),this.sinkDown(this.content.length-1)}pop(){const t=this.content[0],e=this.content.pop();return this.content.length>0&&(this.content[0]=e,this.bubbleUp(0)),t}remove(t){const e=this.content.indexOf(t),r=this.content.pop();e!==this.content.length-1&&(this.content[e]=r,this.scoreFunction(r)<this.scoreFunction(t)?this.sinkDown(e):this.bubbleUp(e))}size(){return this.content.length}rescoreElement(t){this.sinkDown(this.content.indexOf(t))}sinkDown(t){const e=this.content[t];for(;t>0;){const r=(t+1>>1)-1,s=this.content[r];if(!(this.scoreFunction(e)<this.scoreFunction(s)))break;this.content[r]=e,this.content[t]=s,t=r}}bubbleUp(t){const e=this.content.length,r=this.content[t],s=this.scoreFunction(r);for(;;){const n=t+1<<1,o=n-1;let i,h=null;if(o<e&&(i=this.scoreFunction(this.content[o]),i<s&&(h=o)),n<e&&this.scoreFunction(this.content[n])<(null===h?s:i)&&(h=n),null===h)break;this.content[t]=this.content[h],this.content[h]=r,t=h}}}class f{constructor(){this.portals=[]}push(t,e){void 0===e&&(e=t),this.portals.push({left:t,right:e})}stringPull(){const t=this.portals,e=[];let r,s,n,o=0,i=0,h=0;r=t[0].left,s=t[0].left,n=t[0].right,e.push(r);for(let c=1;c<t.length;c++){const a=t[c].left,u=t[c].right;if(p.triarea2(r,n,u)<=0){if(!(p.vequal(r,n)||p.triarea2(r,s,u)>0)){e.push(s),r=s,o=i,s=r,n=r,i=o,h=o,c=o;continue}n=u,h=c}if(p.triarea2(r,s,a)>=0){if(!(p.vequal(r,s)||p.triarea2(r,n,a)<0)){e.push(n),r=n,o=h,s=r,n=r,i=o,h=o,c=o;continue}s=a,i=c}}return 0!==e.length&&p.vequal(e[e.length-1],t[t.length-1].left)||e.push(t[t.length-1].left),this.path=e,e}}class v{constructor(){this.zones={}}static createZone(t,e=1e-4){return class{static buildZone(t,e){const s=this._buildNavigationMesh(t,e),n={};s.vertices.forEach(t=>{t.x=p.roundNumber(t.x,2),t.y=p.roundNumber(t.y,2),t.z=p.roundNumber(t.z,2)}),n.vertices=s.vertices;const o=this._buildPolygonGroups(s);return n.groups=new Array(o.length),o.forEach((t,e)=>{const s=new Map;t.forEach((t,e)=>{s.set(t,e)});const o=new Array(t.length);t.forEach((t,e)=>{const i=[];t.neighbours.forEach(t=>i.push(s.get(t)));const h=[];t.neighbours.forEach(e=>h.push(this._getSharedVerticesInOrder(t,e)));const c=new three_module.Vector3(0,0,0);c.add(n.vertices[t.vertexIds[0]]),c.add(n.vertices[t.vertexIds[1]]),c.add(n.vertices[t.vertexIds[2]]),c.divideScalar(3),c.x=p.roundNumber(c.x,2),c.y=p.roundNumber(c.y,2),c.z=p.roundNumber(c.z,2),o[e]={id:e,neighbours:i,vertexIds:t.vertexIds,centroid:c,portals:h}}),n.groups[e]=o}),n}static _buildNavigationMesh(t,e){return t=p.mergeVertices(t,e),this._buildPolygonsFromGeometry(t)}static _spreadGroupId(t){let e=new Set([t]);for(;e.size>0;){const r=e;e=new Set,r.forEach(r=>{r.group=t.group,r.neighbours.forEach(t=>{void 0===t.group&&e.add(t)})})}}static _buildPolygonGroups(t){const e=[];return t.polygons.forEach(t=>{void 0!==t.group?e[t.group].push(t):(t.group=e.length,this._spreadGroupId(t),e.push([t]))}),e}static _buildPolygonNeighbours(t,e){const r=new Set,s=e[t.vertexIds[1]],n=e[t.vertexIds[2]];return e[t.vertexIds[0]].forEach(e=>{e!==t&&(s.includes(e)||n.includes(e))&&r.add(e)}),s.forEach(e=>{e!==t&&n.includes(e)&&r.add(e)}),r}static _buildPolygonsFromGeometry(t){const e=[],s=[],n=t.attributes.position,o=t.index,i=[];for(let t=0;t<n.count;t++)s.push((new three_module.Vector3).fromBufferAttribute(n,t)),i[t]=[];for(let r=0;r<t.index.count;r+=3){const t=o.getX(r),s=o.getX(r+1),n=o.getX(r+2),h={vertexIds:[t,s,n],neighbours:null};e.push(h),i[t].push(h),i[s].push(h),i[n].push(h)}return e.forEach(t=>{t.neighbours=this._buildPolygonNeighbours(t,i)}),{polygons:e,vertices:s}}static _getSharedVerticesInOrder(t,e){const r=t.vertexIds,s=r[0],n=r[1],o=r[2],i=e.vertexIds,h=i.includes(s),c=i.includes(n),a=i.includes(o);return h&&c&&a?Array.from(r):h&&c?[s,n]:c&&a?[n,o]:h&&a?[o,s]:(console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."),[])}}.buildZone(t,e)}setZoneData(t,e){this.zones[t]=e}getRandomNode(t,e,s,n){if(!this.zones[t])return new three_module.Vector3;s=s||null,n=n||0;const o=[];return this.zones[t].groups[e].forEach(t=>{s&&n?p.distanceToSquared(s,t.centroid)<n*n&&o.push(t.centroid):o.push(t.centroid)}),p.sample(o)||new three_module.Vector3}getClosestNode(t,e,r,s=!1){const n=this.zones[e].vertices;let o=null,i=Infinity;return this.zones[e].groups[r].forEach(e=>{const r=p.distanceToSquared(e.centroid,t);r<i&&(!s||p.isVectorInPolygon(t,e,n))&&(o=e,i=r)}),o}findPath(t,e,s,n){const o=this.zones[s].groups[n],i=this.zones[s].vertices,h=this.getClosestNode(t,s,n,!0),c=this.getClosestNode(e,s,n,!0);if(!h||!c)return null;const a=class{static init(t){for(let e=0;e<t.length;e++){const r=t[e];r.f=0,r.g=0,r.h=0,r.cost=1,r.visited=!1,r.closed=!1,r.parent=null}}static cleanUp(t){for(let e=0;e<t.length;e++){const r=t[e];delete r.f,delete r.g,delete r.h,delete r.cost,delete r.visited,delete r.closed,delete r.parent}}static heap(){return new g(function(t){return t.f})}static search(t,e,r){this.init(t);const s=this.heap();for(s.push(e);s.size()>0;){const e=s.pop();if(e===r){let t=e;const r=[];for(;t.parent;)r.push(t),t=t.parent;return this.cleanUp(r),r.reverse()}e.closed=!0;const n=this.neighbours(t,e);for(let t=0,o=n.length;t<o;t++){const o=n[t];if(o.closed)continue;const i=e.g+o.cost,h=o.visited;if(!h||i<o.g){if(o.visited=!0,o.parent=e,!o.centroid||!r.centroid)throw new Error("Unexpected state");o.h=o.h||this.heuristic(o.centroid,r.centroid),o.g=i,o.f=o.g+o.h,h?s.rescoreElement(o):s.push(o)}}}return[]}static heuristic(t,e){return p.distanceToSquared(t,e)}static neighbours(t,e){const r=[];for(let s=0;s<e.neighbours.length;s++)r.push(t[e.neighbours[s]]);return r}}.search(o,h,c),u=function(t,e){for(var r=0;r<t.neighbours.length;r++)if(t.neighbours[r]===e.id)return t.portals[r]},l=new f;l.push(t);for(let t=0;t<a.length;t++){const e=a[t],r=a[t+1];if(r){const t=u(e,r);l.push(i[t[0]],i[t[1]])}}l.push(e),l.stringPull();const d=l.path.map(t=>new three_module.Vector3(t.x,t.y,t.z));return d.shift(),d}}v.prototype.getGroup=function(){const t=new three_module.Plane;return function(e,r,s=!1){if(!this.zones[e])return null;let n=null,o=Math.pow(50,2);const i=this.zones[e];for(let e=0;e<i.groups.length;e++){const h=i.groups[e];for(const c of h){if(s&&(t.setFromCoplanarPoints(i.vertices[c.vertexIds[0]],i.vertices[c.vertexIds[1]],i.vertices[c.vertexIds[2]]),Math.abs(t.distanceToPoint(r))<.01)&&p.isPointInPoly([i.vertices[c.vertexIds[0]],i.vertices[c.vertexIds[1]],i.vertices[c.vertexIds[2]]],r))return e;const h=p.distanceToSquared(c.centroid,r);h<o&&(n=e,o=h)}}return n}}(),v.prototype.clampStep=function(){const t=new three_module.Vector3,e=new three_module.Plane,o=new three_module.Triangle,i=new three_module.Vector3;let h,c,a=new three_module.Vector3;return function(r,s,n,u,l,d){const p=this.zones[u].vertices,g=this.zones[u].groups[l],f=[n],v={};v[n.id]=0,h=void 0,a.set(0,0,0),c=Infinity,e.setFromCoplanarPoints(p[n.vertexIds[0]],p[n.vertexIds[1]],p[n.vertexIds[2]]),e.projectPoint(s,t),i.copy(t);for(let e=f.pop();e;e=f.pop()){o.set(p[e.vertexIds[0]],p[e.vertexIds[1]],p[e.vertexIds[2]]),o.closestPointToPoint(i,t),t.distanceToSquared(i)<c&&(h=e,a.copy(t),c=t.distanceToSquared(i));const r=v[e.id];if(!(r>2))for(let t=0;t<e.neighbours.length;t++){const s=g[e.neighbours[t]];s.id in v||(f.push(s),v[s.id]=r+1)}}return d.copy(a),h}}();const b={PLAYER:new three_module.Color(15631215).convertSRGBToLinear().getHex(),TARGET:new three_module.Color(14469912).convertSRGBToLinear().getHex(),PATH:new three_module.Color(41903).convertSRGBToLinear().getHex(),WAYPOINT:new three_module.Color(41903).convertSRGBToLinear().getHex(),CLAMPED_STEP:new three_module.Color(14472114).convertSRGBToLinear().getHex(),CLOSEST_NODE:new three_module.Color(4417387).convertSRGBToLinear().getHex()};class w extends (/* unused pure expression or super */ null && (i)){constructor(){super(),this._playerMarker=new h(new c(.25,32,32),new a({color:b.PLAYER})),this._targetMarker=new h(new u(.3,.3,.3),new a({color:b.TARGET})),this._nodeMarker=new h(new u(.1,.8,.1),new a({color:b.CLOSEST_NODE})),this._stepMarker=new h(new u(.1,1,.1),new a({color:b.CLAMPED_STEP})),this._pathMarker=new i,this._pathLineMaterial=new l({color:b.PATH,linewidth:2}),this._pathPointMaterial=new a({color:b.WAYPOINT}),this._pathPointGeometry=new c(.08),this._markers=[this._playerMarker,this._targetMarker,this._nodeMarker,this._stepMarker,this._pathMarker],this._markers.forEach(t=>{t.visible=!1,this.add(t)})}setPath(r){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);r=[this._playerMarker.position].concat(r);const s=new e;s.setAttribute("position",new t(new Float32Array(3*r.length),3));for(let t=0;t<r.length;t++)s.attributes.position.setXYZ(t,r[t].x,r[t].y+.2,r[t].z);this._pathMarker.add(new d(s,this._pathLineMaterial));for(let t=0;t<r.length-1;t++){const e=new h(this._pathPointGeometry,this._pathPointMaterial);e.position.copy(r[t]),e.position.y+=.2,this._pathMarker.add(e)}return this._pathMarker.visible=!0,this}setPlayerPosition(t){return this._playerMarker.position.copy(t),this._playerMarker.visible=!0,this}setTargetPosition(t){return this._targetMarker.position.copy(t),this._targetMarker.visible=!0,this}setNodePosition(t){return this._nodeMarker.position.copy(t),this._nodeMarker.visible=!0,this}setStepPosition(t){return this._stepMarker.position.copy(t),this._stepMarker.visible=!0,this}reset(){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);return this._markers.forEach(t=>{t.visible=!1}),this}}\n//# sourceMappingURL=three-pathfinding.module.js.map\n\n;// CONCATENATED MODULE: ./src/lib/modules/controller/pathFindingPlayer/NavMeshPathfinder.ts\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nclass NavMeshPathfinder {\n  constructor() {\n    _defineProperty(this, "pathfinder", void 0);\n\n    _defineProperty(this, "mesh", void 0);\n\n    _defineProperty(this, "zone", "character");\n\n    _defineProperty(this, "navGroup", null);\n\n    _defineProperty(this, "navNode", null);\n\n    _defineProperty(this, "findPOVPositionAboveNavMesh", (() => {\n      const startingFeetPosition = new three_module.Vector3();\n      const desiredFeetPosition = new three_module.Vector3(); // TODO: Here we assume the player is standing straight up, but in VR it is often the case\n      // that you want to lean over the edge of a balcony/table that does not have nav mesh below.\n      // We should find way to allow leaning over the edge of a balcony and maybe disallow putting\n      // your head through a wall.\n\n      return (startPOVPosition, desiredPOVPosition, outPOVPosition) => {\n        //const playerHeight = getCurrentPlayerHeight(true);\n        const playerHeight = 2;\n        startingFeetPosition.copy(startPOVPosition);\n        startingFeetPosition.y -= playerHeight;\n        desiredFeetPosition.copy(desiredPOVPosition);\n        desiredFeetPosition.y -= playerHeight;\n        this.findPositionOnNavMesh(startingFeetPosition, desiredFeetPosition, outPOVPosition);\n        outPOVPosition.y += playerHeight;\n        return outPOVPosition;\n      };\n    })());\n  }\n\n  isEnabled() {\n    return this.pathfinder && this.zone in this.pathfinder.zones;\n  }\n\n  loadMesh(mesh) {\n    let zone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.zone;\n    this.pathfinder = new v();\n    this.mesh = null;\n    this.zone = zone;\n\n    if (this.mesh) {\n      console.error("tried to load multiple nav meshes");\n      this.removeNavMeshData();\n    }\n\n    const geometry = mesh.geometry;\n    geometry.applyMatrix4(mesh.matrixWorld);\n    this.pathfinder.setZoneData(zone, v.createZone(geometry));\n    this.mesh = mesh;\n  }\n\n  getClosestNode(pos) {\n    const pathfinder = this.pathfinder;\n\n    if (!pathfinder.zones[this.zone].groups[this.navGroup]) {\n      return null;\n    }\n\n    return pathfinder.getClosestNode(pos, this.zone, this.navGroup, true) || pathfinder.getClosestNode(pos, this.zone, this.navGroup);\n  }\n\n  findPositionOnNavMesh(start, end, outPos) {\n    let shouldRecomputeGroupAndNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const pathfinder = this.pathfinder;\n    if (!(this.zone in pathfinder.zones)) return;\n    this.navGroup = shouldRecomputeGroupAndNode || this.navGroup === null ? pathfinder.getGroup(this.zone, end, true, true) : this.navGroup;\n    this.navNode = shouldRecomputeGroupAndNode || this.navNode === null || this.navNode === undefined ? this.getClosestNode(end) : this.navNode;\n\n    if (this.navNode === null || this.navNode === undefined) {\n      // this.navNode can be null if it has never been set or if getClosestNode fails,\n      // and it can be undefined if clampStep fails, so we have to check both. We do not\n      // simply check if it is falsey (!this.navNode), because 0 (zero) is a valid value,\n      // and 0 is falsey.\n      outPos.copy(end);\n    } else {\n      this.navNode = pathfinder.clampStep(start, end, this.navNode, this.zone, this.navGroup, outPos);\n    }\n\n    return outPos;\n  }\n  /*findPositionOnNavMesh(\n    start: Vector3,\n    end: Vector3,\n    outPos: Vector3,\n    shouldRecomputeGroupAndNode: boolean = false\n  ) {\n    const pathfinder = this.pathfinder;\n    if (!(this.zone in pathfinder.zones)) return;\n    this.navGroup =\n      shouldRecomputeGroupAndNode || this.navGroup === null\n        ? pathfinder.getGroup(this.zone, end, true, true)\n        : this.navGroup;\n    this.navNode =\n      shouldRecomputeGroupAndNode ||\n      this.navNode === null ||\n      this.navNode === undefined\n        ? this.getClosestNode(end)\n        : this.navNode;\n    if (this.navNode === null || this.navNode === undefined) {\n      // this.navNode can be null if it has never been set or if getClosestNode fails,\n      // and it can be undefined if clampStep fails, so we have to check both. We do not\n      // simply check if it is falsey (!this.navNode), because 0 (zero) is a valid value,\n      // and 0 is falsey.\n      outPos.copy(end);\n    } else {\n      try {\n        this.navNode = pathfinder.clampStep(\n          start,\n          end,\n          this.navNode,\n          this.zone,\n          this.navGroup,\n          outPos\n        );\n      } catch (e) {\n        console.error(e);\n        outPos.copy(start);\n        this.navNode = null;\n        this.navGroup = null;\n      }\n    }\n    return outPos;\n  }*/\n\n\n  removeNavMeshData() {\n    if (this.mesh && this.mesh.geometry && this.mesh.geometry.dispose) {\n      this.mesh.geometry.dispose();\n    }\n\n    this.mesh = null;\n    this.pathfinder.zones = {};\n  }\n\n}\n;// CONCATENATED MODULE: ./src/lib/modules/controller/pathFindingPlayer/NavMeshPlayer.ts\nfunction NavMeshPlayer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n//import { ServiceEntity } from "@aptero/axolotis-player/build/types/modules/core/service/ServiceEntity";\n\n\nclass Factory {\n  async createComponent(world, config) {\n    let services = world.getFirstComponentByType(build.ServiceEntity.name);\n    let three = await services.getService("@aptero/axolotis-core-plugins/modules/three/ThreeLib");\n    let input = await services.getService("@aptero/axolotis-core-plugins/modules/controller/pathFindingPlayer/Input");\n    let playerService = await services.getService("@aptero/axolotis-core-plugins/modules/controller/PlayerService");\n    let frameLoop = await services.getService("@aptero/axolotis-player/modules/FrameLoop"); //let position = new THREE.Vector3(2.14, 1.48, -1.36);\n    //let position = new THREE.Vector3(0,5,0);\n\n    let position = new three_module.Vector3(config.position && config.position.x || 0, config.position && config.position.y || 0, config.position && config.position.z || 0);\n    let rotation = new three_module.Quaternion().setFromAxisAngle(new three_module.Vector3(0, 1, 0), -Math.PI * 0.5);\n    let playerControls = new NavMeshPlayer(position, rotation, await three, await input, playerService);\n    playerService.declarePlayer(playerControls);\n    playerControls.Initialize();\n    (await frameLoop).addLoop(NavMeshPlayer.name, delta => {\n      playerControls.Update(delta);\n    });\n    return playerControls;\n  }\n\n}\nconst NAV_ZONE = "character";\nclass NavMeshPlayer {\n  //playerHeight\n  getType() {\n    return NavMeshPlayer.name;\n  }\n\n  askFlyMode() {}\n\n  declareNavMesh(navMesh) {\n    this.navMesh.loadMesh(navMesh, NAV_ZONE);\n  }\n\n  teleportToLocation(x, y, z) {\n    this.position.copy(new three_module.Vector3(x, y, z));\n  }\n\n  getHeadPosition(targetCopy) {\n    targetCopy.copy(this.position);\n  }\n\n  constructor(position, rotation, three, input, playerService) {\n    this.input = input;\n    this.playerService = playerService;\n\n    NavMeshPlayer_defineProperty(this, "camera", void 0);\n\n    NavMeshPlayer_defineProperty(this, "timeZeroToMax", void 0);\n\n    NavMeshPlayer_defineProperty(this, "decceleration", void 0);\n\n    NavMeshPlayer_defineProperty(this, "speed", void 0);\n\n    NavMeshPlayer_defineProperty(this, "maxSpeed", void 0);\n\n    NavMeshPlayer_defineProperty(this, "mouseSpeed", void 0);\n\n    NavMeshPlayer_defineProperty(this, "acceleration", void 0);\n\n    NavMeshPlayer_defineProperty(this, "isLocked", void 0);\n\n    NavMeshPlayer_defineProperty(this, "angles", void 0);\n\n    NavMeshPlayer_defineProperty(this, "pitch", void 0);\n\n    NavMeshPlayer_defineProperty(this, "jumpVelocity", void 0);\n\n    NavMeshPlayer_defineProperty(this, "yaw", void 0);\n\n    NavMeshPlayer_defineProperty(this, "tempVec", void 0);\n\n    NavMeshPlayer_defineProperty(this, "moveDir", void 0);\n\n    NavMeshPlayer_defineProperty(this, "yOffset", void 0);\n\n    NavMeshPlayer_defineProperty(this, "xAxis", void 0);\n\n    NavMeshPlayer_defineProperty(this, "yAxis", void 0);\n\n    NavMeshPlayer_defineProperty(this, "position", void 0);\n\n    NavMeshPlayer_defineProperty(this, "positionOutTmp", new three_module.Vector3());\n\n    NavMeshPlayer_defineProperty(this, "positionOutTmp2", new three_module.Vector3());\n\n    NavMeshPlayer_defineProperty(this, "rotation", void 0);\n\n    NavMeshPlayer_defineProperty(this, "velocity", void 0);\n\n    NavMeshPlayer_defineProperty(this, "navMesh", void 0);\n\n    NavMeshPlayer_defineProperty(this, "OnPointerlockChange", () => {\n      if (document.pointerLockElement) {\n        this.isLocked = true;\n        return;\n      }\n\n      this.isLocked = false;\n    });\n\n    NavMeshPlayer_defineProperty(this, "OnMouseMove", event => {\n      if (!this.isLocked) {\n        return;\n      }\n\n      const {\n        movementX,\n        movementY\n      } = event;\n      this.angles.y -= movementX * this.mouseSpeed;\n      this.angles.x -= movementY * this.mouseSpeed;\n      this.angles.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.angles.x));\n      this.UpdateRotation();\n    });\n\n    NavMeshPlayer_defineProperty(this, "Accelarate", (direction, t) => {\n      const accel = this.tempVec.copy(direction).multiplyScalar(this.acceleration * t);\n      this.speed.add(accel);\n      this.speed.clampLength(0.0, this.maxSpeed);\n    });\n\n    NavMeshPlayer_defineProperty(this, "Deccelerate", t => {\n      const frameDeccel = this.tempVec.copy(this.speed).multiplyScalar(this.decceleration * t);\n      this.speed.add(frameDeccel);\n    });\n\n    this.position = position;\n    this.rotation = rotation;\n    this.navMesh = new NavMeshPathfinder();\n    this.camera = three.camera;\n    this.timeZeroToMax = 0.08;\n    this.maxSpeed = 7.0;\n    this.speed = new three_module.Vector3();\n    this.acceleration = this.maxSpeed / this.timeZeroToMax;\n    this.decceleration = -7.0;\n    this.mouseSpeed = 0.002;\n    this.isLocked = false;\n    this.angles = new three_module.Euler();\n    this.pitch = new three_module.Quaternion();\n    this.yaw = new three_module.Quaternion();\n    this.jumpVelocity = 5;\n    this.yOffset = 2;\n    this.tempVec = new three_module.Vector3();\n    this.moveDir = new three_module.Vector3();\n    this.xAxis = new three_module.Vector3(1.0, 0.0, 0.0);\n    this.yAxis = new three_module.Vector3(0.0, 1.0, 0.0);\n    this.velocity = new three_module.Vector3();\n  }\n\n  Initialize() {\n    this.angles.setFromQuaternion(this.rotation);\n    this.UpdateRotation();\n    this.input.AddMouseMoveListner(this.OnMouseMove);\n    document.addEventListener("pointerlockchange", this.OnPointerlockChange);\n    this.input.AddClickListner(() => {\n      if (!this.isLocked) {\n        document.body.requestPointerLock();\n      }\n    });\n  }\n\n  UpdateRotation() {\n    this.pitch.setFromAxisAngle(this.xAxis, this.angles.x);\n    this.yaw.setFromAxisAngle(this.yAxis, this.angles.y);\n    this.rotation.multiplyQuaternions(this.yaw, this.pitch).normalize();\n    this.camera.quaternion.copy(this.rotation);\n  }\n\n  Update(t) {\n    t = t * 0.001;\n    const forwardFactor = this.input.GetKeyDown("KeyS") - this.input.GetKeyDown("KeyW");\n    const rightFactor = this.input.GetKeyDown("KeyD") - this.input.GetKeyDown("KeyA");\n    const direction = this.moveDir.set(rightFactor, 0.0, forwardFactor).normalize();\n    this.Deccelerate(t);\n    this.Accelarate(direction, t);\n    const moveVector = this.tempVec.copy(this.speed);\n    moveVector.applyQuaternion(this.yaw);\n    this.velocity.setX(moveVector.x);\n    this.velocity.setZ(moveVector.z);\n    this.velocity.multiplyScalar(t);\n    this.positionOutTmp.x = this.position.x + this.velocity.x;\n    this.positionOutTmp.y = this.position.y + this.velocity.y;\n    this.positionOutTmp.z = this.position.z + this.velocity.z;\n\n    if (this.navMesh.isEnabled()) {\n      this.navMesh.findPOVPositionAboveNavMesh(this.position, this.positionOutTmp, this.positionOutTmp2);\n    } else {\n      this.positionOutTmp2.copy(this.positionOutTmp);\n    }\n\n    this.camera.position.set(this.positionOutTmp2.x, this.positionOutTmp2.y, this.positionOutTmp2.z);\n    this.position.copy(this.camera.position);\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUhQO0FBS0QsS0FORCxNQU1PO0FBQ0wsV0FBS0EsZUFBTCxDQUFxQjVILElBQXJCLENBQTBCLEtBQUswSCxjQUEvQjtBQUNEOztBQUVELFNBQUtoQyxNQUFMLENBQVkvQyxRQUFaLENBQXFCd0UsR0FBckIsQ0FDRSxLQUFLUyxlQUFMLENBQXFCaEYsQ0FEdkIsRUFFRSxLQUFLZ0YsZUFBTCxDQUFxQjNILENBRnZCLEVBR0UsS0FBSzJILGVBQUwsQ0FBcUIvRSxDQUh2QjtBQUtBLFNBQUtGLFFBQUwsQ0FBYzNDLElBQWQsQ0FBbUIsS0FBSzBGLE1BQUwsQ0FBWS9DLFFBQS9CO0FBQ0Q7O0FBM0w2RCIsInNvdXJjZXMiOlsid2VicGFjazovL2F4b2xvdGlzLWNvcmUtcGx1Z2lucy8uL25vZGVfbW9kdWxlcy90aHJlZS1wYXRoZmluZGluZy9kaXN0L3RocmVlLXBhdGhmaW5kaW5nLm1vZHVsZS5qcz9iOTM2Iiwid2VicGFjazovL2F4b2xvdGlzLWNvcmUtcGx1Z2lucy8uL3NyYy9saWIvbW9kdWxlcy9jb250cm9sbGVyL3BhdGhGaW5kaW5nUGxheWVyL05hdk1lc2hQYXRoZmluZGVyLnRzP2YzYjIiLCJ3ZWJwYWNrOi8vYXhvbG90aXMtY29yZS1wbHVnaW5zLy4vc3JjL2xpYi9tb2R1bGVzL2NvbnRyb2xsZXIvcGF0aEZpbmRpbmdQbGF5ZXIvTmF2TWVzaFBsYXllci50cz82N2YwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHtCdWZmZXJBdHRyaWJ1dGUgYXMgdCxCdWZmZXJHZW9tZXRyeSBhcyBlLFZlY3RvcjMgYXMgcixQbGFuZSBhcyBzLFRyaWFuZ2xlIGFzIG4sQ29sb3IgYXMgbyxPYmplY3QzRCBhcyBpLE1lc2ggYXMgaCxTcGhlcmVCdWZmZXJHZW9tZXRyeSBhcyBjLE1lc2hCYXNpY01hdGVyaWFsIGFzIGEsQm94QnVmZmVyR2VvbWV0cnkgYXMgdSxMaW5lQmFzaWNNYXRlcmlhbCBhcyBsLExpbmUgYXMgZH1mcm9tXCJ0aHJlZVwiO2NsYXNzIHB7c3RhdGljIHJvdW5kTnVtYmVyKHQsZSl7Y29uc3Qgcj1NYXRoLnBvdygxMCxlKTtyZXR1cm4gTWF0aC5yb3VuZCh0KnIpL3J9c3RhdGljIHNhbXBsZSh0KXtyZXR1cm4gdFtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdC5sZW5ndGgpXX1zdGF0aWMgZGlzdGFuY2VUb1NxdWFyZWQodCxlKXt2YXIgcj10LngtZS54LHM9dC55LWUueSxuPXQuei1lLno7cmV0dXJuIHIqcitzKnMrbipufXN0YXRpYyBpc1BvaW50SW5Qb2x5KHQsZSl7Zm9yKHZhciByPSExLHM9LTEsbj10Lmxlbmd0aCxvPW4tMTsrK3M8bjtvPXMpKHRbc10uejw9ZS56JiZlLno8dFtvXS56fHx0W29dLno8PWUueiYmZS56PHRbc10ueikmJmUueDwodFtvXS54LXRbc10ueCkqKGUuei10W3NdLnopLyh0W29dLnotdFtzXS56KSt0W3NdLngmJihyPSFyKTtyZXR1cm4gcn1zdGF0aWMgaXNWZWN0b3JJblBvbHlnb24odCxlLHIpe3ZhciBzPTFlNSxuPS0xZTUsbz1bXTtyZXR1cm4gZS52ZXJ0ZXhJZHMuZm9yRWFjaCh0PT57cz1NYXRoLm1pbihyW3RdLnkscyksbj1NYXRoLm1heChyW3RdLnksbiksby5wdXNoKHJbdF0pfSksISEodC55PG4rLjUmJnQueT5zLS41JiZ0aGlzLmlzUG9pbnRJblBvbHkobyx0KSl9c3RhdGljIHRyaWFyZWEyKHQsZSxyKXtyZXR1cm4oci54LXQueCkqKGUuei10LnopLShlLngtdC54KSooci56LXQueil9c3RhdGljIHZlcXVhbCh0LGUpe3JldHVybiB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKHQsZSk8MWUtNX1zdGF0aWMgbWVyZ2VWZXJ0aWNlcyhyLHM9MWUtNCl7cz1NYXRoLm1heChzLE51bWJlci5FUFNJTE9OKTtmb3IodmFyIG49e30sbz1yLmdldEluZGV4KCksaT1yLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpLGg9bz9vLmNvdW50OmkuY291bnQsYz0wLGE9W10sdT1bXSxsPU1hdGgubG9nMTAoMS9zKSxkPU1hdGgucG93KDEwLGwpLHA9MDtwPGg7cCsrKXt2YXIgZz1vP28uZ2V0WChwKTpwLGY9XCJcIjtmKz1+fihpLmdldFgoZykqZCkrXCIsXCIsZis9fn4oaS5nZXRZKGcpKmQpK1wiLFwiLChmKz1+fihpLmdldFooZykqZCkrXCIsXCIpaW4gbj9hLnB1c2gobltmXSk6KHUucHVzaChpLmdldFgoZykpLHUucHVzaChpLmdldFkoZykpLHUucHVzaChpLmdldFooZykpLG5bZl09YyxhLnB1c2goYyksYysrKX1jb25zdCB2PW5ldyB0KG5ldyBGbG9hdDMyQXJyYXkodSksaS5pdGVtU2l6ZSxpLm5vcm1hbGl6ZWQpLGI9bmV3IGU7cmV0dXJuIGIuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIix2KSxiLnNldEluZGV4KGEpLGJ9fWNsYXNzIGd7Y29uc3RydWN0b3IodCl7dGhpcy5jb250ZW50PVtdLHRoaXMuc2NvcmVGdW5jdGlvbj10fXB1c2godCl7dGhpcy5jb250ZW50LnB1c2godCksdGhpcy5zaW5rRG93bih0aGlzLmNvbnRlbnQubGVuZ3RoLTEpfXBvcCgpe2NvbnN0IHQ9dGhpcy5jb250ZW50WzBdLGU9dGhpcy5jb250ZW50LnBvcCgpO3JldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoPjAmJih0aGlzLmNvbnRlbnRbMF09ZSx0aGlzLmJ1YmJsZVVwKDApKSx0fXJlbW92ZSh0KXtjb25zdCBlPXRoaXMuY29udGVudC5pbmRleE9mKHQpLHI9dGhpcy5jb250ZW50LnBvcCgpO2UhPT10aGlzLmNvbnRlbnQubGVuZ3RoLTEmJih0aGlzLmNvbnRlbnRbZV09cix0aGlzLnNjb3JlRnVuY3Rpb24ocik8dGhpcy5zY29yZUZ1bmN0aW9uKHQpP3RoaXMuc2lua0Rvd24oZSk6dGhpcy5idWJibGVVcChlKSl9c2l6ZSgpe3JldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RofXJlc2NvcmVFbGVtZW50KHQpe3RoaXMuc2lua0Rvd24odGhpcy5jb250ZW50LmluZGV4T2YodCkpfXNpbmtEb3duKHQpe2NvbnN0IGU9dGhpcy5jb250ZW50W3RdO2Zvcig7dD4wOyl7Y29uc3Qgcj0odCsxPj4xKS0xLHM9dGhpcy5jb250ZW50W3JdO2lmKCEodGhpcy5zY29yZUZ1bmN0aW9uKGUpPHRoaXMuc2NvcmVGdW5jdGlvbihzKSkpYnJlYWs7dGhpcy5jb250ZW50W3JdPWUsdGhpcy5jb250ZW50W3RdPXMsdD1yfX1idWJibGVVcCh0KXtjb25zdCBlPXRoaXMuY29udGVudC5sZW5ndGgscj10aGlzLmNvbnRlbnRbdF0scz10aGlzLnNjb3JlRnVuY3Rpb24ocik7Zm9yKDs7KXtjb25zdCBuPXQrMTw8MSxvPW4tMTtsZXQgaSxoPW51bGw7aWYobzxlJiYoaT10aGlzLnNjb3JlRnVuY3Rpb24odGhpcy5jb250ZW50W29dKSxpPHMmJihoPW8pKSxuPGUmJnRoaXMuc2NvcmVGdW5jdGlvbih0aGlzLmNvbnRlbnRbbl0pPChudWxsPT09aD9zOmkpJiYoaD1uKSxudWxsPT09aClicmVhazt0aGlzLmNvbnRlbnRbdF09dGhpcy5jb250ZW50W2hdLHRoaXMuY29udGVudFtoXT1yLHQ9aH19fWNsYXNzIGZ7Y29uc3RydWN0b3IoKXt0aGlzLnBvcnRhbHM9W119cHVzaCh0LGUpe3ZvaWQgMD09PWUmJihlPXQpLHRoaXMucG9ydGFscy5wdXNoKHtsZWZ0OnQscmlnaHQ6ZX0pfXN0cmluZ1B1bGwoKXtjb25zdCB0PXRoaXMucG9ydGFscyxlPVtdO2xldCByLHMsbixvPTAsaT0wLGg9MDtyPXRbMF0ubGVmdCxzPXRbMF0ubGVmdCxuPXRbMF0ucmlnaHQsZS5wdXNoKHIpO2ZvcihsZXQgYz0xO2M8dC5sZW5ndGg7YysrKXtjb25zdCBhPXRbY10ubGVmdCx1PXRbY10ucmlnaHQ7aWYocC50cmlhcmVhMihyLG4sdSk8PTApe2lmKCEocC52ZXF1YWwocixuKXx8cC50cmlhcmVhMihyLHMsdSk+MCkpe2UucHVzaChzKSxyPXMsbz1pLHM9cixuPXIsaT1vLGg9byxjPW87Y29udGludWV9bj11LGg9Y31pZihwLnRyaWFyZWEyKHIscyxhKT49MCl7aWYoIShwLnZlcXVhbChyLHMpfHxwLnRyaWFyZWEyKHIsbixhKTwwKSl7ZS5wdXNoKG4pLHI9bixvPWgscz1yLG49cixpPW8saD1vLGM9bztjb250aW51ZX1zPWEsaT1jfX1yZXR1cm4gMCE9PWUubGVuZ3RoJiZwLnZlcXVhbChlW2UubGVuZ3RoLTFdLHRbdC5sZW5ndGgtMV0ubGVmdCl8fGUucHVzaCh0W3QubGVuZ3RoLTFdLmxlZnQpLHRoaXMucGF0aD1lLGV9fWNsYXNzIHZ7Y29uc3RydWN0b3IoKXt0aGlzLnpvbmVzPXt9fXN0YXRpYyBjcmVhdGVab25lKHQsZT0xZS00KXtyZXR1cm4gY2xhc3N7c3RhdGljIGJ1aWxkWm9uZSh0LGUpe2NvbnN0IHM9dGhpcy5fYnVpbGROYXZpZ2F0aW9uTWVzaCh0LGUpLG49e307cy52ZXJ0aWNlcy5mb3JFYWNoKHQ9Pnt0Lng9cC5yb3VuZE51bWJlcih0LngsMiksdC55PXAucm91bmROdW1iZXIodC55LDIpLHQuej1wLnJvdW5kTnVtYmVyKHQueiwyKX0pLG4udmVydGljZXM9cy52ZXJ0aWNlcztjb25zdCBvPXRoaXMuX2J1aWxkUG9seWdvbkdyb3VwcyhzKTtyZXR1cm4gbi5ncm91cHM9bmV3IEFycmF5KG8ubGVuZ3RoKSxvLmZvckVhY2goKHQsZSk9Pntjb25zdCBzPW5ldyBNYXA7dC5mb3JFYWNoKCh0LGUpPT57cy5zZXQodCxlKX0pO2NvbnN0IG89bmV3IEFycmF5KHQubGVuZ3RoKTt0LmZvckVhY2goKHQsZSk9Pntjb25zdCBpPVtdO3QubmVpZ2hib3Vycy5mb3JFYWNoKHQ9PmkucHVzaChzLmdldCh0KSkpO2NvbnN0IGg9W107dC5uZWlnaGJvdXJzLmZvckVhY2goZT0+aC5wdXNoKHRoaXMuX2dldFNoYXJlZFZlcnRpY2VzSW5PcmRlcih0LGUpKSk7Y29uc3QgYz1uZXcgcigwLDAsMCk7Yy5hZGQobi52ZXJ0aWNlc1t0LnZlcnRleElkc1swXV0pLGMuYWRkKG4udmVydGljZXNbdC52ZXJ0ZXhJZHNbMV1dKSxjLmFkZChuLnZlcnRpY2VzW3QudmVydGV4SWRzWzJdXSksYy5kaXZpZGVTY2FsYXIoMyksYy54PXAucm91bmROdW1iZXIoYy54LDIpLGMueT1wLnJvdW5kTnVtYmVyKGMueSwyKSxjLno9cC5yb3VuZE51bWJlcihjLnosMiksb1tlXT17aWQ6ZSxuZWlnaGJvdXJzOmksdmVydGV4SWRzOnQudmVydGV4SWRzLGNlbnRyb2lkOmMscG9ydGFsczpofX0pLG4uZ3JvdXBzW2VdPW99KSxufXN0YXRpYyBfYnVpbGROYXZpZ2F0aW9uTWVzaCh0LGUpe3JldHVybiB0PXAubWVyZ2VWZXJ0aWNlcyh0LGUpLHRoaXMuX2J1aWxkUG9seWdvbnNGcm9tR2VvbWV0cnkodCl9c3RhdGljIF9zcHJlYWRHcm91cElkKHQpe2xldCBlPW5ldyBTZXQoW3RdKTtmb3IoO2Uuc2l6ZT4wOyl7Y29uc3Qgcj1lO2U9bmV3IFNldCxyLmZvckVhY2gocj0+e3IuZ3JvdXA9dC5ncm91cCxyLm5laWdoYm91cnMuZm9yRWFjaCh0PT57dm9pZCAwPT09dC5ncm91cCYmZS5hZGQodCl9KX0pfX1zdGF0aWMgX2J1aWxkUG9seWdvbkdyb3Vwcyh0KXtjb25zdCBlPVtdO3JldHVybiB0LnBvbHlnb25zLmZvckVhY2godD0+e3ZvaWQgMCE9PXQuZ3JvdXA/ZVt0Lmdyb3VwXS5wdXNoKHQpOih0Lmdyb3VwPWUubGVuZ3RoLHRoaXMuX3NwcmVhZEdyb3VwSWQodCksZS5wdXNoKFt0XSkpfSksZX1zdGF0aWMgX2J1aWxkUG9seWdvbk5laWdoYm91cnModCxlKXtjb25zdCByPW5ldyBTZXQscz1lW3QudmVydGV4SWRzWzFdXSxuPWVbdC52ZXJ0ZXhJZHNbMl1dO3JldHVybiBlW3QudmVydGV4SWRzWzBdXS5mb3JFYWNoKGU9PntlIT09dCYmKHMuaW5jbHVkZXMoZSl8fG4uaW5jbHVkZXMoZSkpJiZyLmFkZChlKX0pLHMuZm9yRWFjaChlPT57ZSE9PXQmJm4uaW5jbHVkZXMoZSkmJnIuYWRkKGUpfSkscn1zdGF0aWMgX2J1aWxkUG9seWdvbnNGcm9tR2VvbWV0cnkodCl7Y29uc3QgZT1bXSxzPVtdLG49dC5hdHRyaWJ1dGVzLnBvc2l0aW9uLG89dC5pbmRleCxpPVtdO2ZvcihsZXQgdD0wO3Q8bi5jb3VudDt0Kyspcy5wdXNoKChuZXcgcikuZnJvbUJ1ZmZlckF0dHJpYnV0ZShuLHQpKSxpW3RdPVtdO2ZvcihsZXQgcj0wO3I8dC5pbmRleC5jb3VudDtyKz0zKXtjb25zdCB0PW8uZ2V0WChyKSxzPW8uZ2V0WChyKzEpLG49by5nZXRYKHIrMiksaD17dmVydGV4SWRzOlt0LHMsbl0sbmVpZ2hib3VyczpudWxsfTtlLnB1c2goaCksaVt0XS5wdXNoKGgpLGlbc10ucHVzaChoKSxpW25dLnB1c2goaCl9cmV0dXJuIGUuZm9yRWFjaCh0PT57dC5uZWlnaGJvdXJzPXRoaXMuX2J1aWxkUG9seWdvbk5laWdoYm91cnModCxpKX0pLHtwb2x5Z29uczplLHZlcnRpY2VzOnN9fXN0YXRpYyBfZ2V0U2hhcmVkVmVydGljZXNJbk9yZGVyKHQsZSl7Y29uc3Qgcj10LnZlcnRleElkcyxzPXJbMF0sbj1yWzFdLG89clsyXSxpPWUudmVydGV4SWRzLGg9aS5pbmNsdWRlcyhzKSxjPWkuaW5jbHVkZXMobiksYT1pLmluY2x1ZGVzKG8pO3JldHVybiBoJiZjJiZhP0FycmF5LmZyb20ocik6aCYmYz9bcyxuXTpjJiZhP1tuLG9dOmgmJmE/W28sc106KGNvbnNvbGUud2FybihcIkVycm9yIHByb2Nlc3NpbmcgbmF2aWdhdGlvbiBtZXNoIG5laWdoYm9yczsgbmVpZ2hib3JzIHdpdGggPDIgc2hhcmVkIHZlcnRpY2VzIGZvdW5kLlwiKSxbXSl9fS5idWlsZFpvbmUodCxlKX1zZXRab25lRGF0YSh0LGUpe3RoaXMuem9uZXNbdF09ZX1nZXRSYW5kb21Ob2RlKHQsZSxzLG4pe2lmKCF0aGlzLnpvbmVzW3RdKXJldHVybiBuZXcgcjtzPXN8fG51bGwsbj1ufHwwO2NvbnN0IG89W107cmV0dXJuIHRoaXMuem9uZXNbdF0uZ3JvdXBzW2VdLmZvckVhY2godD0+e3MmJm4/cC5kaXN0YW5jZVRvU3F1YXJlZChzLHQuY2VudHJvaWQpPG4qbiYmby5wdXNoKHQuY2VudHJvaWQpOm8ucHVzaCh0LmNlbnRyb2lkKX0pLHAuc2FtcGxlKG8pfHxuZXcgcn1nZXRDbG9zZXN0Tm9kZSh0LGUscixzPSExKXtjb25zdCBuPXRoaXMuem9uZXNbZV0udmVydGljZXM7bGV0IG89bnVsbCxpPUluZmluaXR5O3JldHVybiB0aGlzLnpvbmVzW2VdLmdyb3Vwc1tyXS5mb3JFYWNoKGU9Pntjb25zdCByPXAuZGlzdGFuY2VUb1NxdWFyZWQoZS5jZW50cm9pZCx0KTtyPGkmJighc3x8cC5pc1ZlY3RvckluUG9seWdvbih0LGUsbikpJiYobz1lLGk9cil9KSxvfWZpbmRQYXRoKHQsZSxzLG4pe2NvbnN0IG89dGhpcy56b25lc1tzXS5ncm91cHNbbl0saT10aGlzLnpvbmVzW3NdLnZlcnRpY2VzLGg9dGhpcy5nZXRDbG9zZXN0Tm9kZSh0LHMsbiwhMCksYz10aGlzLmdldENsb3Nlc3ROb2RlKGUscyxuLCEwKTtpZighaHx8IWMpcmV0dXJuIG51bGw7Y29uc3QgYT1jbGFzc3tzdGF0aWMgaW5pdCh0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgcj10W2VdO3IuZj0wLHIuZz0wLHIuaD0wLHIuY29zdD0xLHIudmlzaXRlZD0hMSxyLmNsb3NlZD0hMSxyLnBhcmVudD1udWxsfX1zdGF0aWMgY2xlYW5VcCh0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgcj10W2VdO2RlbGV0ZSByLmYsZGVsZXRlIHIuZyxkZWxldGUgci5oLGRlbGV0ZSByLmNvc3QsZGVsZXRlIHIudmlzaXRlZCxkZWxldGUgci5jbG9zZWQsZGVsZXRlIHIucGFyZW50fX1zdGF0aWMgaGVhcCgpe3JldHVybiBuZXcgZyhmdW5jdGlvbih0KXtyZXR1cm4gdC5mfSl9c3RhdGljIHNlYXJjaCh0LGUscil7dGhpcy5pbml0KHQpO2NvbnN0IHM9dGhpcy5oZWFwKCk7Zm9yKHMucHVzaChlKTtzLnNpemUoKT4wOyl7Y29uc3QgZT1zLnBvcCgpO2lmKGU9PT1yKXtsZXQgdD1lO2NvbnN0IHI9W107Zm9yKDt0LnBhcmVudDspci5wdXNoKHQpLHQ9dC5wYXJlbnQ7cmV0dXJuIHRoaXMuY2xlYW5VcChyKSxyLnJldmVyc2UoKX1lLmNsb3NlZD0hMDtjb25zdCBuPXRoaXMubmVpZ2hib3Vycyh0LGUpO2ZvcihsZXQgdD0wLG89bi5sZW5ndGg7dDxvO3QrKyl7Y29uc3Qgbz1uW3RdO2lmKG8uY2xvc2VkKWNvbnRpbnVlO2NvbnN0IGk9ZS5nK28uY29zdCxoPW8udmlzaXRlZDtpZighaHx8aTxvLmcpe2lmKG8udmlzaXRlZD0hMCxvLnBhcmVudD1lLCFvLmNlbnRyb2lkfHwhci5jZW50cm9pZCl0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHN0YXRlXCIpO28uaD1vLmh8fHRoaXMuaGV1cmlzdGljKG8uY2VudHJvaWQsci5jZW50cm9pZCksby5nPWksby5mPW8uZytvLmgsaD9zLnJlc2NvcmVFbGVtZW50KG8pOnMucHVzaChvKX19fXJldHVybltdfXN0YXRpYyBoZXVyaXN0aWModCxlKXtyZXR1cm4gcC5kaXN0YW5jZVRvU3F1YXJlZCh0LGUpfXN0YXRpYyBuZWlnaGJvdXJzKHQsZSl7Y29uc3Qgcj1bXTtmb3IobGV0IHM9MDtzPGUubmVpZ2hib3Vycy5sZW5ndGg7cysrKXIucHVzaCh0W2UubmVpZ2hib3Vyc1tzXV0pO3JldHVybiByfX0uc2VhcmNoKG8saCxjKSx1PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPTA7cjx0Lm5laWdoYm91cnMubGVuZ3RoO3IrKylpZih0Lm5laWdoYm91cnNbcl09PT1lLmlkKXJldHVybiB0LnBvcnRhbHNbcl19LGw9bmV3IGY7bC5wdXNoKHQpO2ZvcihsZXQgdD0wO3Q8YS5sZW5ndGg7dCsrKXtjb25zdCBlPWFbdF0scj1hW3QrMV07aWYocil7Y29uc3QgdD11KGUscik7bC5wdXNoKGlbdFswXV0saVt0WzFdXSl9fWwucHVzaChlKSxsLnN0cmluZ1B1bGwoKTtjb25zdCBkPWwucGF0aC5tYXAodD0+bmV3IHIodC54LHQueSx0LnopKTtyZXR1cm4gZC5zaGlmdCgpLGR9fXYucHJvdG90eXBlLmdldEdyb3VwPWZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgcztyZXR1cm4gZnVuY3Rpb24oZSxyLHM9ITEpe2lmKCF0aGlzLnpvbmVzW2VdKXJldHVybiBudWxsO2xldCBuPW51bGwsbz1NYXRoLnBvdyg1MCwyKTtjb25zdCBpPXRoaXMuem9uZXNbZV07Zm9yKGxldCBlPTA7ZTxpLmdyb3Vwcy5sZW5ndGg7ZSsrKXtjb25zdCBoPWkuZ3JvdXBzW2VdO2Zvcihjb25zdCBjIG9mIGgpe2lmKHMmJih0LnNldEZyb21Db3BsYW5hclBvaW50cyhpLnZlcnRpY2VzW2MudmVydGV4SWRzWzBdXSxpLnZlcnRpY2VzW2MudmVydGV4SWRzWzFdXSxpLnZlcnRpY2VzW2MudmVydGV4SWRzWzJdXSksTWF0aC5hYnModC5kaXN0YW5jZVRvUG9pbnQocikpPC4wMSkmJnAuaXNQb2ludEluUG9seShbaS52ZXJ0aWNlc1tjLnZlcnRleElkc1swXV0saS52ZXJ0aWNlc1tjLnZlcnRleElkc1sxXV0saS52ZXJ0aWNlc1tjLnZlcnRleElkc1syXV1dLHIpKXJldHVybiBlO2NvbnN0IGg9cC5kaXN0YW5jZVRvU3F1YXJlZChjLmNlbnRyb2lkLHIpO2g8byYmKG49ZSxvPWgpfX1yZXR1cm4gbn19KCksdi5wcm90b3R5cGUuY2xhbXBTdGVwPWZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgcixlPW5ldyBzLG89bmV3IG4saT1uZXcgcjtsZXQgaCxjLGE9bmV3IHI7cmV0dXJuIGZ1bmN0aW9uKHIscyxuLHUsbCxkKXtjb25zdCBwPXRoaXMuem9uZXNbdV0udmVydGljZXMsZz10aGlzLnpvbmVzW3VdLmdyb3Vwc1tsXSxmPVtuXSx2PXt9O3Zbbi5pZF09MCxoPXZvaWQgMCxhLnNldCgwLDAsMCksYz1JbmZpbml0eSxlLnNldEZyb21Db3BsYW5hclBvaW50cyhwW24udmVydGV4SWRzWzBdXSxwW24udmVydGV4SWRzWzFdXSxwW24udmVydGV4SWRzWzJdXSksZS5wcm9qZWN0UG9pbnQocyx0KSxpLmNvcHkodCk7Zm9yKGxldCBlPWYucG9wKCk7ZTtlPWYucG9wKCkpe28uc2V0KHBbZS52ZXJ0ZXhJZHNbMF1dLHBbZS52ZXJ0ZXhJZHNbMV1dLHBbZS52ZXJ0ZXhJZHNbMl1dKSxvLmNsb3Nlc3RQb2ludFRvUG9pbnQoaSx0KSx0LmRpc3RhbmNlVG9TcXVhcmVkKGkpPGMmJihoPWUsYS5jb3B5KHQpLGM9dC5kaXN0YW5jZVRvU3F1YXJlZChpKSk7Y29uc3Qgcj12W2UuaWRdO2lmKCEocj4yKSlmb3IobGV0IHQ9MDt0PGUubmVpZ2hib3Vycy5sZW5ndGg7dCsrKXtjb25zdCBzPWdbZS5uZWlnaGJvdXJzW3RdXTtzLmlkIGluIHZ8fChmLnB1c2gocyksdltzLmlkXT1yKzEpfX1yZXR1cm4gZC5jb3B5KGEpLGh9fSgpO2NvbnN0IGI9e1BMQVlFUjpuZXcgbygxNTYzMTIxNSkuY29udmVydFNSR0JUb0xpbmVhcigpLmdldEhleCgpLFRBUkdFVDpuZXcgbygxNDQ2OTkxMikuY29udmVydFNSR0JUb0xpbmVhcigpLmdldEhleCgpLFBBVEg6bmV3IG8oNDE5MDMpLmNvbnZlcnRTUkdCVG9MaW5lYXIoKS5nZXRIZXgoKSxXQVlQT0lOVDpuZXcgbyg0MTkwMykuY29udmVydFNSR0JUb0xpbmVhcigpLmdldEhleCgpLENMQU1QRURfU1RFUDpuZXcgbygxNDQ3MjExNCkuY29udmVydFNSR0JUb0xpbmVhcigpLmdldEhleCgpLENMT1NFU1RfTk9ERTpuZXcgbyg0NDE3Mzg3KS5jb252ZXJ0U1JHQlRvTGluZWFyKCkuZ2V0SGV4KCl9O2NsYXNzIHcgZXh0ZW5kcyBpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLl9wbGF5ZXJNYXJrZXI9bmV3IGgobmV3IGMoLjI1LDMyLDMyKSxuZXcgYSh7Y29sb3I6Yi5QTEFZRVJ9KSksdGhpcy5fdGFyZ2V0TWFya2VyPW5ldyBoKG5ldyB1KC4zLC4zLC4zKSxuZXcgYSh7Y29sb3I6Yi5UQVJHRVR9KSksdGhpcy5fbm9kZU1hcmtlcj1uZXcgaChuZXcgdSguMSwuOCwuMSksbmV3IGEoe2NvbG9yOmIuQ0xPU0VTVF9OT0RFfSkpLHRoaXMuX3N0ZXBNYXJrZXI9bmV3IGgobmV3IHUoLjEsMSwuMSksbmV3IGEoe2NvbG9yOmIuQ0xBTVBFRF9TVEVQfSkpLHRoaXMuX3BhdGhNYXJrZXI9bmV3IGksdGhpcy5fcGF0aExpbmVNYXRlcmlhbD1uZXcgbCh7Y29sb3I6Yi5QQVRILGxpbmV3aWR0aDoyfSksdGhpcy5fcGF0aFBvaW50TWF0ZXJpYWw9bmV3IGEoe2NvbG9yOmIuV0FZUE9JTlR9KSx0aGlzLl9wYXRoUG9pbnRHZW9tZXRyeT1uZXcgYyguMDgpLHRoaXMuX21hcmtlcnM9W3RoaXMuX3BsYXllck1hcmtlcix0aGlzLl90YXJnZXRNYXJrZXIsdGhpcy5fbm9kZU1hcmtlcix0aGlzLl9zdGVwTWFya2VyLHRoaXMuX3BhdGhNYXJrZXJdLHRoaXMuX21hcmtlcnMuZm9yRWFjaCh0PT57dC52aXNpYmxlPSExLHRoaXMuYWRkKHQpfSl9c2V0UGF0aChyKXtmb3IoO3RoaXMuX3BhdGhNYXJrZXIuY2hpbGRyZW4ubGVuZ3RoOyl0aGlzLl9wYXRoTWFya2VyLmNoaWxkcmVuWzBdLnZpc2libGU9ITEsdGhpcy5fcGF0aE1hcmtlci5yZW1vdmUodGhpcy5fcGF0aE1hcmtlci5jaGlsZHJlblswXSk7cj1bdGhpcy5fcGxheWVyTWFya2VyLnBvc2l0aW9uXS5jb25jYXQocik7Y29uc3Qgcz1uZXcgZTtzLnNldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsbmV3IHQobmV3IEZsb2F0MzJBcnJheSgzKnIubGVuZ3RoKSwzKSk7Zm9yKGxldCB0PTA7dDxyLmxlbmd0aDt0Kyspcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLnNldFhZWih0LHJbdF0ueCxyW3RdLnkrLjIsclt0XS56KTt0aGlzLl9wYXRoTWFya2VyLmFkZChuZXcgZChzLHRoaXMuX3BhdGhMaW5lTWF0ZXJpYWwpKTtmb3IobGV0IHQ9MDt0PHIubGVuZ3RoLTE7dCsrKXtjb25zdCBlPW5ldyBoKHRoaXMuX3BhdGhQb2ludEdlb21ldHJ5LHRoaXMuX3BhdGhQb2ludE1hdGVyaWFsKTtlLnBvc2l0aW9uLmNvcHkoclt0XSksZS5wb3NpdGlvbi55Kz0uMix0aGlzLl9wYXRoTWFya2VyLmFkZChlKX1yZXR1cm4gdGhpcy5fcGF0aE1hcmtlci52aXNpYmxlPSEwLHRoaXN9c2V0UGxheWVyUG9zaXRpb24odCl7cmV0dXJuIHRoaXMuX3BsYXllck1hcmtlci5wb3NpdGlvbi5jb3B5KHQpLHRoaXMuX3BsYXllck1hcmtlci52aXNpYmxlPSEwLHRoaXN9c2V0VGFyZ2V0UG9zaXRpb24odCl7cmV0dXJuIHRoaXMuX3RhcmdldE1hcmtlci5wb3NpdGlvbi5jb3B5KHQpLHRoaXMuX3RhcmdldE1hcmtlci52aXNpYmxlPSEwLHRoaXN9c2V0Tm9kZVBvc2l0aW9uKHQpe3JldHVybiB0aGlzLl9ub2RlTWFya2VyLnBvc2l0aW9uLmNvcHkodCksdGhpcy5fbm9kZU1hcmtlci52aXNpYmxlPSEwLHRoaXN9c2V0U3RlcFBvc2l0aW9uKHQpe3JldHVybiB0aGlzLl9zdGVwTWFya2VyLnBvc2l0aW9uLmNvcHkodCksdGhpcy5fc3RlcE1hcmtlci52aXNpYmxlPSEwLHRoaXN9cmVzZXQoKXtmb3IoO3RoaXMuX3BhdGhNYXJrZXIuY2hpbGRyZW4ubGVuZ3RoOyl0aGlzLl9wYXRoTWFya2VyLmNoaWxkcmVuWzBdLnZpc2libGU9ITEsdGhpcy5fcGF0aE1hcmtlci5yZW1vdmUodGhpcy5fcGF0aE1hcmtlci5jaGlsZHJlblswXSk7cmV0dXJuIHRoaXMuX21hcmtlcnMuZm9yRWFjaCh0PT57dC52aXNpYmxlPSExfSksdGhpc319ZXhwb3J0e3YgYXMgUGF0aGZpbmRpbmcsdyBhcyBQYXRoZmluZGluZ0hlbHBlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJlZS1wYXRoZmluZGluZy5tb2R1bGUuanMubWFwXG4iLCJpbXBvcnQgeyBQYXRoZmluZGluZyB9IGZyb20gXCJ0aHJlZS1wYXRoZmluZGluZ1wiO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCI7XG5cbmV4cG9ydCBjbGFzcyBOYXZNZXNoUGF0aGZpbmRlciB7XG4gIHByaXZhdGUgcGF0aGZpbmRlcjogUGF0aGZpbmRpbmc7XG4gIHByaXZhdGUgbWVzaDogYW55O1xuICBwcml2YXRlIHpvbmU6IHN0cmluZyA9IFwiY2hhcmFjdGVyXCI7XG4gIHByaXZhdGUgbmF2R3JvdXA6IGFueSA9IG51bGw7XG4gIHByaXZhdGUgbmF2Tm9kZTogYW55ID0gbnVsbDtcblxuICBpc0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucGF0aGZpbmRlciAmJiB0aGlzLnpvbmUgaW4gdGhpcy5wYXRoZmluZGVyLnpvbmVzO1xuICB9XG5cbiAgbG9hZE1lc2gobWVzaCwgem9uZTogc3RyaW5nID0gdGhpcy56b25lKSB7XG4gICAgdGhpcy5wYXRoZmluZGVyID0gbmV3IFBhdGhmaW5kaW5nKCk7XG4gICAgdGhpcy5tZXNoID0gbnVsbDtcbiAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJ0cmllZCB0byBsb2FkIG11bHRpcGxlIG5hdiBtZXNoZXNcIik7XG4gICAgICB0aGlzLnJlbW92ZU5hdk1lc2hEYXRhKCk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcbiAgICBnZW9tZXRyeS5hcHBseU1hdHJpeDQobWVzaC5tYXRyaXhXb3JsZCk7XG4gICAgdGhpcy5wYXRoZmluZGVyLnNldFpvbmVEYXRhKHpvbmUsIFBhdGhmaW5kaW5nLmNyZWF0ZVpvbmUoZ2VvbWV0cnkpKTtcbiAgICB0aGlzLm1lc2ggPSBtZXNoO1xuICB9XG5cbiAgZ2V0Q2xvc2VzdE5vZGUocG9zKSB7XG4gICAgY29uc3QgcGF0aGZpbmRlciA9IHRoaXMucGF0aGZpbmRlcjtcbiAgICBpZiAoIXBhdGhmaW5kZXIuem9uZXNbdGhpcy56b25lXS5ncm91cHNbdGhpcy5uYXZHcm91cF0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgcGF0aGZpbmRlci5nZXRDbG9zZXN0Tm9kZShwb3MsIHRoaXMuem9uZSwgdGhpcy5uYXZHcm91cCwgdHJ1ZSkgfHxcbiAgICAgIHBhdGhmaW5kZXIuZ2V0Q2xvc2VzdE5vZGUocG9zLCB0aGlzLnpvbmUsIHRoaXMubmF2R3JvdXApXG4gICAgKTtcbiAgfVxuXG4gIGZpbmRQT1ZQb3NpdGlvbkFib3ZlTmF2TWVzaCA9ICgoKSA9PiB7XG4gICAgY29uc3Qgc3RhcnRpbmdGZWV0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNvbnN0IGRlc2lyZWRGZWV0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIC8vIFRPRE86IEhlcmUgd2UgYXNzdW1lIHRoZSBwbGF5ZXIgaXMgc3RhbmRpbmcgc3RyYWlnaHQgdXAsIGJ1dCBpbiBWUiBpdCBpcyBvZnRlbiB0aGUgY2FzZVxuICAgIC8vIHRoYXQgeW91IHdhbnQgdG8gbGVhbiBvdmVyIHRoZSBlZGdlIG9mIGEgYmFsY29ueS90YWJsZSB0aGF0IGRvZXMgbm90IGhhdmUgbmF2IG1lc2ggYmVsb3cuXG4gICAgLy8gV2Ugc2hvdWxkIGZpbmQgd2F5IHRvIGFsbG93IGxlYW5pbmcgb3ZlciB0aGUgZWRnZSBvZiBhIGJhbGNvbnkgYW5kIG1heWJlIGRpc2FsbG93IHB1dHRpbmdcbiAgICAvLyB5b3VyIGhlYWQgdGhyb3VnaCBhIHdhbGwuXG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXJ0UE9WUG9zaXRpb246IFRIUkVFLlZlY3RvcjMsXG4gICAgICBkZXNpcmVkUE9WUG9zaXRpb246IFRIUkVFLlZlY3RvcjMsXG4gICAgICBvdXRQT1ZQb3NpdGlvbjogVEhSRUUuVmVjdG9yM1xuICAgICkgPT4ge1xuICAgICAgLy9jb25zdCBwbGF5ZXJIZWlnaHQgPSBnZXRDdXJyZW50UGxheWVySGVpZ2h0KHRydWUpO1xuICAgICAgY29uc3QgcGxheWVySGVpZ2h0ID0gMjtcbiAgICAgIHN0YXJ0aW5nRmVldFBvc2l0aW9uLmNvcHkoc3RhcnRQT1ZQb3NpdGlvbik7XG4gICAgICBzdGFydGluZ0ZlZXRQb3NpdGlvbi55IC09IHBsYXllckhlaWdodDtcbiAgICAgIGRlc2lyZWRGZWV0UG9zaXRpb24uY29weShkZXNpcmVkUE9WUG9zaXRpb24pO1xuICAgICAgZGVzaXJlZEZlZXRQb3NpdGlvbi55IC09IHBsYXllckhlaWdodDtcbiAgICAgIHRoaXMuZmluZFBvc2l0aW9uT25OYXZNZXNoKFxuICAgICAgICBzdGFydGluZ0ZlZXRQb3NpdGlvbixcbiAgICAgICAgZGVzaXJlZEZlZXRQb3NpdGlvbixcbiAgICAgICAgb3V0UE9WUG9zaXRpb25cbiAgICAgICk7XG4gICAgICBvdXRQT1ZQb3NpdGlvbi55ICs9IHBsYXllckhlaWdodDtcbiAgICAgIHJldHVybiBvdXRQT1ZQb3NpdGlvbjtcbiAgICB9O1xuICB9KSgpO1xuXG4gIGZpbmRQb3NpdGlvbk9uTmF2TWVzaChcbiAgICBzdGFydDogVmVjdG9yMyxcbiAgICBlbmQ6IFZlY3RvcjMsXG4gICAgb3V0UG9zOiBWZWN0b3IzLFxuICAgIHNob3VsZFJlY29tcHV0ZUdyb3VwQW5kTm9kZTogYm9vbGVhbiA9IGZhbHNlXG4gICkge1xuICAgIGNvbnN0IHBhdGhmaW5kZXIgPSB0aGlzLnBhdGhmaW5kZXI7XG4gICAgaWYgKCEodGhpcy56b25lIGluIHBhdGhmaW5kZXIuem9uZXMpKSByZXR1cm47XG4gICAgdGhpcy5uYXZHcm91cCA9XG4gICAgICBzaG91bGRSZWNvbXB1dGVHcm91cEFuZE5vZGUgfHwgdGhpcy5uYXZHcm91cCA9PT0gbnVsbFxuICAgICAgICA/IHBhdGhmaW5kZXIuZ2V0R3JvdXAodGhpcy56b25lLCBlbmQsIHRydWUsIHRydWUpXG4gICAgICAgIDogdGhpcy5uYXZHcm91cDtcbiAgICB0aGlzLm5hdk5vZGUgPVxuICAgICAgc2hvdWxkUmVjb21wdXRlR3JvdXBBbmROb2RlIHx8XG4gICAgICB0aGlzLm5hdk5vZGUgPT09IG51bGwgfHxcbiAgICAgIHRoaXMubmF2Tm9kZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdGhpcy5nZXRDbG9zZXN0Tm9kZShlbmQpXG4gICAgICAgIDogdGhpcy5uYXZOb2RlO1xuICAgIGlmICh0aGlzLm5hdk5vZGUgPT09IG51bGwgfHwgdGhpcy5uYXZOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoaXMubmF2Tm9kZSBjYW4gYmUgbnVsbCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzZXQgb3IgaWYgZ2V0Q2xvc2VzdE5vZGUgZmFpbHMsXG4gICAgICAvLyBhbmQgaXQgY2FuIGJlIHVuZGVmaW5lZCBpZiBjbGFtcFN0ZXAgZmFpbHMsIHNvIHdlIGhhdmUgdG8gY2hlY2sgYm90aC4gV2UgZG8gbm90XG4gICAgICAvLyBzaW1wbHkgY2hlY2sgaWYgaXQgaXMgZmFsc2V5ICghdGhpcy5uYXZOb2RlKSwgYmVjYXVzZSAwICh6ZXJvKSBpcyBhIHZhbGlkIHZhbHVlLFxuICAgICAgLy8gYW5kIDAgaXMgZmFsc2V5LlxuICAgICAgb3V0UG9zLmNvcHkoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYXZOb2RlID0gcGF0aGZpbmRlci5jbGFtcFN0ZXAoXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQsXG4gICAgICAgIHRoaXMubmF2Tm9kZSxcbiAgICAgICAgdGhpcy56b25lLFxuICAgICAgICB0aGlzLm5hdkdyb3VwLFxuICAgICAgICBvdXRQb3NcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBvdXRQb3M7XG4gIH1cblxuICAvKmZpbmRQb3NpdGlvbk9uTmF2TWVzaChcbiAgICBzdGFydDogVmVjdG9yMyxcbiAgICBlbmQ6IFZlY3RvcjMsXG4gICAgb3V0UG9zOiBWZWN0b3IzLFxuICAgIHNob3VsZFJlY29tcHV0ZUdyb3VwQW5kTm9kZTogYm9vbGVhbiA9IGZhbHNlXG4gICkge1xuICAgIGNvbnN0IHBhdGhmaW5kZXIgPSB0aGlzLnBhdGhmaW5kZXI7XG4gICAgaWYgKCEodGhpcy56b25lIGluIHBhdGhmaW5kZXIuem9uZXMpKSByZXR1cm47XG4gICAgdGhpcy5uYXZHcm91cCA9XG4gICAgICBzaG91bGRSZWNvbXB1dGVHcm91cEFuZE5vZGUgfHwgdGhpcy5uYXZHcm91cCA9PT0gbnVsbFxuICAgICAgICA/IHBhdGhmaW5kZXIuZ2V0R3JvdXAodGhpcy56b25lLCBlbmQsIHRydWUsIHRydWUpXG4gICAgICAgIDogdGhpcy5uYXZHcm91cDtcbiAgICB0aGlzLm5hdk5vZGUgPVxuICAgICAgc2hvdWxkUmVjb21wdXRlR3JvdXBBbmROb2RlIHx8XG4gICAgICB0aGlzLm5hdk5vZGUgPT09IG51bGwgfHxcbiAgICAgIHRoaXMubmF2Tm9kZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdGhpcy5nZXRDbG9zZXN0Tm9kZShlbmQpXG4gICAgICAgIDogdGhpcy5uYXZOb2RlO1xuICAgIGlmICh0aGlzLm5hdk5vZGUgPT09IG51bGwgfHwgdGhpcy5uYXZOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoaXMubmF2Tm9kZSBjYW4gYmUgbnVsbCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzZXQgb3IgaWYgZ2V0Q2xvc2VzdE5vZGUgZmFpbHMsXG4gICAgICAvLyBhbmQgaXQgY2FuIGJlIHVuZGVmaW5lZCBpZiBjbGFtcFN0ZXAgZmFpbHMsIHNvIHdlIGhhdmUgdG8gY2hlY2sgYm90aC4gV2UgZG8gbm90XG4gICAgICAvLyBzaW1wbHkgY2hlY2sgaWYgaXQgaXMgZmFsc2V5ICghdGhpcy5uYXZOb2RlKSwgYmVjYXVzZSAwICh6ZXJvKSBpcyBhIHZhbGlkIHZhbHVlLFxuICAgICAgLy8gYW5kIDAgaXMgZmFsc2V5LlxuICAgICAgb3V0UG9zLmNvcHkoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5uYXZOb2RlID0gcGF0aGZpbmRlci5jbGFtcFN0ZXAoXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgZW5kLFxuICAgICAgICAgIHRoaXMubmF2Tm9kZSxcbiAgICAgICAgICB0aGlzLnpvbmUsXG4gICAgICAgICAgdGhpcy5uYXZHcm91cCxcbiAgICAgICAgICBvdXRQb3NcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgb3V0UG9zLmNvcHkoc3RhcnQpO1xuICAgICAgICB0aGlzLm5hdk5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm5hdkdyb3VwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dFBvcztcbiAgfSovXG5cbiAgcmVtb3ZlTmF2TWVzaERhdGEoKSB7XG4gICAgaWYgKHRoaXMubWVzaCAmJiB0aGlzLm1lc2guZ2VvbWV0cnkgJiYgdGhpcy5tZXNoLmdlb21ldHJ5LmRpc3Bvc2UpIHtcbiAgICAgIHRoaXMubWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHRoaXMubWVzaCA9IG51bGw7XG4gICAgdGhpcy5wYXRoZmluZGVyLnpvbmVzID0ge307XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgRXVsZXIsIFF1YXRlcm5pb24sIFZlY3RvcjMgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IEZyYW1lTG9vcCB9IGZyb20gXCJAYXB0ZXJvL2F4b2xvdGlzLXBsYXllci9idWlsZC90eXBlcy9tb2R1bGVzL0ZyYW1lTG9vcFwiO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGFwdGVyby9heG9sb3Rpcy1wbGF5ZXIvYnVpbGQvdHlwZXMvbW9kdWxlcy9jb3JlL2Vjcy9Db21wb25lbnRcIjtcbmltcG9ydCB7IFdlYnBhY2tMYXp5TW9kdWxlIH0gZnJvbSBcIkBhcHRlcm8vYXhvbG90aXMtcGxheWVyL2J1aWxkL3R5cGVzL21vZHVsZXMvY29yZS9sb2FkZXIvV2VicGFja0xvYWRlclwiO1xuaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCJAYXB0ZXJvL2F4b2xvdGlzLXBsYXllci9idWlsZC90eXBlcy9tb2R1bGVzL2NvcmUvZWNzL0NvbXBvbmVudEZhY3RvcnlcIjtcbmltcG9ydCB7IFdvcmxkRW50aXR5IH0gZnJvbSBcIkBhcHRlcm8vYXhvbG90aXMtcGxheWVyL2J1aWxkL3R5cGVzL21vZHVsZXMvY29yZS9lY3MvV29ybGRFbnRpdHlcIjtcbi8vaW1wb3J0IHsgU2VydmljZUVudGl0eSB9IGZyb20gXCJAYXB0ZXJvL2F4b2xvdGlzLXBsYXllci9idWlsZC90eXBlcy9tb2R1bGVzL2NvcmUvc2VydmljZS9TZXJ2aWNlRW50aXR5XCI7XG5pbXBvcnQgeyBTZXJ2aWNlRW50aXR5IH0gZnJvbSBcIkBhcHRlcm8vYXhvbG90aXMtcGxheWVyXCI7XG5pbXBvcnQgeyBUaHJlZUxpYiB9IGZyb20gXCJAcm9vdC9saWIvbW9kdWxlcy90aHJlZS9UaHJlZUxpYlwiO1xuaW1wb3J0IHsgSW5wdXQgfSBmcm9tIFwiQHJvb3QvbGliL21vZHVsZXMvY29udHJvbGxlci9wYXRoRmluZGluZ1BsYXllci9JbnB1dFwiO1xuaW1wb3J0IHtcbiAgUGxheWVyLFxuICBQbGF5ZXJTZXJ2aWNlLFxufSBmcm9tIFwiQHJvb3QvbGliL21vZHVsZXMvY29udHJvbGxlci9QbGF5ZXJTZXJ2aWNlXCI7XG5pbXBvcnQgeyBOYXZNZXNoUGF0aGZpbmRlciB9IGZyb20gXCJAcm9vdC9saWIvbW9kdWxlcy9jb250cm9sbGVyL3BhdGhGaW5kaW5nUGxheWVyL05hdk1lc2hQYXRoZmluZGVyXCI7XG5cbmV4cG9ydCBjbGFzcyBGYWN0b3J5XG4gIGltcGxlbWVudHMgV2VicGFja0xhenlNb2R1bGUsIENvbXBvbmVudEZhY3Rvcnk8TmF2TWVzaFBsYXllcj5cbntcbiAgYXN5bmMgY3JlYXRlQ29tcG9uZW50KFxuICAgIHdvcmxkOiBXb3JsZEVudGl0eSxcbiAgICBjb25maWc6IGFueVxuICApOiBQcm9taXNlPE5hdk1lc2hQbGF5ZXI+IHtcbiAgICBsZXQgc2VydmljZXMgPSB3b3JsZC5nZXRGaXJzdENvbXBvbmVudEJ5VHlwZTxTZXJ2aWNlRW50aXR5PihcbiAgICAgIFNlcnZpY2VFbnRpdHkubmFtZVxuICAgICk7XG4gICAgbGV0IHRocmVlID0gYXdhaXQgc2VydmljZXMuZ2V0U2VydmljZTxUaHJlZUxpYj4oXG4gICAgICBcIkBhcHRlcm8vYXhvbG90aXMtY29yZS1wbHVnaW5zL21vZHVsZXMvdGhyZWUvVGhyZWVMaWJcIlxuICAgICk7XG4gICAgbGV0IGlucHV0ID0gYXdhaXQgc2VydmljZXMuZ2V0U2VydmljZTxJbnB1dD4oXG4gICAgICBcIkBhcHRlcm8vYXhvbG90aXMtY29yZS1wbHVnaW5zL21vZHVsZXMvY29udHJvbGxlci9wYXRoRmluZGluZ1BsYXllci9JbnB1dFwiXG4gICAgKTtcbiAgICBsZXQgcGxheWVyU2VydmljZSA9IGF3YWl0IHNlcnZpY2VzLmdldFNlcnZpY2U8UGxheWVyU2VydmljZT4oXG4gICAgICBcIkBhcHRlcm8vYXhvbG90aXMtY29yZS1wbHVnaW5zL21vZHVsZXMvY29udHJvbGxlci9QbGF5ZXJTZXJ2aWNlXCJcbiAgICApO1xuICAgIGxldCBmcmFtZUxvb3AgPSBhd2FpdCBzZXJ2aWNlcy5nZXRTZXJ2aWNlPEZyYW1lTG9vcD4oXG4gICAgICBcIkBhcHRlcm8vYXhvbG90aXMtcGxheWVyL21vZHVsZXMvRnJhbWVMb29wXCJcbiAgICApO1xuICAgIC8vbGV0IHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMi4xNCwgMS40OCwgLTEuMzYpO1xuICAgIC8vbGV0IHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMCw1LDApO1xuICAgIGxldCBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgKGNvbmZpZy5wb3NpdGlvbiAmJiBjb25maWcucG9zaXRpb24ueCkgfHwgMCxcbiAgICAgIChjb25maWcucG9zaXRpb24gJiYgY29uZmlnLnBvc2l0aW9uLnkpIHx8IDAsXG4gICAgICAoY29uZmlnLnBvc2l0aW9uICYmIGNvbmZpZy5wb3NpdGlvbi56KSB8fCAwXG4gICAgKTtcbiAgICBsZXQgcm90YXRpb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLnNldEZyb21BeGlzQW5nbGUoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSxcbiAgICAgIC1NYXRoLlBJICogMC41XG4gICAgKTtcbiAgICBsZXQgcGxheWVyQ29udHJvbHMgPSBuZXcgTmF2TWVzaFBsYXllcihcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcm90YXRpb24sXG4gICAgICBhd2FpdCB0aHJlZSxcbiAgICAgIGF3YWl0IGlucHV0LFxuICAgICAgcGxheWVyU2VydmljZVxuICAgICk7XG4gICAgcGxheWVyU2VydmljZS5kZWNsYXJlUGxheWVyKHBsYXllckNvbnRyb2xzKTtcbiAgICBwbGF5ZXJDb250cm9scy5Jbml0aWFsaXplKCk7XG4gICAgKGF3YWl0IGZyYW1lTG9vcCkuYWRkTG9vcChOYXZNZXNoUGxheWVyLm5hbWUsIChkZWx0YSkgPT4ge1xuICAgICAgcGxheWVyQ29udHJvbHMuVXBkYXRlKGRlbHRhKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGxheWVyQ29udHJvbHM7XG4gIH1cbn1cblxuY29uc3QgTkFWX1pPTkUgPSBcImNoYXJhY3RlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZNZXNoUGxheWVyIGltcGxlbWVudHMgQ29tcG9uZW50LCBQbGF5ZXIge1xuICBwcml2YXRlIGNhbWVyYTogYW55O1xuICBwcml2YXRlIHRpbWVaZXJvVG9NYXg6IG51bWJlcjtcbiAgcHJpdmF0ZSBkZWNjZWxlcmF0aW9uOiBudW1iZXI7XG4gIHByaXZhdGUgc3BlZWQ6IFZlY3RvcjM7XG4gIHByaXZhdGUgbWF4U3BlZWQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBtb3VzZVNwZWVkOiBudW1iZXI7XG4gIHByaXZhdGUgYWNjZWxlcmF0aW9uOiBudW1iZXI7XG4gIHByaXZhdGUgaXNMb2NrZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgYW5nbGVzOiBFdWxlcjtcbiAgcHJpdmF0ZSBwaXRjaDogUXVhdGVybmlvbjtcbiAgcHJpdmF0ZSBqdW1wVmVsb2NpdHk6IG51bWJlcjtcbiAgcHJpdmF0ZSB5YXc6IFF1YXRlcm5pb247XG4gIHByaXZhdGUgdGVtcFZlYzogVmVjdG9yMztcbiAgcHJpdmF0ZSBtb3ZlRGlyOiBWZWN0b3IzO1xuICBwcml2YXRlIHlPZmZzZXQ6IG51bWJlcjsgLy9wbGF5ZXJIZWlnaHRcbiAgcHJpdmF0ZSB4QXhpczogVmVjdG9yMztcbiAgcHJpdmF0ZSB5QXhpczogVmVjdG9yMztcbiAgcHJpdmF0ZSBwb3NpdGlvbjogVmVjdG9yMztcbiAgcHJpdmF0ZSBwb3NpdGlvbk91dFRtcDogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgcG9zaXRpb25PdXRUbXAyOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSByb3RhdGlvbjogUXVhdGVybmlvbjtcbiAgcHJpdmF0ZSB2ZWxvY2l0eTogVmVjdG9yMztcbiAgcHJpdmF0ZSBuYXZNZXNoOiBOYXZNZXNoUGF0aGZpbmRlcjtcblxuICBnZXRUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIE5hdk1lc2hQbGF5ZXIubmFtZTtcbiAgfVxuXG4gIGFza0ZseU1vZGUoKSB7fVxuXG4gIGRlY2xhcmVOYXZNZXNoKFxuICAgIG5hdk1lc2g6IFRIUkVFLk1lc2g8VEhSRUUuQnVmZmVyR2VvbWV0cnksIFRIUkVFLk1hdGVyaWFsIHwgVEhSRUUuTWF0ZXJpYWxbXT5cbiAgKSB7XG4gICAgdGhpcy5uYXZNZXNoLmxvYWRNZXNoKG5hdk1lc2gsIE5BVl9aT05FKTtcbiAgfVxuXG4gIHRlbGVwb3J0VG9Mb2NhdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKSB7XG4gICAgdGhpcy5wb3NpdGlvbi5jb3B5KG5ldyBUSFJFRS5WZWN0b3IzKHgsIHksIHopKTtcbiAgfVxuXG4gIGdldEhlYWRQb3NpdGlvbih0YXJnZXRDb3B5OiBUSFJFRS5WZWN0b3IzKTogdm9pZCB7XG4gICAgdGFyZ2V0Q29weS5jb3B5KHRoaXMucG9zaXRpb24pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcG9zaXRpb24sXG4gICAgcm90YXRpb24sXG4gICAgdGhyZWU6IFRocmVlTGliLFxuICAgIHByaXZhdGUgaW5wdXQ6IElucHV0LFxuICAgIHByaXZhdGUgcGxheWVyU2VydmljZTogUGxheWVyU2VydmljZVxuICApIHtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMubmF2TWVzaCA9IG5ldyBOYXZNZXNoUGF0aGZpbmRlcigpO1xuXG4gICAgdGhpcy5jYW1lcmEgPSB0aHJlZS5jYW1lcmE7XG5cbiAgICB0aGlzLnRpbWVaZXJvVG9NYXggPSAwLjA4O1xuXG4gICAgdGhpcy5tYXhTcGVlZCA9IDcuMDtcbiAgICB0aGlzLnNwZWVkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IHRoaXMubWF4U3BlZWQgLyB0aGlzLnRpbWVaZXJvVG9NYXg7XG4gICAgdGhpcy5kZWNjZWxlcmF0aW9uID0gLTcuMDtcblxuICAgIHRoaXMubW91c2VTcGVlZCA9IDAuMDAyO1xuICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuYW5nbGVzID0gbmV3IFRIUkVFLkV1bGVyKCk7XG4gICAgdGhpcy5waXRjaCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy55YXcgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgdGhpcy5qdW1wVmVsb2NpdHkgPSA1O1xuICAgIHRoaXMueU9mZnNldCA9IDI7XG4gICAgdGhpcy50ZW1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLm1vdmVEaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHRoaXMueEF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygxLjAsIDAuMCwgMC4wKTtcbiAgICB0aGlzLnlBeGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoMC4wLCAxLjAsIDAuMCk7XG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIH1cblxuICBJbml0aWFsaXplKCkge1xuICAgIHRoaXMuYW5nbGVzLnNldEZyb21RdWF0ZXJuaW9uKHRoaXMucm90YXRpb24pO1xuICAgIHRoaXMuVXBkYXRlUm90YXRpb24oKTtcblxuICAgIHRoaXMuaW5wdXQuQWRkTW91c2VNb3ZlTGlzdG5lcih0aGlzLk9uTW91c2VNb3ZlKTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybG9ja2NoYW5nZVwiLCB0aGlzLk9uUG9pbnRlcmxvY2tDaGFuZ2UpO1xuXG4gICAgdGhpcy5pbnB1dC5BZGRDbGlja0xpc3RuZXIoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBPblBvaW50ZXJsb2NrQ2hhbmdlID0gKCkgPT4ge1xuICAgIGlmIChkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQpIHtcbiAgICAgIHRoaXMuaXNMb2NrZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcbiAgfTtcblxuICBPbk1vdXNlTW92ZSA9IChldmVudCkgPT4ge1xuICAgIGlmICghdGhpcy5pc0xvY2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbW92ZW1lbnRYLCBtb3ZlbWVudFkgfSA9IGV2ZW50O1xuXG4gICAgdGhpcy5hbmdsZXMueSAtPSBtb3ZlbWVudFggKiB0aGlzLm1vdXNlU3BlZWQ7XG4gICAgdGhpcy5hbmdsZXMueCAtPSBtb3ZlbWVudFkgKiB0aGlzLm1vdXNlU3BlZWQ7XG5cbiAgICB0aGlzLmFuZ2xlcy54ID0gTWF0aC5tYXgoXG4gICAgICAtTWF0aC5QSSAvIDIsXG4gICAgICBNYXRoLm1pbihNYXRoLlBJIC8gMiwgdGhpcy5hbmdsZXMueClcbiAgICApO1xuXG4gICAgdGhpcy5VcGRhdGVSb3RhdGlvbigpO1xuICB9O1xuXG4gIFVwZGF0ZVJvdGF0aW9uKCkge1xuICAgIHRoaXMucGl0Y2guc2V0RnJvbUF4aXNBbmdsZSh0aGlzLnhBeGlzLCB0aGlzLmFuZ2xlcy54KTtcbiAgICB0aGlzLnlhdy5zZXRGcm9tQXhpc0FuZ2xlKHRoaXMueUF4aXMsIHRoaXMuYW5nbGVzLnkpO1xuXG4gICAgdGhpcy5yb3RhdGlvbi5tdWx0aXBseVF1YXRlcm5pb25zKHRoaXMueWF3LCB0aGlzLnBpdGNoKS5ub3JtYWxpemUoKTtcblxuICAgIHRoaXMuY2FtZXJhLnF1YXRlcm5pb24uY29weSh0aGlzLnJvdGF0aW9uKTtcbiAgfVxuXG4gIEFjY2VsYXJhdGUgPSAoZGlyZWN0aW9uLCB0KSA9PiB7XG4gICAgY29uc3QgYWNjZWwgPSB0aGlzLnRlbXBWZWNcbiAgICAgIC5jb3B5KGRpcmVjdGlvbilcbiAgICAgIC5tdWx0aXBseVNjYWxhcih0aGlzLmFjY2VsZXJhdGlvbiAqIHQpO1xuICAgIHRoaXMuc3BlZWQuYWRkKGFjY2VsKTtcbiAgICB0aGlzLnNwZWVkLmNsYW1wTGVuZ3RoKDAuMCwgdGhpcy5tYXhTcGVlZCk7XG4gIH07XG5cbiAgRGVjY2VsZXJhdGUgPSAodCkgPT4ge1xuICAgIGNvbnN0IGZyYW1lRGVjY2VsID0gdGhpcy50ZW1wVmVjXG4gICAgICAuY29weSh0aGlzLnNwZWVkKVxuICAgICAgLm11bHRpcGx5U2NhbGFyKHRoaXMuZGVjY2VsZXJhdGlvbiAqIHQpO1xuICAgIHRoaXMuc3BlZWQuYWRkKGZyYW1lRGVjY2VsKTtcbiAgfTtcblxuICBVcGRhdGUodCkge1xuICAgIHQgPSB0ICogMC4wMDE7XG4gICAgY29uc3QgZm9yd2FyZEZhY3RvciA9XG4gICAgICB0aGlzLmlucHV0LkdldEtleURvd24oXCJLZXlTXCIpIC0gdGhpcy5pbnB1dC5HZXRLZXlEb3duKFwiS2V5V1wiKTtcbiAgICBjb25zdCByaWdodEZhY3RvciA9XG4gICAgICB0aGlzLmlucHV0LkdldEtleURvd24oXCJLZXlEXCIpIC0gdGhpcy5pbnB1dC5HZXRLZXlEb3duKFwiS2V5QVwiKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLm1vdmVEaXJcbiAgICAgIC5zZXQocmlnaHRGYWN0b3IsIDAuMCwgZm9yd2FyZEZhY3RvcilcbiAgICAgIC5ub3JtYWxpemUoKTtcblxuICAgIHRoaXMuRGVjY2VsZXJhdGUodCk7XG4gICAgdGhpcy5BY2NlbGFyYXRlKGRpcmVjdGlvbiwgdCk7XG5cbiAgICBjb25zdCBtb3ZlVmVjdG9yID0gdGhpcy50ZW1wVmVjLmNvcHkodGhpcy5zcGVlZCk7XG4gICAgbW92ZVZlY3Rvci5hcHBseVF1YXRlcm5pb24odGhpcy55YXcpO1xuXG4gICAgdGhpcy52ZWxvY2l0eS5zZXRYKG1vdmVWZWN0b3IueCk7XG4gICAgdGhpcy52ZWxvY2l0eS5zZXRaKG1vdmVWZWN0b3Iueik7XG4gICAgdGhpcy52ZWxvY2l0eS5tdWx0aXBseVNjYWxhcih0KTtcblxuICAgIHRoaXMucG9zaXRpb25PdXRUbXAueCA9IHRoaXMucG9zaXRpb24ueCArIHRoaXMudmVsb2NpdHkueDtcbiAgICB0aGlzLnBvc2l0aW9uT3V0VG1wLnkgPSB0aGlzLnBvc2l0aW9uLnkgKyB0aGlzLnZlbG9jaXR5Lnk7XG4gICAgdGhpcy5wb3NpdGlvbk91dFRtcC56ID0gdGhpcy5wb3NpdGlvbi56ICsgdGhpcy52ZWxvY2l0eS56O1xuXG4gICAgaWYgKHRoaXMubmF2TWVzaC5pc0VuYWJsZWQoKSkge1xuICAgICAgdGhpcy5uYXZNZXNoLmZpbmRQT1ZQb3NpdGlvbkFib3ZlTmF2TWVzaChcbiAgICAgICAgdGhpcy5wb3NpdGlvbixcbiAgICAgICAgdGhpcy5wb3NpdGlvbk91dFRtcCxcbiAgICAgICAgdGhpcy5wb3NpdGlvbk91dFRtcDJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9zaXRpb25PdXRUbXAyLmNvcHkodGhpcy5wb3NpdGlvbk91dFRtcCk7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24uc2V0KFxuICAgICAgdGhpcy5wb3NpdGlvbk91dFRtcDIueCxcbiAgICAgIHRoaXMucG9zaXRpb25PdXRUbXAyLnksXG4gICAgICB0aGlzLnBvc2l0aW9uT3V0VG1wMi56XG4gICAgKTtcbiAgICB0aGlzLnBvc2l0aW9uLmNvcHkodGhpcy5jYW1lcmEucG9zaXRpb24pO1xuICB9XG59XG4iXSwibmFtZXMiOlsiUGF0aGZpbmRpbmciLCJUSFJFRSIsIk5hdk1lc2hQYXRoZmluZGVyIiwic3RhcnRpbmdGZWV0UG9zaXRpb24iLCJWZWN0b3IzIiwiZGVzaXJlZEZlZXRQb3NpdGlvbiIsInN0YXJ0UE9WUG9zaXRpb24iLCJkZXNpcmVkUE9WUG9zaXRpb24iLCJvdXRQT1ZQb3NpdGlvbiIsInBsYXllckhlaWdodCIsImNvcHkiLCJ5IiwiZmluZFBvc2l0aW9uT25OYXZNZXNoIiwiaXNFbmFibGVkIiwicGF0aGZpbmRlciIsInpvbmUiLCJ6b25lcyIsImxvYWRNZXNoIiwibWVzaCIsImNvbnNvbGUiLCJlcnJvciIsInJlbW92ZU5hdk1lc2hEYXRhIiwiZ2VvbWV0cnkiLCJhcHBseU1hdHJpeDQiLCJtYXRyaXhXb3JsZCIsInNldFpvbmVEYXRhIiwiY3JlYXRlWm9uZSIsImdldENsb3Nlc3ROb2RlIiwicG9zIiwiZ3JvdXBzIiwibmF2R3JvdXAiLCJzdGFydCIsImVuZCIsIm91dFBvcyIsInNob3VsZFJlY29tcHV0ZUdyb3VwQW5kTm9kZSIsImdldEdyb3VwIiwibmF2Tm9kZSIsInVuZGVmaW5lZCIsImNsYW1wU3RlcCIsImRpc3Bvc2UiLCJTZXJ2aWNlRW50aXR5IiwiRmFjdG9yeSIsImNyZWF0ZUNvbXBvbmVudCIsIndvcmxkIiwiY29uZmlnIiwic2VydmljZXMiLCJnZXRGaXJzdENvbXBvbmVudEJ5VHlwZSIsIm5hbWUiLCJ0aHJlZSIsImdldFNlcnZpY2UiLCJpbnB1dCIsInBsYXllclNlcnZpY2UiLCJmcmFtZUxvb3AiLCJwb3NpdGlvbiIsIngiLCJ6Iiwicm90YXRpb24iLCJRdWF0ZXJuaW9uIiwic2V0RnJvbUF4aXNBbmdsZSIsIk1hdGgiLCJQSSIsInBsYXllckNvbnRyb2xzIiwiTmF2TWVzaFBsYXllciIsImRlY2xhcmVQbGF5ZXIiLCJJbml0aWFsaXplIiwiYWRkTG9vcCIsImRlbHRhIiwiVXBkYXRlIiwiTkFWX1pPTkUiLCJnZXRUeXBlIiwiYXNrRmx5TW9kZSIsImRlY2xhcmVOYXZNZXNoIiwibmF2TWVzaCIsInRlbGVwb3J0VG9Mb2NhdGlvbiIsImdldEhlYWRQb3NpdGlvbiIsInRhcmdldENvcHkiLCJjb25zdHJ1Y3RvciIsImRvY3VtZW50IiwicG9pbnRlckxvY2tFbGVtZW50IiwiaXNMb2NrZWQiLCJldmVudCIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsImFuZ2xlcyIsIm1vdXNlU3BlZWQiLCJtYXgiLCJtaW4iLCJVcGRhdGVSb3RhdGlvbiIsImRpcmVjdGlvbiIsInQiLCJhY2NlbCIsInRlbXBWZWMiLCJtdWx0aXBseVNjYWxhciIsImFjY2VsZXJhdGlvbiIsInNwZWVkIiwiYWRkIiwiY2xhbXBMZW5ndGgiLCJtYXhTcGVlZCIsImZyYW1lRGVjY2VsIiwiZGVjY2VsZXJhdGlvbiIsImNhbWVyYSIsInRpbWVaZXJvVG9NYXgiLCJFdWxlciIsInBpdGNoIiwieWF3IiwianVtcFZlbG9jaXR5IiwieU9mZnNldCIsIm1vdmVEaXIiLCJ4QXhpcyIsInlBeGlzIiwidmVsb2NpdHkiLCJzZXRGcm9tUXVhdGVybmlvbiIsIkFkZE1vdXNlTW92ZUxpc3RuZXIiLCJPbk1vdXNlTW92ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJPblBvaW50ZXJsb2NrQ2hhbmdlIiwiQWRkQ2xpY2tMaXN0bmVyIiwiYm9keSIsInJlcXVlc3RQb2ludGVyTG9jayIsIm11bHRpcGx5UXVhdGVybmlvbnMiLCJub3JtYWxpemUiLCJxdWF0ZXJuaW9uIiwiZm9yd2FyZEZhY3RvciIsIkdldEtleURvd24iLCJyaWdodEZhY3RvciIsInNldCIsIkRlY2NlbGVyYXRlIiwiQWNjZWxhcmF0ZSIsIm1vdmVWZWN0b3IiLCJhcHBseVF1YXRlcm5pb24iLCJzZXRYIiwic2V0WiIsInBvc2l0aW9uT3V0VG1wIiwiZmluZFBPVlBvc2l0aW9uQWJvdmVOYXZNZXNoIiwicG9zaXRpb25PdXRUbXAyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n')}}]);