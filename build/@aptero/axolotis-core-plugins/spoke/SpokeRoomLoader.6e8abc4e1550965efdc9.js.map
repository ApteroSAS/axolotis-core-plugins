{"version":3,"file":"@aptero/axolotis-core-plugins/spoke/SpokeRoomLoader.6e8abc4e1550965efdc9.js","mappings":"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","sources":["webpack://axolotis-core-plugins/./src/lib/modules/spoke/SceneLoader.ts","webpack://axolotis-core-plugins/./node_modules/phoenix/priv/static/phoenix.mjs","webpack://axolotis-core-plugins/./src/lib/modules/spoke/PhoenixUtils.ts","webpack://axolotis-core-plugins/./src/lib/modules/spoke/SpokeRoomLoader.ts"],"sourcesContent":["import { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\n\nexport default class SceneLoader {\n  private scene: any;\n  private mesh: any;\n  public navMesh: any;\n\n  constructor() {}\n\n  async loadScene(sceneUrl: string, threeLib: ThreeLib) {\n    this.scene = threeLib.scene;\n    this.mesh = await threeLib.loadAssets(sceneUrl);\n    this.mesh = this.mesh.scene;\n\n    this.mesh.traverse((node) => {\n      if (node.isMesh) {\n        if (node.name === \"navMesh\") {\n          this.navMesh = node;\n        }\n      }\n    });\n\n    this.scene.add(this.mesh);\n  }\n}\n","// js/phoenix/utils.js\nvar closure = (value) => {\n  if (typeof value === \"function\") {\n    return value;\n  } else {\n    let closure2 = function() {\n      return value;\n    };\n    return closure2;\n  }\n};\n\n// js/phoenix/constants.js\nvar globalSelf = typeof self !== \"undefined\" ? self : null;\nvar phxWindow = typeof window !== \"undefined\" ? window : null;\nvar global = globalSelf || phxWindow || global;\nvar DEFAULT_VSN = \"2.0.0\";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 1e4;\nvar WS_CLOSE_NORMAL = 1e3;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n};\nvar XHR_STATES = {\n  complete: 4\n};\n\n// js/phoenix/push.js\nvar Push = class {\n  constructor(channel, event, payload, timeout) {\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || function() {\n      return {};\n    };\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n  resend(timeout) {\n    this.timeout = timeout;\n    this.reset();\n    this.send();\n  }\n  send() {\n    if (this.hasReceived(\"timeout\")) {\n      return;\n    }\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    });\n  }\n  receive(status, callback) {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp.response);\n    }\n    this.recHooks.push({ status, callback });\n    return this;\n  }\n  reset() {\n    this.cancelRefEvent();\n    this.ref = null;\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n  }\n  matchReceive({ status, response, _ref }) {\n    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));\n  }\n  cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n    this.channel.off(this.refEvent);\n  }\n  cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = null;\n  }\n  startTimeout() {\n    if (this.timeoutTimer) {\n      this.cancelTimeout();\n    }\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n    this.channel.on(this.refEvent, (payload) => {\n      this.cancelRefEvent();\n      this.cancelTimeout();\n      this.receivedResp = payload;\n      this.matchReceive(payload);\n    });\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout);\n  }\n  hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n  trigger(status, response) {\n    this.channel.trigger(this.refEvent, { status, response });\n  }\n};\n\n// js/phoenix/timer.js\nvar Timer = class {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n};\n\n// js/phoenix/channel.js\nvar Channel = class {\n  constructor(topic, params, socket) {\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.stateChangeRefs = [];\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n    this.stateChangeRefs.push(this.socket.onOpen(() => {\n      this.rejoinTimer.reset();\n      if (this.isErrored()) {\n        this.rejoin();\n      }\n    }));\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError((reason) => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `error ${this.topic}`, reason);\n      if (this.isJoining()) {\n        this.joinPush.reset();\n      }\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n      leavePush.send();\n      this.state = CHANNEL_STATES.errored;\n      this.joinPush.reset();\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n  join(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n    } else {\n      this.timeout = timeout;\n      this.joinedOnce = true;\n      this.rejoin();\n      return this.joinPush;\n    }\n  }\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n  onError(callback) {\n    return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));\n  }\n  on(event, callback) {\n    let ref = this.bindingRef++;\n    this.bindings.push({ event, ref, callback });\n    return ref;\n  }\n  off(event, ref) {\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n    });\n  }\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n  push(event, payload, timeout = this.timeout) {\n    payload = payload || {};\n    if (!this.joinedOnce) {\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\n    }\n    let pushEvent = new Push(this, event, function() {\n      return payload;\n    }, timeout);\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  leave(timeout = this.timeout) {\n    this.rejoinTimer.reset();\n    this.joinPush.cancelTimeout();\n    this.state = CHANNEL_STATES.leaving;\n    let onClose = () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, \"leave\");\n    };\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n    leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n    leavePush.send();\n    if (!this.canPush()) {\n      leavePush.trigger(\"ok\", {});\n    }\n    return leavePush;\n  }\n  onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  isMember(topic, event, payload, joinRef) {\n    if (this.topic !== topic) {\n      return false;\n    }\n    if (joinRef && joinRef !== this.joinRef()) {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", \"dropping outdated message\", { topic, event, payload, joinRef });\n      return false;\n    } else {\n      return true;\n    }\n  }\n  joinRef() {\n    return this.joinPush.ref;\n  }\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return;\n    }\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  trigger(event, payload, ref, joinRef) {\n    let handledPayload = this.onMessage(event, payload, ref, joinRef);\n    if (payload && !handledPayload) {\n      throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n    }\n    let eventBindings = this.bindings.filter((bind) => bind.event === event);\n    for (let i = 0; i < eventBindings.length; i++) {\n      let bind = eventBindings[i];\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\n    }\n  }\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n};\n\n// js/phoenix/ajax.js\nvar Ajax = class {\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n    if (global.XDomainRequest) {\n      let req = new global.XDomainRequest();\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n    } else {\n      let req = new global.XMLHttpRequest();\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n    }\n  }\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n    req.timeout = timeout;\n    req.open(method, endPoint);\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText);\n      callback && callback(response);\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.onprogress = () => {\n    };\n    req.send(body);\n  }\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n    req.open(method, endPoint, true);\n    req.timeout = timeout;\n    req.setRequestHeader(\"Content-Type\", accept);\n    req.onerror = () => {\n      callback && callback(null);\n    };\n    req.onreadystatechange = () => {\n      if (req.readyState === XHR_STATES.complete && callback) {\n        let response = this.parseJSON(req.responseText);\n        callback(response);\n      }\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.send(body);\n  }\n  static parseJSON(resp) {\n    if (!resp || resp === \"\") {\n      return null;\n    }\n    try {\n      return JSON.parse(resp);\n    } catch (e) {\n      console && console.log(\"failed to parse JSON response\", resp);\n      return null;\n    }\n  }\n  static serialize(obj, parentKey) {\n    let queryStr = [];\n    for (var key in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        continue;\n      }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n      let paramVal = obj[key];\n      if (typeof paramVal === \"object\") {\n        queryStr.push(this.serialize(paramVal, paramKey));\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n      }\n    }\n    return queryStr.join(\"&\");\n  }\n  static appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    return `${url}${prefix}${this.serialize(params)}`;\n  }\n};\n\n// js/phoenix/longpoll.js\nvar LongPoll = class {\n  constructor(endPoint) {\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.onopen = function() {\n    };\n    this.onerror = function() {\n    };\n    this.onmessage = function() {\n    };\n    this.onclose = function() {\n    };\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    this.poll();\n  }\n  normalizeEndpoint(endPoint) {\n    return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n  }\n  endpointURL() {\n    return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n  }\n  closeAndRetry(code, reason, wasClean) {\n    this.close(code, reason, wasClean);\n    this.readyState = SOCKET_STATES.connecting;\n  }\n  ontimeout() {\n    this.onerror(\"timeout\");\n    this.closeAndRetry(1005, \"timeout\", false);\n  }\n  poll() {\n    if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n      return;\n    }\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), (resp) => {\n      if (resp) {\n        var { status, token, messages } = resp;\n        this.token = token;\n      } else {\n        status = 0;\n      }\n      switch (status) {\n        case 200:\n          messages.forEach((msg) => {\n            setTimeout(() => {\n              this.onmessage({ data: msg });\n            }, 0);\n          });\n          this.poll();\n          break;\n        case 204:\n          this.poll();\n          break;\n        case 410:\n          this.readyState = SOCKET_STATES.open;\n          this.onopen({});\n          this.poll();\n          break;\n        case 403:\n          this.onerror(403);\n          this.close(1008, \"forbidden\", false);\n          break;\n        case 0:\n        case 500:\n          this.onerror(500);\n          this.closeAndRetry(1011, \"internal server error\", 500);\n          break;\n        default:\n          throw new Error(`unhandled poll status ${status}`);\n      }\n    });\n  }\n  send(body) {\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), (resp) => {\n      if (!resp || resp.status !== 200) {\n        this.onerror(resp && resp.status);\n        this.closeAndRetry(1011, \"internal server error\", false);\n      }\n    });\n  }\n  close(code, reason, wasClean) {\n    this.readyState = SOCKET_STATES.closed;\n    let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });\n    if (typeof CloseEvent !== \"undefined\") {\n      this.onclose(new CloseEvent(\"close\", opts));\n    } else {\n      this.onclose(opts);\n    }\n  }\n};\n\n// js/phoenix/presence.js\nvar Presence = class {\n  constructor(channel, opts = {}) {\n    let events = opts.events || { state: \"presence_state\", diff: \"presence_diff\" };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function() {\n      },\n      onLeave: function() {\n      },\n      onSync: function() {\n      }\n    };\n    this.channel.on(events.state, (newState) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      this.joinRef = this.channel.joinRef();\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach((diff) => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel.on(events.diff, (diff) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n  list(by) {\n    return Presence.list(this.state, by);\n  }\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\n  }\n  static syncState(currentState, newState, onJoin, onLeave) {\n    let state = this.clone(currentState);\n    let joins = {};\n    let leaves = {};\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key];\n      if (currentPresence) {\n        let newRefs = newPresence.metas.map((m) => m.phx_ref);\n        let curRefs = currentPresence.metas.map((m) => m.phx_ref);\n        let joinedMetas = newPresence.metas.filter((m) => curRefs.indexOf(m.phx_ref) < 0);\n        let leftMetas = currentPresence.metas.filter((m) => newRefs.indexOf(m.phx_ref) < 0);\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n  }\n  static syncDiff(state, diff, onJoin, onLeave) {\n    let { joins, leaves } = this.clone(diff);\n    if (!onJoin) {\n      onJoin = function() {\n      };\n    }\n    if (!onLeave) {\n      onLeave = function() {\n      };\n    }\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key];\n      state[key] = this.clone(newPresence);\n      if (currentPresence) {\n        let joinedRefs = state[key].metas.map((m) => m.phx_ref);\n        let curMetas = currentPresence.metas.filter((m) => joinedRefs.indexOf(m.phx_ref) < 0);\n        state[key].metas.unshift(...curMetas);\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      let refsToRemove = leftPresence.metas.map((m) => m.phx_ref);\n      currentPresence.metas = currentPresence.metas.filter((p) => {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  }\n  static list(presences, chooser) {\n    if (!chooser) {\n      chooser = function(key, pres) {\n        return pres;\n      };\n    }\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence);\n    });\n  }\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n  }\n  static clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n// js/phoenix/serializer.js\nvar serializer_default = {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: { push: 0, reply: 1, broadcast: 2 },\n  encode(msg, callback) {\n    if (msg.payload.constructor === ArrayBuffer) {\n      return callback(this.binaryEncode(msg));\n    } else {\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n      return callback(JSON.stringify(payload));\n    }\n  },\n  decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this.binaryDecode(rawPayload));\n    } else {\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n      return callback({ join_ref, ref, topic, event, payload });\n    }\n  },\n  binaryEncode(message) {\n    let { join_ref, ref, event, topic, payload } = message;\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n    let view = new DataView(header);\n    let offset = 0;\n    view.setUint8(offset++, this.KINDS.push);\n    view.setUint8(offset++, join_ref.length);\n    view.setUint8(offset++, ref.length);\n    view.setUint8(offset++, topic.length);\n    view.setUint8(offset++, event.length);\n    Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    var combined = new Uint8Array(header.byteLength + payload.byteLength);\n    combined.set(new Uint8Array(header), 0);\n    combined.set(new Uint8Array(payload), header.byteLength);\n    return combined.buffer;\n  },\n  binaryDecode(buffer) {\n    let view = new DataView(buffer);\n    let kind = view.getUint8(0);\n    let decoder = new TextDecoder();\n    switch (kind) {\n      case this.KINDS.push:\n        return this.decodePush(buffer, view, decoder);\n      case this.KINDS.reply:\n        return this.decodeReply(buffer, view, decoder);\n      case this.KINDS.broadcast:\n        return this.decodeBroadcast(buffer, view, decoder);\n    }\n  },\n  decodePush(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let topicSize = view.getUint8(2);\n    let eventSize = view.getUint8(3);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: joinRef, ref: null, topic, event, payload: data };\n  },\n  decodeReply(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let refSize = view.getUint8(2);\n    let topicSize = view.getUint8(3);\n    let eventSize = view.getUint8(4);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n    offset = offset + refSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    let payload = { status: event, response: data };\n    return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };\n  },\n  decodeBroadcast(buffer, view, decoder) {\n    let topicSize = view.getUint8(1);\n    let eventSize = view.getUint8(2);\n    let offset = this.HEADER_LENGTH + 2;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: null, ref: null, topic, event, payload: data };\n  }\n};\n\n// js/phoenix/socket.js\nvar Socket = class {\n  constructor(endPoint, opts = {}) {\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || global.WebSocket || LongPoll;\n    this.establishedConnections = 0;\n    this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n    this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n    this.closeWasClean = false;\n    this.binaryType = opts.binaryType || \"arraybuffer\";\n    this.connectClock = 1;\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n    let awaitingConnectionOnPageShow = null;\n    if (phxWindow && phxWindow.addEventListener) {\n      phxWindow.addEventListener(\"pagehide\", (_e) => {\n        if (this.conn) {\n          this.disconnect();\n          awaitingConnectionOnPageShow = this.connectClock;\n        }\n      });\n      phxWindow.addEventListener(\"pageshow\", (_e) => {\n        if (awaitingConnectionOnPageShow === this.connectClock) {\n          awaitingConnectionOnPageShow = null;\n          this.connect();\n        }\n      });\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n    this.rejoinAfterMs = (tries) => {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries);\n      } else {\n        return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n      }\n    };\n    this.reconnectAfterMs = (tries) => {\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries);\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n      }\n    };\n    this.logger = opts.logger || null;\n    this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n    this.params = closure(opts.params || {});\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.vsn = opts.vsn || DEFAULT_VSN;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect());\n    }, this.reconnectAfterMs);\n  }\n  replaceTransport(newTransport) {\n    this.disconnect();\n    this.transport = newTransport;\n  }\n  protocol() {\n    return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n  }\n  endPointURL() {\n    let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });\n    if (uri.charAt(0) !== \"/\") {\n      return uri;\n    }\n    if (uri.charAt(1) === \"/\") {\n      return `${this.protocol()}:${uri}`;\n    }\n    return `${this.protocol()}://${location.host}${uri}`;\n  }\n  disconnect(callback, code, reason) {\n    this.connectClock++;\n    this.closeWasClean = true;\n    this.reconnectTimer.reset();\n    this.teardown(callback, code, reason);\n  }\n  connect(params) {\n    this.connectClock++;\n    if (params) {\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n      this.params = closure(params);\n    }\n    if (this.conn) {\n      return;\n    }\n    this.closeWasClean = false;\n    this.conn = new this.transport(this.endPointURL());\n    this.conn.binaryType = this.binaryType;\n    this.conn.timeout = this.longpollerTimeout;\n    this.conn.onopen = () => this.onConnOpen();\n    this.conn.onerror = (error) => this.onConnError(error);\n    this.conn.onmessage = (event) => this.onConnMessage(event);\n    this.conn.onclose = (event) => this.onConnClose(event);\n  }\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  hasLogger() {\n    return this.logger !== null;\n  }\n  onOpen(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.open.push([ref, callback]);\n    return ref;\n  }\n  onClose(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.close.push([ref, callback]);\n    return ref;\n  }\n  onError(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.error.push([ref, callback]);\n    return ref;\n  }\n  onMessage(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.message.push([ref, callback]);\n    return ref;\n  }\n  onConnOpen() {\n    if (this.hasLogger())\n      this.log(\"transport\", `connected to ${this.endPointURL()}`);\n    this.closeWasClean = false;\n    this.establishedConnections++;\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.resetHeartbeat();\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n  }\n  heartbeatTimeout() {\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      if (this.hasLogger()) {\n        this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n      }\n      this.abnormalClose(\"heartbeat timeout\");\n    }\n  }\n  resetHeartbeat() {\n    if (this.conn && this.conn.skipHeartbeat) {\n      return;\n    }\n    this.pendingHeartbeatRef = null;\n    clearTimeout(this.heartbeatTimer);\n    setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n  }\n  teardown(callback, code, reason) {\n    if (!this.conn) {\n      return callback && callback();\n    }\n    this.waitForBufferDone(() => {\n      if (this.conn) {\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n      }\n      this.waitForSocketClosed(() => {\n        if (this.conn) {\n          this.conn.onclose = function() {\n          };\n          this.conn = null;\n        }\n        callback && callback();\n      });\n    });\n  }\n  waitForBufferDone(callback, tries = 1) {\n    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1);\n    }, 150 * tries);\n  }\n  waitForSocketClosed(callback, tries = 1) {\n    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1);\n    }, 150 * tries);\n  }\n  onConnClose(event) {\n    let closeCode = event && event.code;\n    if (this.hasLogger())\n      this.log(\"transport\", \"close\", event);\n    this.triggerChanError();\n    clearTimeout(this.heartbeatTimer);\n    if (!this.closeWasClean && closeCode !== 1e3) {\n      this.reconnectTimer.scheduleTimeout();\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n  }\n  onConnError(error) {\n    if (this.hasLogger())\n      this.log(\"transport\", error);\n    let transportBefore = this.transport;\n    let establishedBefore = this.establishedConnections;\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\n      callback(error, transportBefore, establishedBefore);\n    });\n    if (transportBefore === this.transport || establishedBefore > 0) {\n      this.triggerChanError();\n    }\n  }\n  triggerChanError() {\n    this.channels.forEach((channel) => {\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n        channel.trigger(CHANNEL_EVENTS.error);\n      }\n    });\n  }\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return \"connecting\";\n      case SOCKET_STATES.open:\n        return \"open\";\n      case SOCKET_STATES.closing:\n        return \"closing\";\n      default:\n        return \"closed\";\n    }\n  }\n  isConnected() {\n    return this.connectionState() === \"open\";\n  }\n  remove(channel) {\n    this.off(channel.stateChangeRefs);\n    this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());\n  }\n  off(refs) {\n    for (let key in this.stateChangeCallbacks) {\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n        return refs.indexOf(ref) === -1;\n      });\n    }\n  }\n  channel(topic, chanParams = {}) {\n    let chan = new Channel(topic, chanParams, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  push(data) {\n    if (this.hasLogger()) {\n      let { topic, event, payload, ref, join_ref } = data;\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n    }\n    if (this.isConnected()) {\n      this.encode(data, (result) => this.conn.send(result));\n    } else {\n      this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));\n    }\n  }\n  makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  sendHeartbeat() {\n    if (this.pendingHeartbeatRef && !this.isConnected()) {\n      return;\n    }\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef });\n    this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n  }\n  abnormalClose(reason) {\n    this.closeWasClean = false;\n    if (this.isConnected()) {\n      this.conn.close(WS_CLOSE_NORMAL, reason);\n    }\n  }\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback());\n      this.sendBuffer = [];\n    }\n  }\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, (msg) => {\n      let { topic, event, payload, ref, join_ref } = msg;\n      if (ref && ref === this.pendingHeartbeatRef) {\n        clearTimeout(this.heartbeatTimer);\n        this.pendingHeartbeatRef = null;\n        setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n      }\n      if (this.hasLogger())\n        this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i];\n        if (!channel.isMember(topic, event, payload, join_ref)) {\n          continue;\n        }\n        channel.trigger(event, payload, ref, join_ref);\n      }\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        let [, callback] = this.stateChangeCallbacks.message[i];\n        callback(msg);\n      }\n    });\n  }\n  leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));\n    if (dupChannel) {\n      if (this.hasLogger())\n        this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n      dupChannel.leave();\n    }\n  }\n};\nexport {\n  Channel,\n  LongPoll,\n  Presence,\n  serializer_default as Serializer,\n  Socket\n};\n//# sourceMappingURL=phoenix.mjs.map\n","import { Socket } from \"phoenix\";\n\nlet configs = {\n  RETICULUM_SOCKET_SERVER_PORT: \"443\",\n  RETICULUM_SOCKET_SERVER: \"alphahub.aptero.co\", //TODO\n  RETICULUM_SOCKET_PROTOCOL: \"wss:\",\n};\n\nexport function createHubChannelParams(\n  authToken: string | null = null,\n  permsToken: string | null = null\n) {\n  /*{\n        \"profile\": {\n        \"avatarId\": \"https://hub.aptero.co/data/avatar/A031/base.glb\",\n            \"displayName\": \"Pierre\"\n    },\n        \"push_subscription_endpoint\": null,\n        \"auth_token\": \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJyZXQiLCJleHAiOjE2MjM2Nzc4NzUsImlhdCI6MTYxNjQyMDI3NSwiaXNzIjoicmV0IiwianRpIjoiMTBkMWFkZmYtYjBlMi00N2RkLWFiMTgtMjY3MGY0ZDVhMTFkIiwibmJmIjoxNjE2NDIwMjc0LCJzdWIiOiI2NDA0MDcwNTA5NjYyNjk5NjEiLCJ0eXAiOiJhY2Nlc3MifQ.qp29Ip4AKkpRPtVVOUikytL1u-lGPJidUglsWlW8H9izgdRsoH_c0yZuA04Miwi6K2iN-GsoCr8Kd1fTH0yp2g\",\n        \"perms_token\": null,\n        \"context\": {\n        \"mobile\": false,\n            \"embed\": true\n    },\n        \"hub_invite_id\": null\n    }*/\n  const params = {\n    profile: {\n      avatarId: \"\",\n      displayName: \"\",\n    },\n    push_subscription_endpoint: null,\n    auth_token: null,\n    perms_token: null,\n    bot_access_key: null,\n    context: {\n      mobile: false,\n      embed: true,\n    },\n    hub_invite_id: null,\n  };\n\n  return params;\n}\n\nexport async function load(\n  hubid\n): Promise<{ data: any; hubPhxChannel: any; vapiddata: any }> {\n  const socket = await connectToReticulum();\n  socket.onClose((e) => {\n    console.error(e);\n  });\n\n  const { data, hubPhxChannel, vapiddata } = await new Promise(\n    (resolve, reject) => {\n      // Reticulum global channel\n      let retChannel = socket.channel(`ret`, { hub_id: hubid });\n      retChannel\n        .join()\n        .receive(\"ok\", (vapiddata) => {\n          const hubPhxChannel = socket.channel(\n            `hub:` + hubid,\n            createHubChannelParams()\n          );\n          hubPhxChannel\n            .join()\n            .receive(\"ok\", async (data) => {\n              resolve({ data, hubPhxChannel, vapiddata });\n            })\n            .receive(\"error\", (res) => {\n              reject(res);\n            });\n        })\n        .receive(\"error\", (res) => {\n          reject(res);\n        });\n    }\n  );\n  return { data, hubPhxChannel, vapiddata };\n}\n\nlet reticulumMeta: any = null;\nlet invalidatedReticulumMetaThisSession = false;\n\nlet directReticulumHostAndPort;\n\nasync function refreshDirectReticulumHostAndPort() {\n  const qs = new URLSearchParams(location.search);\n  let host = qs.get(\"phx_host\");\n  host = host || configs.RETICULUM_SOCKET_SERVER;\n  const port = configs.RETICULUM_SOCKET_SERVER_PORT;\n  directReticulumHostAndPort = { host, port };\n}\n\nexport async function invalidateReticulumMeta() {\n  invalidatedReticulumMetaThisSession = true;\n  reticulumMeta = null;\n}\n\n//TODO important function\nexport async function connectToReticulum(\n  debug = false,\n  params = null,\n  socketClass = Socket\n) {\n  const qs = new URLSearchParams(location.search);\n\n  const getNewSocketUrl = async () => {\n    await refreshDirectReticulumHostAndPort();\n    const { host, port } = directReticulumHostAndPort;\n    const protocol =\n      qs.get(\"phx_protocol\") ||\n      configs.RETICULUM_SOCKET_PROTOCOL ||\n      (document.location.protocol === \"https:\" ? \"wss:\" : \"ws:\");\n\n    return `${protocol}//${host}${port ? `:${port}` : \"\"}`;\n  };\n\n  const socketUrl = await getNewSocketUrl();\n  console.log(`Phoenix Socket URL: ${socketUrl}`);\n\n  const socketSettings: any = {};\n\n  if (debug) {\n    socketSettings.logger = (kind, msg, data) => {\n      console.log(`${kind}: ${msg}`, data);\n    };\n  }\n\n  if (params) {\n    socketSettings.params = params;\n  }\n\n  const socket = new socketClass(`${socketUrl}/socket`, socketSettings);\n  socket.connect();\n  socket.onError(async () => {\n    // On error, underlying reticulum node may have died, so rebalance by\n    // fetching a new healthy node to connect to.\n    invalidateReticulumMeta();\n\n    const endPointPath = new URL(socket.endPoint).pathname;\n    const newSocketUrl = await getNewSocketUrl();\n    const newEndPoint = `${newSocketUrl}${endPointPath}`;\n    console.log(`Socket error, changed endpoint to ${newEndPoint}`);\n    socket.endPoint = newEndPoint;\n  });\n\n  return socket;\n}\n\nexport function getPresenceEntryForSession(presences, sessionId) {\n  const entry =\n    Object.entries(presences || {}).find(([k]) => k === sessionId) || [];\n  const presence: any = entry[1];\n  return (presence && presence.metas && presence.metas[0]) || {};\n}\n\nexport function getPresenceContextForSession(presences, sessionId) {\n  return (getPresenceEntryForSession(presences, sessionId) || {}).context || {};\n}\n\nexport function getPresenceProfileForSession(presences, sessionId) {\n  return (getPresenceEntryForSession(presences, sessionId) || {}).profile || {};\n}\n\nfunction migrateBindings(oldChannel, newChannel) {\n  const doNotDuplicate = [\n    \"phx_close\",\n    \"phx_error\",\n    \"phx_reply\",\n    \"presence_state\",\n    \"presence_diff\",\n  ];\n  const shouldDuplicate = (event) => {\n    return !event.startsWith(\"chan_reply_\") && !doNotDuplicate.includes(event);\n  };\n  for (let i = 0, l = oldChannel.bindings.length; i < l; i++) {\n    const item = oldChannel.bindings[i];\n    if (shouldDuplicate(item.event)) {\n      newChannel.bindings.push(item);\n    }\n  }\n  newChannel.bindingRef = oldChannel.bindingRef;\n}\n\n// Takes the given channel, and creates a new channel with the same bindings\n// with the given socket, joins it, and leaves the old channel after joining.\n//\n// NOTE: This function relies upon phoenix channel object internals, so this\n// function will need to be reviewed if/when we ever update phoenix.js\nexport function migrateChannelToSocket(oldChannel, socket, params) {\n  const channel = socket.channel(oldChannel.topic, params || oldChannel.params);\n\n  migrateBindings(oldChannel, channel);\n\n  for (let i = 0, l = oldChannel.pushBuffer.length; i < l; i++) {\n    const item = oldChannel.pushBuffer[i];\n    channel.push(item.event, item.payload, item.timeout);\n  }\n\n  const oldJoinPush = oldChannel.joinPush;\n  const joinPush = channel.join();\n\n  for (let i = 0, l = oldJoinPush.recHooks.length; i < l; i++) {\n    const item = oldJoinPush.recHooks[i];\n    joinPush.receive(item.status, item.callback);\n  }\n\n  return new Promise((resolve) => {\n    joinPush.receive(\"ok\", () => {\n      // Clear all event handlers first so no duplicate messages come in.\n      oldChannel.bindings = [];\n      resolve(channel);\n    });\n  });\n}\n\nexport function migrateToChannel(oldChannel, newChannel) {\n  migrateBindings(oldChannel, newChannel);\n\n  return new Promise((resolve, reject) => {\n    newChannel\n      .join()\n      .receive(\"ok\", (data) => {\n        oldChannel.leave();\n        oldChannel.bindings = [];\n        resolve(data);\n      })\n      .receive(\"error\", (data) => {\n        newChannel.leave();\n        reject(data);\n      });\n  });\n}\n\nexport function discordBridgesForPresences(presences: any[]) {\n  const channels = [];\n  for (const p of Object.values(presences)) {\n    for (const m of p.metas) {\n      if (m.profile && m.profile.discordBridges) {\n        Array.prototype.push.apply(\n          channels,\n          m.profile.discordBridges.map((b) => b.channel.name)\n        );\n      }\n    }\n  }\n  return channels;\n}\n\nexport function hasEmbedPresences(presences: any[]) {\n  for (const p of Object.values(presences)) {\n    for (const m of p.metas) {\n      if (m.context && m.context.embed) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function denoisePresence({ onJoin, onLeave, onChange }) {\n  return {\n    rawOnJoin: (key, beforeJoin, afterJoin) => {\n      if (beforeJoin === undefined) {\n        onJoin(key, afterJoin.metas[0]);\n      }\n    },\n    rawOnLeave: (key, remaining, removed) => {\n      if (remaining.metas.length === 0) {\n        onLeave(key, removed.metas[0]);\n      } else {\n        onChange(\n          key,\n          removed.metas[removed.metas.length - 1],\n          remaining.metas[remaining.metas.length - 1]\n        );\n      }\n    },\n  };\n}\n\nexport function presenceEventsForHub(events) {\n  const onJoin = (key, meta) => {\n    events.trigger(`hub:join`, { key, meta });\n  };\n  const onLeave = (key, meta) => {\n    events.trigger(`hub:leave`, { key, meta });\n  };\n  const onChange = (key, previous, current) => {\n    events.trigger(`hub:change`, { key, previous, current });\n  };\n  return {\n    onJoin,\n    onLeave,\n    onChange,\n  };\n}\n","import { Component } from \"@aptero/axolotis-player\";\r\nimport { ComponentFactory } from \"@aptero/axolotis-player\";\r\nimport { WorldEntity } from \"@aptero/axolotis-player\";\r\nimport SceneLoader from \"@root/lib/modules/spoke/SceneLoader\";\r\nimport { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\r\nimport { PlayerService } from \"@root/lib/modules/controller/PlayerService\";\r\nimport { load } from \"@root/lib/modules/spoke/PhoenixUtils\";\r\nimport { WebpackLazyModule } from \"@root/lib/generated/webpack/WebpackLoader\";\r\nimport { Services } from \"@aptero/axolotis-player\";\r\n\r\nexport class SpokeRoomLoader implements Component {\r\n  public sceneLoader: SceneLoader | null = null;\r\n\r\n  constructor(private threeLib: ThreeLib) {}\r\n\r\n  async loadRoom(hubid) {\r\n    const { data, hubPhxChannel, vapiddata } = await load(hubid);\r\n    const sceneURL = data.hubs[0].scene.model_url.replace(\".bin\", \".glb\");\r\n    this.sceneLoader = new SceneLoader();\r\n    await this.sceneLoader.loadScene(sceneURL, this.threeLib);\r\n  }\r\n\r\n  getType(): string {\r\n    return SpokeRoomLoader.name;\r\n  }\r\n}\r\n\r\nexport class Factory\r\n  implements WebpackLazyModule, ComponentFactory<SpokeRoomLoader>\r\n{\r\n  async createComponent(\r\n    world: WorldEntity,\r\n    config: any\r\n  ): Promise<SpokeRoomLoader> {\r\n    let services = world.getFirstComponentByType<Services>(Services.name);\r\n    let three = await services.getService<ThreeLib>(\r\n      \"@aptero/axolotis-core-plugins/three/ThreeLib\"\r\n    );\r\n    let playerService = await services.getService<PlayerService>(\r\n      \"@aptero/axolotis-core-plugins/controller/PlayerService\"\r\n    );\r\n    let spokeRoomLoader = new SpokeRoomLoader(three);\r\n    await spokeRoomLoader.loadRoom(config.room);\r\n    if (spokeRoomLoader.sceneLoader) {\r\n      playerService\r\n        .getCurrentPlayer()\r\n        .declareNavMesh(spokeRoomLoader.sceneLoader.navMesh);\r\n    }\r\n    return spokeRoomLoader;\r\n  }\r\n}\r\n\r\n/*\r\nHave to connect to the phoenix websocket\r\nand get scene url from message from\r\n[\"2\", \"2\", \"hub:yUXD7A2\", \"phx_reply\", {\r\n    \"response\": {\r\n        \"hub_requires_oauth\": false,\r\n        \"hubs\": [{\r\n            \"allow_promotion\": true,\r\n            \"description\": null,\r\n            \"embed_token\": \"c223b27b9e6f48c5591b4b140fe7de6f\",\r\n            \"entry_code\": 180429,\r\n            \"entry_mode\": \"allow\",\r\n            \"host\": \"dedicatedwebrtc3.aptero.co\",\r\n            \"hub_id\": \"yUXD7A2\",\r\n            \"lobby_count\": 0,\r\n            \"member_count\": 0,\r\n            \"member_permissions\": {\r\n                \"fly\": true,\r\n                \"pin_objects\": true,\r\n                \"spawn_and_move_media\": true,\r\n                \"spawn_camera\": true,\r\n                \"spawn_drawing\": true,\r\n                \"spawn_emoji\": true\r\n            },\r\n            \"name\": \"Lightweight Empty Room\",\r\n            \"port\": \"443\",\r\n            \"room_size\": 50,\r\n            \"scene\": {\r\n                \"account_id\": null,\r\n                \"allow_promotion\": false,\r\n                \"allow_remixing\": false,\r\n                \"attribution\": null,\r\n                \"attributions\": { \"content\": [], \"creator\": \"\" },\r\n                \"description\": null,\r\n                \"model_url\": \"https://alphahub.aptero.co/files/598eeed3-0768-408a-a75b-b0fcb8e907af.bin\",\r\n                \"name\": \"Museum\",\r\n                \"parent_scene_id\": null,\r\n                \"project_id\": \"wwDyQ8t\",\r\n                \"scene_id\": \"br4pVT2\",\r\n                \"screenshot_url\": \"https://alphahub.aptero.co/files/38473f11-615f-487d-b20b-f3b6558abea6.jpg\",\r\n                \"type\": \"scene\",\r\n                \"url\": \"https://alphahub.aptero.co/scenes/br4pVT2/museum\"\r\n            },\r\n            \"slug\": \"lightweight-empty-room\",\r\n            \"turn\": {\r\n                \"credential\": \"CWBiIUroBx9x7OITbxMrm54HiJw=\",\r\n                \"enabled\": true,\r\n                \"transports\": [{ \"port\": 5349 }],\r\n                \"username\": \"1636140736:coturn\"\r\n            },\r\n            \"user_data\": null\r\n        }],\r\n        \"perms_token\": \"eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJhY2NvdW50X2lkIjoiNjQwNDA3MDUwOTY2MjY5OTYxIiwiYW1wbGlmeV9hdWRpbyI6dHJ1ZSwiYXVkIjoicmV0X3Blcm1zIiwiY2xvc2VfaHViIjp0cnVlLCJjcmVhdGVfaHViIjp0cnVlLCJlbWJlZF9odWIiOnRydWUsImV4cCI6MTYzNjE0MDkxNiwiZmx5Ijp0cnVlLCJodWJfaWQiOiJ5VVhEN0EyIiwiaWF0IjoxNjM2MTQwNjE2LCJpc3MiOiIiLCJqb2luX2h1YiI6dHJ1ZSwianRpIjoiZjhkNGU2MDMtMWE0NC00MWRmLTg5NWMtNjE3ZGVhYzc5ZDI4Iiwia2lja191c2VycyI6dHJ1ZSwibXV0ZV91c2VycyI6dHJ1ZSwibmJmIjoxNjM2MTQwNjE1LCJwaW5fb2JqZWN0cyI6dHJ1ZSwicG9zdGdyZXN0X3JvbGUiOiJyZXRfYWRtaW4iLCJzcGF3bl9hbmRfbW92ZV9tZWRpYSI6dHJ1ZSwic3Bhd25fY2FtZXJhIjp0cnVlLCJzcGF3bl9kcmF3aW5nIjp0cnVlLCJzcGF3bl9lbW9qaSI6dHJ1ZSwic3ViIjoiNjQwNDA3MDUwOTY2MjY5OTYxX3lVWEQ3QTIiLCJ0d2VldCI6ZmFsc2UsInR5cCI6ImFjY2VzcyIsInVwZGF0ZV9odWIiOnRydWUsInVwZGF0ZV9odWJfcHJvbW90aW9uIjp0cnVlLCJ1cGRhdGVfcm9sZXMiOnRydWV9.qlNJloKYDmc2wSTaKF1eVYKKV_lCuuwzfdRnq3Jc-OP9P5uhKiFzo1i9N6rHBCIfITEwp8fJouD7TNOrBvpwFgxR1JHTgOpgWTdD6ltxRGspbtJRMJQ7qa66WTrVxKup4fI1ah70dFIsHu26GNdUaaNp8503VYuo41Dzs0XnTT1bLjbNM0ugJ_ZaF_d24b1m_7dLKdAn0-aZkoTQSCl3wzNDKLE90B2FJT6Mc7hqeo8d0mhr3yNQSRyJ4xLS0TBG4fvFZQL5H_bRD4Fk-q17jeMAgIAvtquElbs1cYRnQFE3g-PcsRYYRsejWaz4PEJUlZ5MM5tbohM5XoVHdRT8ZA\",\r\n        \"session_id\": \"a3c750b8-6446-4a1e-a638-c516073d8861\",\r\n        \"session_token\": \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJyZXRfc2Vzc2lvbiIsImV4cCI6MTYzNjIyNzAxNiwiaWF0IjoxNjM2MTQwNjE2LCJpc3MiOiIiLCJqdGkiOiIzNDk4Yjg4OC01NjA0LTQxYzctYWFmZC0xMjI5NmU4YmNlYTIiLCJuYmYiOjE2MzYxNDA2MTUsInNlc3Npb25faWQiOiJhM2M3NTBiOC02NDQ2LTRhMWUtYTYzOC1jNTE2MDczZDg4NjEiLCJzdWIiOiJhM2M3NTBiOC02NDQ2LTRhMWUtYTYzOC1jNTE2MDczZDg4NjEiLCJ0eXAiOiJhY2Nlc3MifQ.EbEzkgwNJ8_H4g8vxFI-ch9HprbzNh12xkfj-OrUOkUqTF-j-qEpsF-XFIZozSlCU2cwJVD7RLuxNOuqDVF76g\",\r\n        \"subscriptions\": { \"favorites\": true, \"web_push\": null }\r\n    }, \"status\": \"ok\"\r\n}];\r\n\r\n */\r\n"],"names":["SceneLoader","constructor","sceneUrl","threeLib","this","scene","mesh","loadAssets","traverse","node","isMesh","name","navMesh","add","closure","value","globalSelf","self","phxWindow","window","global","SOCKET_STATES","CHANNEL_STATES","CHANNEL_EVENTS","TRANSPORTS","XHR_STATES","Push","channel","event","payload","timeout","receivedResp","timeoutTimer","recHooks","sent","resend","reset","send","hasReceived","startTimeout","socket","push","topic","ref","join_ref","joinRef","receive","status","callback","response","cancelRefEvent","refEvent","matchReceive","_ref","filter","h","forEach","off","cancelTimeout","clearTimeout","makeRef","replyEventName","on","setTimeout","trigger","Timer","timerCalc","timer","tries","scheduleTimeout","Ajax","static","method","endPoint","accept","body","ontimeout","XDomainRequest","req","xdomainRequest","XMLHttpRequest","xhrRequest","open","onload","parseJSON","responseText","onprogress","setRequestHeader","onerror","onreadystatechange","readyState","resp","JSON","parse","e","console","log","obj","parentKey","queryStr","key","Object","prototype","hasOwnProperty","call","paramKey","paramVal","serialize","encodeURIComponent","join","url","params","keys","length","prefix","match","LongPoll","token","skipHeartbeat","onopen","onmessage","onclose","pollEndpoint","normalizeEndpoint","poll","replace","RegExp","endpointURL","appendParams","closeAndRetry","code","reason","wasClean","close","request","bind","messages","msg","data","Error","opts","assign","CloseEvent","serializer_default","HEADER_LENGTH","META_LENGTH","KINDS","reply","broadcast","encode","ArrayBuffer","binaryEncode","stringify","decode","rawPayload","binaryDecode","message","metaLength","header","view","DataView","offset","setUint8","Array","from","char","charCodeAt","combined","Uint8Array","byteLength","set","buffer","kind","getUint8","decoder","TextDecoder","decodePush","decodeReply","decodeBroadcast","joinRefSize","topicSize","eventSize","slice","refSize","Socket","stateChangeCallbacks","error","channels","sendBuffer","transport","WebSocket","establishedConnections","defaultEncoder","defaultDecoder","closeWasClean","binaryType","connectClock","awaitingConnectionOnPageShow","addEventListener","_e","conn","disconnect","connect","heartbeatIntervalMs","rejoinAfterMs","reconnectAfterMs","logger","longpollerTimeout","vsn","heartbeatTimer","pendingHeartbeatRef","reconnectTimer","teardown","replaceTransport","newTransport","protocol","location","endPointURL","uri","charAt","host","onConnOpen","onConnError","onConnMessage","onConnClose","hasLogger","onOpen","onClose","onError","onMessage","flushSendBuffer","resetHeartbeat","heartbeatTimeout","abnormalClose","sendHeartbeat","waitForBufferDone","waitForSocketClosed","bufferedAmount","closeCode","triggerChanError","transportBefore","establishedBefore","isErrored","isLeaving","isClosed","connectionState","isConnected","remove","stateChangeRefs","c","refs","indexOf","chanParams","chan","state","bindings","bindingRef","joinedOnce","joinPush","pushBuffer","rejoinTimer","rejoin","pushEvent","isJoining","canPush","isJoined","leave","leavePush","_event","isMember","leaveOpenTopic","handledPayload","eventBindings","i","result","newRef","toString","rawMessage","dupChannel","find","configs","async","load","hubid","debug","socketClass","qs","URLSearchParams","search","getNewSocketUrl","refreshDirectReticulumHostAndPort","port","directReticulumHostAndPort","get","document","socketUrl","socketSettings","invalidateReticulumMeta","endPointPath","URL","pathname","newSocketUrl","newEndPoint","connectToReticulum","hubPhxChannel","vapiddata","Promise","resolve","reject","hub_id","profile","avatarId","displayName","push_subscription_endpoint","auth_token","perms_token","bot_access_key","context","mobile","embed","hub_invite_id","res","reticulumMeta","invalidatedReticulumMetaThisSession","SpokeRoomLoader","sceneURL","hubs","model_url","sceneLoader","loadScene","getType","Factory","world","config","services","getFirstComponentByType","Services","three","getService","playerService","spokeRoomLoader","loadRoom","room","getCurrentPlayer","declareNavMesh"],"sourceRoot":""}