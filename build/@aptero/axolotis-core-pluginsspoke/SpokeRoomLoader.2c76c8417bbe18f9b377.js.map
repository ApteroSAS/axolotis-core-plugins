{"version":3,"file":"@aptero/axolotis-core-pluginsspoke/SpokeRoomLoader.2c76c8417bbe18f9b377.js","mappings":";;;;;;;;;;;wVAEe,MAAMA,EAKnBC,cAAc,sEAEC,gBAACC,EAAkBC,GAChCC,KAAKC,MAAQF,EAASE,MACtBD,KAAKE,WAAaH,EAASI,WAAWL,GACtCE,KAAKE,KAAOF,KAAKE,KAAKD,MAEtBD,KAAKE,KAAKE,UAAUC,IACdA,EAAKC,QACW,YAAdD,EAAKE,OACPP,KAAKQ,QAAUH,MAKrBL,KAAKC,MAAMQ,IAAIT,KAAKE,OCrBxB,IAAIQ,EAAWC,IACb,GAAqB,mBAAVA,EACT,OAAOA,EAKP,OAHe,WACb,OAAOA,IAOTC,EAA6B,oBAATC,KAAuBA,KAAO,KAClDC,EAA8B,oBAAXC,OAAyBA,OAAS,KACrDC,EAASJ,GAAcE,QAAa,EAEpCG,EAA8B,EAA9BA,EAAuC,EAAvCA,EAAmD,EAAnDA,EAA8D,EAG9DC,EACM,SADNA,EAEO,UAFPA,EAGM,SAHNA,EAIO,UAJPA,EAKO,UAEPC,EACK,YADLA,EAEK,YAFLA,EAGI,WAHJA,EAIK,YAJLA,EAKK,YAELC,EACQ,WADRA,EAES,YAETC,EACQ,EAIRC,EAAO,MACTzB,YAAY0B,EAASC,EAAOC,EAASC,GACnC1B,KAAKuB,QAAUA,EACfvB,KAAKwB,MAAQA,EACbxB,KAAKyB,QAAUA,GAAW,WACxB,MAAO,IAETzB,KAAK2B,aAAe,KACpB3B,KAAK0B,QAAUA,EACf1B,KAAK4B,aAAe,KACpB5B,KAAK6B,SAAW,GAChB7B,KAAK8B,MAAO,EAEdC,OAAOL,GACL1B,KAAK0B,QAAUA,EACf1B,KAAKgC,QACLhC,KAAKiC,OAEPA,OACMjC,KAAKkC,YAAY,aAGrBlC,KAAKmC,eACLnC,KAAK8B,MAAO,EACZ9B,KAAKuB,QAAQa,OAAOC,KAAK,CACvBC,MAAOtC,KAAKuB,QAAQe,MACpBd,MAAOxB,KAAKwB,MACZC,QAASzB,KAAKyB,UACdc,IAAKvC,KAAKuC,IACVC,SAAUxC,KAAKuB,QAAQkB,aAG3BC,QAAQC,EAAQC,GAKd,OAJI5C,KAAKkC,YAAYS,IACnBC,EAAS5C,KAAK2B,aAAakB,UAE7B7C,KAAK6B,SAASQ,KAAK,CAAEM,OAAAA,EAAQC,SAAAA,IACtB5C,KAETgC,QACEhC,KAAK8C,iBACL9C,KAAKuC,IAAM,KACXvC,KAAK+C,SAAW,KAChB/C,KAAK2B,aAAe,KACpB3B,KAAK8B,MAAO,EAEdkB,cAAa,OAAEL,EAAM,SAAEE,EAAQ,KAAEI,IAC/BjD,KAAK6B,SAASqB,QAAQC,GAAMA,EAAER,SAAWA,IAAQS,SAASD,GAAMA,EAAEP,SAASC,KAE7EC,iBACO9C,KAAK+C,UAGV/C,KAAKuB,QAAQ8B,IAAIrD,KAAK+C,UAExBO,gBACEC,aAAavD,KAAK4B,cAClB5B,KAAK4B,aAAe,KAEtBO,eACMnC,KAAK4B,cACP5B,KAAKsD,gBAEPtD,KAAKuC,IAAMvC,KAAKuB,QAAQa,OAAOoB,UAC/BxD,KAAK+C,SAAW/C,KAAKuB,QAAQkC,eAAezD,KAAKuC,KACjDvC,KAAKuB,QAAQmC,GAAG1D,KAAK+C,UAAWtB,IAC9BzB,KAAK8C,iBACL9C,KAAKsD,gBACLtD,KAAK2B,aAAeF,EACpBzB,KAAKgD,aAAavB,MAEpBzB,KAAK4B,aAAe+B,YAAW,KAC7B3D,KAAK4D,QAAQ,UAAW,MACvB5D,KAAK0B,SAEVQ,YAAYS,GACV,OAAO3C,KAAK2B,cAAgB3B,KAAK2B,aAAagB,SAAWA,EAE3DiB,QAAQjB,EAAQE,GACd7C,KAAKuB,QAAQqC,QAAQ5D,KAAK+C,SAAU,CAAEJ,OAAAA,EAAQE,SAAAA,MAK9CgB,EAAQ,MACVhE,YAAY+C,EAAUkB,GACpB9D,KAAK4C,SAAWA,EAChB5C,KAAK8D,UAAYA,EACjB9D,KAAK+D,MAAQ,KACb/D,KAAKgE,MAAQ,EAEfhC,QACEhC,KAAKgE,MAAQ,EACbT,aAAavD,KAAK+D,OAEpBE,kBACEV,aAAavD,KAAK+D,OAClB/D,KAAK+D,MAAQJ,YAAW,KACtB3D,KAAKgE,MAAQhE,KAAKgE,MAAQ,EAC1BhE,KAAK4C,aACJ5C,KAAK8D,UAAU9D,KAAKgE,MAAQ,MAmM/BE,EAAO,MACTC,eAAeC,EAAQC,EAAUC,EAAQC,EAAM7C,EAAS8C,EAAW5B,GACjE,GAAI5B,EAAOyD,eAAgB,CACzB,IAAIC,EAAM,IAAI1D,EAAOyD,eACrBzE,KAAK2E,eAAeD,EAAKN,EAAQC,EAAUE,EAAM7C,EAAS8C,EAAW5B,OAChE,CACL,IAAI8B,EAAM,IAAI1D,EAAO4D,eACrB5E,KAAK6E,WAAWH,EAAKN,EAAQC,EAAUC,EAAQC,EAAM7C,EAAS8C,EAAW5B,IAG7EuB,sBAAsBO,EAAKN,EAAQC,EAAUE,EAAM7C,EAAS8C,EAAW5B,GACrE8B,EAAIhD,QAAUA,EACdgD,EAAII,KAAKV,EAAQC,GACjBK,EAAIK,OAAS,KACX,IAAIlC,EAAW7C,KAAKgF,UAAUN,EAAIO,cAClCrC,GAAYA,EAASC,IAEnB2B,IACFE,EAAIF,UAAYA,GAElBE,EAAIQ,WAAa,OAEjBR,EAAIzC,KAAKsC,GAEXJ,kBAAkBO,EAAKN,EAAQC,EAAUC,EAAQC,EAAM7C,EAAS8C,EAAW5B,GACzE8B,EAAII,KAAKV,EAAQC,GAAU,GAC3BK,EAAIhD,QAAUA,EACdgD,EAAIS,iBAAiB,eAAgBb,GACrCI,EAAIU,QAAU,KACZxC,GAAYA,EAAS,OAEvB8B,EAAIW,mBAAqB,KACvB,GAAIX,EAAIY,aAAejE,GAAuBuB,EAAU,CACtD,IAAIC,EAAW7C,KAAKgF,UAAUN,EAAIO,cAClCrC,EAASC,KAGT2B,IACFE,EAAIF,UAAYA,GAElBE,EAAIzC,KAAKsC,GAEXJ,iBAAiBoB,GACf,IAAKA,GAAiB,KAATA,EACX,OAAO,KAET,IACE,OAAOC,KAAKC,MAAMF,GAClB,MAAOG,GAEP,OADAC,SAAWA,QAAQC,IAAI,gCAAiCL,GACjD,MAGXpB,iBAAiB0B,EAAKC,GACpB,IAAIC,EAAW,GACf,IAAK,IAAIC,KAAOH,EAAK,CACnB,IAAKI,OAAOC,UAAUC,eAAeC,KAAKP,EAAKG,GAC7C,SAEF,IAAIK,EAAWP,EAAY,GAAGA,KAAaE,KAASA,EAChDM,EAAWT,EAAIG,GACK,iBAAbM,EACTP,EAAS1D,KAAKrC,KAAKuG,UAAUD,EAAUD,IAEvCN,EAAS1D,KAAKmE,mBAAmBH,GAAY,IAAMG,mBAAmBF,IAG1E,OAAOP,EAASU,KAAK,KAEvBtC,oBAAoBuC,EAAKC,GACvB,GAAmC,IAA/BV,OAAOW,KAAKD,GAAQE,OACtB,OAAOH,EAET,IAAII,EAASJ,EAAIK,MAAM,MAAQ,IAAM,IACrC,MAAO,GAAGL,IAAMI,IAAS9G,KAAKuG,UAAUI,OAKxCK,EAAW,MACbnH,YAAYwE,GACVrE,KAAKqE,SAAW,KAChBrE,KAAKiH,MAAQ,KACbjH,KAAKkH,eAAgB,EACrBlH,KAAKmH,OAAS,aAEdnH,KAAKoF,QAAU,aAEfpF,KAAKoH,UAAY,aAEjBpH,KAAKqH,QAAU,aAEfrH,KAAKsH,aAAetH,KAAKuH,kBAAkBlD,GAC3CrE,KAAKsF,WAAarE,EAClBjB,KAAKwH,OAEPD,kBAAkBlD,GAChB,OAAOA,EAASoD,QAAQ,QAAS,WAAWA,QAAQ,SAAU,YAAYA,QAAQ,IAAIC,OAAO,QAAUtG,GAAuB,MAAQA,GAExIuG,cACE,OAAOzD,EAAK0D,aAAa5H,KAAKsH,aAAc,CAAEL,MAAOjH,KAAKiH,QAE5DY,gBACE7H,KAAK8H,QACL9H,KAAKsF,WAAarE,EAEpBuD,YACExE,KAAKoF,QAAQ,WACbpF,KAAK6H,gBAEPL,OACQxH,KAAKsF,aAAerE,GAAsBjB,KAAKsF,aAAerE,GAGpEiD,EAAK6D,QAAQ,MAAO/H,KAAK2H,cAAe,mBAAoB,KAAM3H,KAAK0B,QAAS1B,KAAKwE,UAAUwD,KAAKhI,OAAQuF,IAC1G,GAAIA,EAAM,CACR,IAAI,OAAE5C,EAAM,MAAEsE,EAAK,SAAEgB,GAAa1C,EAClCvF,KAAKiH,MAAQA,OAEbtE,EAAS,EAEX,OAAQA,GACN,KAAK,IACHsF,EAAS7E,SAAS8E,IAChBvE,YAAW,KACT3D,KAAKoH,UAAU,CAAEe,KAAMD,MACtB,MAELlI,KAAKwH,OACL,MACF,KAAK,IACHxH,KAAKwH,OACL,MACF,KAAK,IACHxH,KAAKsF,WAAarE,EAClBjB,KAAKmH,SACLnH,KAAKwH,OACL,MACF,KAAK,IACHxH,KAAKoF,UACLpF,KAAK8H,QACL,MACF,KAAK,EACL,KAAK,IACH9H,KAAKoF,UACLpF,KAAK6H,gBACL,MACF,QACE,MAAM,IAAIO,MAAM,yBAAyBzF,SAIjDV,KAAKsC,GACHL,EAAK6D,QAAQ,OAAQ/H,KAAK2H,cAAe,mBAAoBpD,EAAMvE,KAAK0B,QAAS1B,KAAKoF,QAAQ4C,KAAKhI,KAAM,YAAauF,IAC/GA,GAAwB,MAAhBA,EAAK5C,SAChB3C,KAAKoF,QAAQG,GAAQA,EAAK5C,QAC1B3C,KAAK6H,oBAIXC,MAAMO,EAAOC,GACXtI,KAAKsF,WAAarE,EAClBjB,KAAKqH,YA4ILkB,EAAqB,CACvBC,cAAe,EACfC,YAAa,EACbC,MAAO,CAAErG,KAAM,EAAGsG,MAAO,EAAGC,UAAW,GACvCC,OAAOX,EAAKtF,GACV,GAAIsF,EAAIzG,QAAQ5B,cAAgBiJ,YAC9B,OAAOlG,EAAS5C,KAAK+I,aAAab,IAC7B,CACL,IAAIzG,EAAU,CAACyG,EAAI1F,SAAU0F,EAAI3F,IAAK2F,EAAI5F,MAAO4F,EAAI1G,MAAO0G,EAAIzG,SAChE,OAAOmB,EAAS4C,KAAKwD,UAAUvH,MAGnCwH,OAAOC,EAAYtG,GACjB,GAAIsG,EAAWrJ,cAAgBiJ,YAC7B,OAAOlG,EAAS5C,KAAKmJ,aAAaD,IAC7B,CACL,IAAK1G,EAAUD,EAAKD,EAAOd,EAAOC,GAAW+D,KAAKC,MAAMyD,GACxD,OAAOtG,EAAS,CAAEJ,SAAAA,EAAUD,IAAAA,EAAKD,MAAAA,EAAOd,MAAAA,EAAOC,QAAAA,MAGnDsH,aAAaK,GACX,IAAI,SAAE5G,EAAQ,IAAED,EAAG,MAAEf,EAAK,MAAEc,EAAK,QAAEb,GAAY2H,EAC3CC,EAAarJ,KAAKyI,YAAcjG,EAASqE,OAAStE,EAAIsE,OAASvE,EAAMuE,OAASrF,EAAMqF,OACpFyC,EAAS,IAAIR,YAAY9I,KAAKwI,cAAgBa,GAC9CE,EAAO,IAAIC,SAASF,GACpBG,EAAS,EACbF,EAAKG,SAASD,IAAUzJ,KAAK0I,MAAMrG,MACnCkH,EAAKG,SAASD,IAAUjH,EAASqE,QACjC0C,EAAKG,SAASD,IAAUlH,EAAIsE,QAC5B0C,EAAKG,SAASD,IAAUnH,EAAMuE,QAC9B0C,EAAKG,SAASD,IAAUjI,EAAMqF,QAC9B8C,MAAMC,KAAKpH,GAAWqH,GAASN,EAAKG,SAASD,IAAUI,EAAKC,WAAW,MACvEH,MAAMC,KAAKrH,GAAMsH,GAASN,EAAKG,SAASD,IAAUI,EAAKC,WAAW,MAClEH,MAAMC,KAAKtH,GAAQuH,GAASN,EAAKG,SAASD,IAAUI,EAAKC,WAAW,MACpEH,MAAMC,KAAKpI,GAAQqI,GAASN,EAAKG,SAASD,IAAUI,EAAKC,WAAW,MACpE,IAAIC,EAAW,IAAIC,WAAWV,EAAOW,WAAaxI,EAAQwI,YAG1D,OAFAF,EAASG,IAAI,IAAIF,WAAWV,GAAS,GACrCS,EAASG,IAAI,IAAIF,WAAWvI,GAAU6H,EAAOW,YACtCF,EAASI,QAElBhB,aAAagB,GACX,IAAIZ,EAAO,IAAIC,SAASW,GACpBC,EAAOb,EAAKc,SAAS,GACrBC,EAAU,IAAIC,YAClB,OAAQH,GACN,KAAKpK,KAAK0I,MAAMrG,KACd,OAAOrC,KAAKwK,WAAWL,EAAQZ,EAAMe,GACvC,KAAKtK,KAAK0I,MAAMC,MACd,OAAO3I,KAAKyK,YAAYN,EAAQZ,EAAMe,GACxC,KAAKtK,KAAK0I,MAAME,UACd,OAAO5I,KAAK0K,gBAAgBP,EAAQZ,EAAMe,KAGhDE,WAAWL,EAAQZ,EAAMe,GACvB,IAAIK,EAAcpB,EAAKc,SAAS,GAC5BO,EAAYrB,EAAKc,SAAS,GAC1BQ,EAAYtB,EAAKc,SAAS,GAC1BZ,EAASzJ,KAAKwI,cAAgBxI,KAAKyI,YAAc,EACjDhG,EAAU6H,EAAQrB,OAAOkB,EAAOW,MAAMrB,EAAQA,EAASkB,IAC3DlB,GAAkBkB,EAClB,IAAIrI,EAAQgI,EAAQrB,OAAOkB,EAAOW,MAAMrB,EAAQA,EAASmB,IACzDnB,GAAkBmB,EAClB,IAAIpJ,EAAQ8I,EAAQrB,OAAOkB,EAAOW,MAAMrB,EAAQA,EAASoB,IAGzD,OAFApB,GAAkBoB,EAEX,CAAErI,SAAUC,EAASF,IAAK,KAAMD,MAAAA,EAAOd,MAAAA,EAAOC,QAD1C0I,EAAOW,MAAMrB,EAAQU,EAAOF,cAGzCQ,YAAYN,EAAQZ,EAAMe,GACxB,IAAIK,EAAcpB,EAAKc,SAAS,GAC5BU,EAAUxB,EAAKc,SAAS,GACxBO,EAAYrB,EAAKc,SAAS,GAC1BQ,EAAYtB,EAAKc,SAAS,GAC1BZ,EAASzJ,KAAKwI,cAAgBxI,KAAKyI,YACnChG,EAAU6H,EAAQrB,OAAOkB,EAAOW,MAAMrB,EAAQA,EAASkB,IAC3DlB,GAAkBkB,EAClB,IAAIpI,EAAM+H,EAAQrB,OAAOkB,EAAOW,MAAMrB,EAAQA,EAASsB,IACvDtB,GAAkBsB,EAClB,IAAIzI,EAAQgI,EAAQrB,OAAOkB,EAAOW,MAAMrB,EAAQA,EAASmB,IACzDnB,GAAkBmB,EAClB,IAAIpJ,EAAQ8I,EAAQrB,OAAOkB,EAAOW,MAAMrB,EAAQA,EAASoB,IACzDpB,GAAkBoB,EAClB,IAAI1C,EAAOgC,EAAOW,MAAMrB,EAAQU,EAAOF,YAEvC,MAAO,CAAEzH,SAAUC,EAASF,IAAAA,EAAKD,MAAAA,EAAOd,MAAOL,EAAsBM,QADvD,CAAEkB,OAAQnB,EAAOqB,SAAUsF,KAG3CuC,gBAAgBP,EAAQZ,EAAMe,GAC5B,IAAIM,EAAYrB,EAAKc,SAAS,GAC1BQ,EAAYtB,EAAKc,SAAS,GAC1BZ,EAASzJ,KAAKwI,cAAgB,EAC9BlG,EAAQgI,EAAQrB,OAAOkB,EAAOW,MAAMrB,EAAQA,EAASmB,IACzDnB,GAAkBmB,EAClB,IAAIpJ,EAAQ8I,EAAQrB,OAAOkB,EAAOW,MAAMrB,EAAQA,EAASoB,IAGzD,OAFApB,GAAkBoB,EAEX,CAAErI,SAAU,KAAMD,IAAK,KAAMD,MAAAA,EAAOd,MAAAA,EAAOC,QADvC0I,EAAOW,MAAMrB,EAAQU,EAAOF,eAMvCe,EAAS,MACXnL,YAAYwE,EAAU4G,EAAO,IAC3BjL,KAAKkL,qBAAuB,CAAEpG,KAAM,GAAIgD,MAAO,GAAIqD,MAAO,GAAI/B,QAAS,IACvEpJ,KAAKoL,SAAW,GAChBpL,KAAKqL,WAAa,GAClBrL,KAAKuC,IAAM,EACXvC,KAAK0B,QAAUuJ,EAAKvJ,SAvtBF,IAwtBlB1B,KAAKsL,UAAYL,EAAKK,WAAatK,EAAOuK,WAAavE,EACvDhH,KAAKwL,uBAAyB,EAC9BxL,KAAKyL,eAAiBlD,EAAmBM,OAAOb,KAAKO,GACrDvI,KAAK0L,eAAiBnD,EAAmBU,OAAOjB,KAAKO,GACrDvI,KAAK2L,eAAgB,EACrB3L,KAAK4L,WAAaX,EAAKW,YAAc,cACrC5L,KAAK6L,aAAe,EAChB7L,KAAKsL,YAActE,GACrBhH,KAAK6I,OAASoC,EAAKpC,QAAU7I,KAAKyL,eAClCzL,KAAKiJ,OAASgC,EAAKhC,QAAUjJ,KAAK0L,iBAElC1L,KAAK6I,OAAS7I,KAAKyL,eACnBzL,KAAKiJ,OAASjJ,KAAK0L,gBAErB,IAAII,EAA+B,KAC/BhL,GAAaA,EAAUiL,mBACzBjL,EAAUiL,iBAAiB,YAAaC,IAClChM,KAAKiM,OACPjM,KAAKkM,aACLJ,EAA+B9L,KAAK6L,iBAGxC/K,EAAUiL,iBAAiB,YAAaC,IAClCF,IAAiC9L,KAAK6L,eACxCC,EAA+B,KAC/B9L,KAAKmM,eAIXnM,KAAKoM,oBAAsBnB,EAAKmB,qBAAuB,IACvDpM,KAAKqM,cAAiBrI,GAChBiH,EAAKoB,cACApB,EAAKoB,cAAcrI,GAEnB,CAAC,IAAK,IAAK,KAAKA,EAAQ,IAAM,IAGzChE,KAAKsM,iBAAoBtI,GACnBiH,EAAKqB,iBACArB,EAAKqB,iBAAiBtI,GAEtB,CAAC,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAKA,EAAQ,IAAM,IAGrEhE,KAAKuM,OAAStB,EAAKsB,QAAU,KAC7BvM,KAAKwM,kBAAoBvB,EAAKuB,mBAAqB,IACnDxM,KAAK2G,OAASjG,EAAQuK,EAAKtE,QAAU,IACrC3G,KAAKqE,SAAW,GAAGA,KAAYjD,IAC/BpB,KAAKyM,IAAMxB,EAAKwB,KA1wBF,QA2wBdzM,KAAK0M,eAAiB,KACtB1M,KAAK2M,oBAAsB,KAC3B3M,KAAK4M,eAAiB,IAAI/I,GAAM,KAC9B7D,KAAK6M,UAAS,IAAM7M,KAAKmM,cACxBnM,KAAKsM,kBAEVQ,iBAAiBC,GACf/M,KAAKkM,aACLlM,KAAKsL,UAAYyB,EAEnBC,WACE,OAAOC,SAASD,SAASjG,MAAM,UAAY,MAAQ,KAErDmG,cACE,IAAIC,EAAMjJ,EAAK0D,aAAa1D,EAAK0D,aAAa5H,KAAKqE,SAAUrE,KAAK2G,UAAW,CAAE8F,IAAKzM,KAAKyM,MACzF,MAAsB,MAAlBU,EAAIC,OAAO,GACND,EAEa,MAAlBA,EAAIC,OAAO,GACN,GAAGpN,KAAKgN,cAAcG,IAExB,GAAGnN,KAAKgN,gBAAgBC,SAASI,OAAOF,IAEjDjB,WAAWtJ,EAAU0K,EAAMC,GACzBvN,KAAK6L,eACL7L,KAAK2L,eAAgB,EACrB3L,KAAK4M,eAAe5K,QACpBhC,KAAK6M,SAASjK,EAAU0K,EAAMC,GAEhCpB,QAAQxF,GACN3G,KAAK6L,eACDlF,IACFhB,SAAWA,QAAQC,IAAI,2FACvB5F,KAAK2G,OAASjG,EAAQiG,IAEpB3G,KAAKiM,OAGTjM,KAAK2L,eAAgB,EACrB3L,KAAKiM,KAAO,IAAIjM,KAAKsL,UAAUtL,KAAKkN,eACpClN,KAAKiM,KAAKL,WAAa5L,KAAK4L,WAC5B5L,KAAKiM,KAAKvK,QAAU1B,KAAKwM,kBACzBxM,KAAKiM,KAAK9E,OAAS,IAAMnH,KAAKwN,aAC9BxN,KAAKiM,KAAK7G,QAAW+F,GAAUnL,KAAKyN,YAAYtC,GAChDnL,KAAKiM,KAAK7E,UAAa5F,GAAUxB,KAAK0N,cAAclM,GACpDxB,KAAKiM,KAAK5E,QAAW7F,GAAUxB,KAAK2N,YAAYnM,IAElDoE,IAAIwE,EAAMlC,EAAKC,GACbnI,KAAKuM,OAAOnC,EAAMlC,EAAKC,GAEzByF,YACE,OAAuB,OAAhB5N,KAAKuM,OAEdsB,OAAOjL,GACL,IAAIL,EAAMvC,KAAKwD,UAEf,OADAxD,KAAKkL,qBAAqBpG,KAAKzC,KAAK,CAACE,EAAKK,IACnCL,EAETuL,QAAQlL,GACN,IAAIL,EAAMvC,KAAKwD,UAEf,OADAxD,KAAKkL,qBAAqBpD,MAAMzF,KAAK,CAACE,EAAKK,IACpCL,EAETwL,QAAQnL,GACN,IAAIL,EAAMvC,KAAKwD,UAEf,OADAxD,KAAKkL,qBAAqBC,MAAM9I,KAAK,CAACE,EAAKK,IACpCL,EAETyL,UAAUpL,GACR,IAAIL,EAAMvC,KAAKwD,UAEf,OADAxD,KAAKkL,qBAAqB9B,QAAQ/G,KAAK,CAACE,EAAKK,IACtCL,EAETiL,aACMxN,KAAK4N,aACP5N,KAAK4F,IAAI,YAAa,gBAAgB5F,KAAKkN,iBAC7ClN,KAAK2L,eAAgB,EACrB3L,KAAKwL,yBACLxL,KAAKiO,kBACLjO,KAAK4M,eAAe5K,QACpBhC,KAAKkO,iBACLlO,KAAKkL,qBAAqBpG,KAAK1B,SAAQ,EAAE,CAAER,KAAcA,MAE3DuL,mBACMnO,KAAK2M,sBACP3M,KAAK2M,oBAAsB,KACvB3M,KAAK4N,aACP5N,KAAK4F,IAAI,YAAa,4DAExB5F,KAAKoO,cAAc,sBAGvBF,iBACMlO,KAAKiM,MAAQjM,KAAKiM,KAAK/E,gBAG3BlH,KAAK2M,oBAAsB,KAC3BpJ,aAAavD,KAAK0M,gBAClB/I,YAAW,IAAM3D,KAAKqO,iBAAiBrO,KAAKoM,sBAE9CS,SAASjK,EAAU0K,EAAMC,GACvB,IAAKvN,KAAKiM,KACR,OAAOrJ,GAAYA,IAErB5C,KAAKsO,mBAAkB,KACjBtO,KAAKiM,OACHqB,EACFtN,KAAKiM,KAAKnE,MAAMwF,EAAMC,GAAU,IAEhCvN,KAAKiM,KAAKnE,SAGd9H,KAAKuO,qBAAoB,KACnBvO,KAAKiM,OACPjM,KAAKiM,KAAK5E,QAAU,aAEpBrH,KAAKiM,KAAO,MAEdrJ,GAAYA,UAIlB0L,kBAAkB1L,EAAUoB,EAAQ,GACpB,IAAVA,GAAgBhE,KAAKiM,MAASjM,KAAKiM,KAAKuC,eAI5C7K,YAAW,KACT3D,KAAKsO,kBAAkB1L,EAAUoB,EAAQ,KACxC,IAAMA,GALPpB,IAOJ2L,oBAAoB3L,EAAUoB,EAAQ,GACtB,IAAVA,GAAgBhE,KAAKiM,MAAQjM,KAAKiM,KAAK3G,aAAerE,EAI1D0C,YAAW,KACT3D,KAAKuO,oBAAoB3L,EAAUoB,EAAQ,KAC1C,IAAMA,GALPpB,IAOJ+K,YAAYnM,GACV,IAAIiN,EAAYjN,GAASA,EAAM8L,KAC3BtN,KAAK4N,aACP5N,KAAK4F,IAAI,YAAa,QAASpE,GACjCxB,KAAK0O,mBACLnL,aAAavD,KAAK0M,gBACb1M,KAAK2L,eAA+B,MAAd8C,GACzBzO,KAAK4M,eAAe3I,kBAEtBjE,KAAKkL,qBAAqBpD,MAAM1E,SAAQ,EAAE,CAAER,KAAcA,EAASpB,KAErEiM,YAAYtC,GACNnL,KAAK4N,aACP5N,KAAK4F,IAAI,YAAauF,GACxB,IAAIwD,EAAkB3O,KAAKsL,UACvBsD,EAAoB5O,KAAKwL,uBAC7BxL,KAAKkL,qBAAqBC,MAAM/H,SAAQ,EAAE,CAAER,MAC1CA,EAASuI,EAAOwD,EAAiBC,OAE/BD,IAAoB3O,KAAKsL,WAAasD,EAAoB,IAC5D5O,KAAK0O,mBAGTA,mBACE1O,KAAKoL,SAAShI,SAAS7B,IACfA,EAAQsN,aAAetN,EAAQuN,aAAevN,EAAQwN,YAC1DxN,EAAQqC,QAAQzC,MAItB6N,kBACE,OAAQhP,KAAKiM,MAAQjM,KAAKiM,KAAK3G,YAC7B,KAAKrE,EACH,MAAO,aACT,KAAKA,EACH,MAAO,OACT,KAAKA,EACH,MAAO,UACT,QACE,MAAO,UAGbgO,cACE,MAAkC,SAA3BjP,KAAKgP,kBAEdE,OAAO3N,GACLvB,KAAKqD,IAAI9B,EAAQ4N,iBACjBnP,KAAKoL,SAAWpL,KAAKoL,SAASlI,QAAQkM,GAAMA,EAAE3M,YAAclB,EAAQkB,YAEtEY,IAAIgM,GACF,IAAK,IAAIrJ,KAAOhG,KAAKkL,qBACnBlL,KAAKkL,qBAAqBlF,GAAOhG,KAAKkL,qBAAqBlF,GAAK9C,QAAO,EAAEX,MACzC,IAAvB8M,EAAKC,QAAQ/M,KAI1BhB,QAAQe,EAAOiN,EAAa,IAC1B,IAAIC,EAAO,IA50BD,MACZ3P,YAAYyC,EAAOqE,EAAQvE,GACzBpC,KAAKyP,MAAQvO,EACblB,KAAKsC,MAAQA,EACbtC,KAAK2G,OAASjG,EAAQiG,GAAU,IAChC3G,KAAKoC,OAASA,EACdpC,KAAK0P,SAAW,GAChB1P,KAAK2P,WAAa,EAClB3P,KAAK0B,QAAU1B,KAAKoC,OAAOV,QAC3B1B,KAAK4P,YAAa,EAClB5P,KAAK6P,SAAW,IAAIvO,EAAKtB,KAAMmB,EAAqBnB,KAAK2G,OAAQ3G,KAAK0B,SACtE1B,KAAK8P,WAAa,GAClB9P,KAAKmP,gBAAkB,GACvBnP,KAAK+P,YAAc,IAAIlM,GAAM,KACvB7D,KAAKoC,OAAO6M,eACdjP,KAAKgQ,WAENhQ,KAAKoC,OAAOiK,eACfrM,KAAKmP,gBAAgB9M,KAAKrC,KAAKoC,OAAO2L,SAAQ,IAAM/N,KAAK+P,YAAY/N,WACrEhC,KAAKmP,gBAAgB9M,KAAKrC,KAAKoC,OAAOyL,QAAO,KAC3C7N,KAAK+P,YAAY/N,QACbhC,KAAK6O,aACP7O,KAAKgQ,aAGThQ,KAAK6P,SAASnN,QAAQ,MAAM,KAC1B1C,KAAKyP,MAAQvO,EACblB,KAAK+P,YAAY/N,QACjBhC,KAAK8P,WAAW1M,SAAS6M,GAAcA,EAAUhO,SACjDjC,KAAK8P,WAAa,MAEpB9P,KAAK6P,SAASnN,QAAQ,SAAS,KAC7B1C,KAAKyP,MAAQvO,EACTlB,KAAKoC,OAAO6M,eACdjP,KAAK+P,YAAY9L,qBAGrBjE,KAAK8N,SAAQ,KACX9N,KAAK+P,YAAY/N,QACbhC,KAAKoC,OAAOwL,aACd5N,KAAKoC,OAAOwD,IAAI,UAAW,SAAS5F,KAAKsC,SAAStC,KAAKyC,aACzDzC,KAAKyP,MAAQvO,EACblB,KAAKoC,OAAO8M,OAAOlP,SAErBA,KAAK+N,SAASR,IACRvN,KAAKoC,OAAOwL,aACd5N,KAAKoC,OAAOwD,IAAI,UAAW,SAAS5F,KAAKsC,QAASiL,GAChDvN,KAAKkQ,aACPlQ,KAAK6P,SAAS7N,QAEhBhC,KAAKyP,MAAQvO,EACTlB,KAAKoC,OAAO6M,eACdjP,KAAK+P,YAAY9L,qBAGrBjE,KAAK6P,SAASnN,QAAQ,WAAW,KAC3B1C,KAAKoC,OAAOwL,aACd5N,KAAKoC,OAAOwD,IAAI,UAAW,WAAW5F,KAAKsC,UAAUtC,KAAKyC,aAAczC,KAAK6P,SAASnO,SACxE,IAAIJ,EAAKtB,KAAMmB,EAAsBT,EAAQ,IAAKV,KAAK0B,SAC7DO,OACVjC,KAAKyP,MAAQvO,EACblB,KAAK6P,SAAS7N,QACVhC,KAAKoC,OAAO6M,eACdjP,KAAK+P,YAAY9L,qBAGrBjE,KAAK0D,GAAGvC,GAAsB,CAACM,EAASc,KACtCvC,KAAK4D,QAAQ5D,KAAKyD,eAAelB,GAAMd,MAG3CgF,KAAK/E,EAAU1B,KAAK0B,SAClB,GAAI1B,KAAK4P,WACP,MAAM,IAAIxH,MAAM,8FAKhB,OAHApI,KAAK0B,QAAUA,EACf1B,KAAK4P,YAAa,EAClB5P,KAAKgQ,SACEhQ,KAAK6P,SAGhB/B,QAAQlL,GACN5C,KAAK0D,GAAGvC,EAAsByB,GAEhCmL,QAAQnL,GACN,OAAO5C,KAAK0D,GAAGvC,GAAuBoM,GAAW3K,EAAS2K,KAE5D7J,GAAGlC,EAAOoB,GACR,IAAIL,EAAMvC,KAAK2P,aAEf,OADA3P,KAAK0P,SAASrN,KAAK,CAAEb,MAAAA,EAAOe,IAAAA,EAAKK,SAAAA,IAC1BL,EAETc,IAAI7B,EAAOe,GACTvC,KAAK0P,SAAW1P,KAAK0P,SAASxM,QAAQ8E,KAC3BA,EAAKxG,QAAUA,SAAyB,IAARe,GAAuBA,IAAQyF,EAAKzF,QAGjF4N,UACE,OAAOnQ,KAAKoC,OAAO6M,eAAiBjP,KAAKoQ,WAE3C/N,KAAKb,EAAOC,EAASC,EAAU1B,KAAK0B,SAElC,GADAD,EAAUA,GAAW,IAChBzB,KAAK4P,WACR,MAAM,IAAIxH,MAAM,kBAAkB5G,UAAcxB,KAAKsC,mEAEvD,IAAI2N,EAAY,IAAI3O,EAAKtB,KAAMwB,GAAO,WACpC,OAAOC,IACNC,GAOH,OANI1B,KAAKmQ,UACPF,EAAUhO,QAEVgO,EAAU9N,eACVnC,KAAK8P,WAAWzN,KAAK4N,IAEhBA,EAETI,MAAM3O,EAAU1B,KAAK0B,SACnB1B,KAAK+P,YAAY/N,QACjBhC,KAAK6P,SAASvM,gBACdtD,KAAKyP,MAAQvO,EACb,IAAI4M,EAAU,KACR9N,KAAKoC,OAAOwL,aACd5N,KAAKoC,OAAOwD,IAAI,UAAW,SAAS5F,KAAKsC,SAC3CtC,KAAK4D,QAAQzC,EAAsB,UAEjCmP,EAAY,IAAIhP,EAAKtB,KAAMmB,EAAsBT,EAAQ,IAAKgB,GAMlE,OALA4O,EAAU5N,QAAQ,MAAM,IAAMoL,MAAWpL,QAAQ,WAAW,IAAMoL,MAClEwC,EAAUrO,OACLjC,KAAKmQ,WACRG,EAAU1M,QAAQ,KAAM,IAEnB0M,EAETtC,UAAUuC,EAAQ9O,EAASwB,GACzB,OAAOxB,EAET+O,SAASlO,EAAOd,EAAOC,EAASgB,GAC9B,QAAIzC,KAAKsC,QAAUA,GAGfG,GAAWA,IAAYzC,KAAKyC,YAC1BzC,KAAKoC,OAAOwL,aACd5N,KAAKoC,OAAOwD,IAAI,UAAW,4BAA6B,CAAEtD,MAAAA,EAAOd,MAAAA,EAAOC,QAAAA,EAASgB,QAAAA,IAC5E,IAKXA,UACE,OAAOzC,KAAK6P,SAAStN,IAEvByN,OAAOtO,EAAU1B,KAAK0B,SAChB1B,KAAK8O,cAGT9O,KAAKoC,OAAOqO,eAAezQ,KAAKsC,OAChCtC,KAAKyP,MAAQvO,EACblB,KAAK6P,SAAS9N,OAAOL,IAEvBkC,QAAQpC,EAAOC,EAASc,EAAKE,GAC3B,IAAIiO,EAAiB1Q,KAAKgO,UAAUxM,EAAOC,EAASc,EAAKE,GACzD,GAAIhB,IAAYiP,EACd,MAAM,IAAItI,MAAM,+EAElB,IAAIuI,EAAgB3Q,KAAK0P,SAASxM,QAAQ8E,GAASA,EAAKxG,QAAUA,IAClE,IAAK,IAAIoP,EAAI,EAAGA,EAAID,EAAc9J,OAAQ+J,IAC7BD,EAAcC,GACpBhO,SAAS8N,EAAgBnO,EAAKE,GAAWzC,KAAKyC,WAGvDgB,eAAelB,GACb,MAAO,cAAcA,IAEvBwM,WACE,OAAO/O,KAAKyP,QAAUvO,EAExB2N,YACE,OAAO7O,KAAKyP,QAAUvO,EAExBkP,WACE,OAAOpQ,KAAKyP,QAAUvO,EAExBgP,YACE,OAAOlQ,KAAKyP,QAAUvO,EAExB4N,YACE,OAAO9O,KAAKyP,QAAUvO,IAmpBCoB,EAAOiN,EAAYvP,MAE1C,OADAA,KAAKoL,SAAS/I,KAAKmN,GACZA,EAETnN,KAAK8F,GACH,GAAInI,KAAK4N,YAAa,CACpB,IAAI,MAAEtL,EAAK,MAAEd,EAAK,QAAEC,EAAO,IAAEc,EAAG,SAAEC,GAAa2F,EAC/CnI,KAAK4F,IAAI,OAAQ,GAAGtD,KAASd,MAAUgB,MAAaD,KAAQd,GAE1DzB,KAAKiP,cACPjP,KAAK6I,OAAOV,GAAO0I,GAAW7Q,KAAKiM,KAAKhK,KAAK4O,KAE7C7Q,KAAKqL,WAAWhJ,MAAK,IAAMrC,KAAK6I,OAAOV,GAAO0I,GAAW7Q,KAAKiM,KAAKhK,KAAK4O,OAG5ErN,UACE,IAAIsN,EAAS9Q,KAAKuC,IAAM,EAMxB,OALIuO,IAAW9Q,KAAKuC,IAClBvC,KAAKuC,IAAM,EAEXvC,KAAKuC,IAAMuO,EAEN9Q,KAAKuC,IAAIwO,WAElB1C,gBACMrO,KAAK2M,sBAAwB3M,KAAKiP,gBAGtCjP,KAAK2M,oBAAsB3M,KAAKwD,UAChCxD,KAAKqC,KAAK,CAAEC,MAAO,UAAWd,MAAO,YAAaC,QAAS,GAAIc,IAAKvC,KAAK2M,sBACzE3M,KAAK0M,eAAiB/I,YAAW,IAAM3D,KAAKmO,oBAAoBnO,KAAKoM,sBAEvEgC,cAAcb,GACZvN,KAAK2L,eAAgB,EACjB3L,KAAKiP,eACPjP,KAAKiM,KAAKnE,MAh/BM,IAg/BiByF,GAGrCU,kBACMjO,KAAKiP,eAAiBjP,KAAKqL,WAAWxE,OAAS,IACjD7G,KAAKqL,WAAWjI,SAASR,GAAaA,MACtC5C,KAAKqL,WAAa,IAGtBqC,cAAcsD,GACZhR,KAAKiJ,OAAO+H,EAAW7I,MAAOD,IAC5B,IAAI,MAAE5F,EAAK,MAAEd,EAAK,QAAEC,EAAO,IAAEc,EAAG,SAAEC,GAAa0F,EAC3C3F,GAAOA,IAAQvC,KAAK2M,sBACtBpJ,aAAavD,KAAK0M,gBAClB1M,KAAK2M,oBAAsB,KAC3BhJ,YAAW,IAAM3D,KAAKqO,iBAAiBrO,KAAKoM,sBAE1CpM,KAAK4N,aACP5N,KAAK4F,IAAI,UAAW,GAAGnE,EAAQkB,QAAU,MAAML,KAASd,KAASe,GAAO,IAAMA,EAAM,KAAO,KAAMd,GACnG,IAAK,IAAImP,EAAI,EAAGA,EAAI5Q,KAAKoL,SAASvE,OAAQ+J,IAAK,CAC7C,MAAMrP,EAAUvB,KAAKoL,SAASwF,GACzBrP,EAAQiP,SAASlO,EAAOd,EAAOC,EAASe,IAG7CjB,EAAQqC,QAAQpC,EAAOC,EAASc,EAAKC,GAEvC,IAAK,IAAIoO,EAAI,EAAGA,EAAI5Q,KAAKkL,qBAAqB9B,QAAQvC,OAAQ+J,IAAK,CACjE,IAAK,CAAEhO,GAAY5C,KAAKkL,qBAAqB9B,QAAQwH,GACrDhO,EAASsF,OAIfuI,eAAenO,GACb,IAAI2O,EAAajR,KAAKoL,SAAS8F,MAAM9B,GAAMA,EAAE9M,QAAUA,IAAU8M,EAAEgB,YAAchB,EAAEc,eAC/Ee,IACEjR,KAAK4N,aACP5N,KAAK4F,IAAI,YAAa,4BAA4BtD,MACpD2O,EAAWZ,WCtiCjB,IAAIc,EAC4B,MAD5BA,EAEuB,qBAFvBA,EAGyB,OAwCtBC,eAAeC,EACpBC,GAEA,MAAMlP,QAoDDgP,iBAIL,IAHAG,EAGA,wDAFA5K,EAEA,uDAFS,KACT6K,EACA,uDADcxG,EAEd,MAAMyG,EAAK,IAAIC,gBAAgBzE,SAAS0E,QAElCC,EAAkBR,gBAChBS,IACN,MAAM,KAAExE,EAAF,KAAQyE,GAASC,EACjB/E,EACJyE,EAAGO,IAAI,iBACPb,IACgC,WAA/Bc,SAAShF,SAASD,SAAwB,OAAS,OAEtD,gBAAUA,EAAV,aAAuBK,GAAvB,OAA8ByE,EAAO,IAAH,OAAOA,GAAS,KAG9CI,QAAkBN,IACxBjM,QAAQC,IAAR,8BAAmCsM,IAEnC,MAAMC,EAAsB,GAExBZ,IACFY,EAAe5F,OAAS,CAACnC,EAAMlC,EAAKC,KAClCxC,QAAQC,IAAR,UAAewE,EAAf,aAAwBlC,GAAOC,KAI/BxB,IACFwL,EAAexL,OAASA,GAG1B,MAAMvE,EAAS,IAAIoP,EAAJ,UAAmBU,EAAnB,WAAuCC,GActD,OAbA/P,EAAO+J,UACP/J,EAAO2L,SAAQqD,UAGbgB,IAEA,MAAMC,EAAe,IAAIC,IAAIlQ,EAAOiC,UAAUkO,SACxCC,QAAqBZ,IACrBa,EAAc,GAAH,OAAMD,GAAN,OAAqBH,GACtC1M,QAAQC,IAAR,4CAAiD6M,IACjDrQ,EAAOiC,SAAWoO,KAGbrQ,EAnGcsQ,GACrBtQ,EAAO0L,SAASpI,IACdC,QAAQwF,MAAMzF,MAGhB,MAAM,KAAEyC,EAAF,cAAQwK,EAAR,UAAuBC,SAAoB,IAAIC,SACnD,CAACC,EAASC,KAES3Q,EAAOb,QAAP,MAAsB,CAAEyR,OAAQ1B,IAE9C7K,OACA/D,QAAQ,MAAOkQ,IACd,MAAMD,EAAgBvQ,EAAOb,QAC3B,OAAS+P,EAnCJ,CACb2B,QAAS,CACPC,SAAU,GACVC,YAAa,IAEfC,2BAA4B,KAC5BC,WAAY,KACZC,YAAa,KACbC,eAAgB,KAChBC,QAAS,CACPC,QAAQ,EACRC,OAAO,GAETC,cAAe,OAyBThB,EACGlM,OACA/D,QAAQ,MAAM0O,MAAAA,IACb0B,EAAQ,CAAE3K,KAAAA,EAAMwK,cAAAA,EAAeC,UAAAA,OAEhClQ,QAAQ,SAAUkR,IACjBb,EAAOa,SAGZlR,QAAQ,SAAUkR,IACjBb,EAAOa,SAIf,MAAO,CAAEzL,KAAAA,EAAMwK,cAAAA,EAAeC,UAAAA,GAGhC,IAGIb,EAHA8B,EAAqB,KACrBC,GAAsC,EAI1C1C,eAAeS,IAEb,IAAIxE,EADO,IAAIqE,gBAAgBzE,SAAS0E,QAC1BK,IAAI,YAClB3E,EAAOA,GAAQ8D,EAEfY,EAA6B,CAAE1E,KAAAA,EAAMyE,KADxBX,GAIRC,eAAegB,IACpB0B,GAAsC,EACtCD,EAAgB,KCrFX,MAAME,EAGXlU,YAAoBE,G,UAAoB,KAApBA,SAAAA,E,EAFqB,M,EAED,iB,EAAA,M,sFAE1B,eAACuR,GACb,MAAM,KAAEnJ,EAAF,cAAQwK,EAAR,UAAuBC,SAAoBvB,EAAKC,GAChD0C,EAAW7L,EAAK8L,KAAK,GAAGhU,MAAMiU,UAAUzM,QAAQ,OAAQ,QAC9DzH,KAAKmU,YAAc,IAAIvU,QACjBI,KAAKmU,YAAYC,UAAUJ,EAAUhU,KAAKD,UAGlDsU,UACE,OAAON,EAAgBxT,MAIpB,MAAM+T,EAGU,sBACnBC,EACAC,GAEA,IAAIC,EAAWF,EAAMG,wBACnBC,EAAAA,cAAAA,MAEEC,QAAcH,EAASI,WACzB,wDAEEC,QAAsBL,EAASI,WACjC,kEAEEE,EAAkB,IAAIhB,EAAgBa,GAO1C,aANMG,EAAgBC,SAASR,EAAOS,MAClCF,EAAgBZ,aAClBW,EACGI,mBACAC,eAAeJ,EAAgBZ,YAAY3T,SAEzCuU","sources":["webpack://axolotis-core-plugins/./src/lib/modules/spoke/SceneLoader.ts","webpack://axolotis-core-plugins/./node_modules/phoenix/priv/static/phoenix.esm.js","webpack://axolotis-core-plugins/./src/lib/modules/spoke/PhoenixUtils.ts","webpack://axolotis-core-plugins/./src/lib/modules/spoke/SpokeRoomLoader.ts"],"sourcesContent":["import { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\n\nexport default class SceneLoader {\n  private scene: any;\n  private mesh: any;\n  public navMesh: any;\n\n  constructor() {}\n\n  async loadScene(sceneUrl: string, threeLib: ThreeLib) {\n    this.scene = threeLib.scene;\n    this.mesh = await threeLib.loadAssets(sceneUrl);\n    this.mesh = this.mesh.scene;\n\n    this.mesh.traverse((node) => {\n      if (node.isMesh) {\n        if (node.name === \"navMesh\") {\n          this.navMesh = node;\n        }\n      }\n    });\n\n    this.scene.add(this.mesh);\n  }\n}\n","// js/phoenix/utils.js\nvar closure = (value) => {\n  if (typeof value === \"function\") {\n    return value;\n  } else {\n    let closure2 = function() {\n      return value;\n    };\n    return closure2;\n  }\n};\n\n// js/phoenix/constants.js\nvar globalSelf = typeof self !== \"undefined\" ? self : null;\nvar phxWindow = typeof window !== \"undefined\" ? window : null;\nvar global = globalSelf || phxWindow || void 0;\nvar DEFAULT_VSN = \"2.0.0\";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 1e4;\nvar WS_CLOSE_NORMAL = 1e3;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n};\nvar XHR_STATES = {\n  complete: 4\n};\n\n// js/phoenix/push.js\nvar Push = class {\n  constructor(channel, event, payload, timeout) {\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || function() {\n      return {};\n    };\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n  resend(timeout) {\n    this.timeout = timeout;\n    this.reset();\n    this.send();\n  }\n  send() {\n    if (this.hasReceived(\"timeout\")) {\n      return;\n    }\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    });\n  }\n  receive(status, callback) {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp.response);\n    }\n    this.recHooks.push({ status, callback });\n    return this;\n  }\n  reset() {\n    this.cancelRefEvent();\n    this.ref = null;\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n  }\n  matchReceive({ status, response, _ref }) {\n    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));\n  }\n  cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n    this.channel.off(this.refEvent);\n  }\n  cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = null;\n  }\n  startTimeout() {\n    if (this.timeoutTimer) {\n      this.cancelTimeout();\n    }\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n    this.channel.on(this.refEvent, (payload) => {\n      this.cancelRefEvent();\n      this.cancelTimeout();\n      this.receivedResp = payload;\n      this.matchReceive(payload);\n    });\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout);\n  }\n  hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n  trigger(status, response) {\n    this.channel.trigger(this.refEvent, { status, response });\n  }\n};\n\n// js/phoenix/timer.js\nvar Timer = class {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n};\n\n// js/phoenix/channel.js\nvar Channel = class {\n  constructor(topic, params, socket) {\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.stateChangeRefs = [];\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n    this.stateChangeRefs.push(this.socket.onOpen(() => {\n      this.rejoinTimer.reset();\n      if (this.isErrored()) {\n        this.rejoin();\n      }\n    }));\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError((reason) => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `error ${this.topic}`, reason);\n      if (this.isJoining()) {\n        this.joinPush.reset();\n      }\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n      leavePush.send();\n      this.state = CHANNEL_STATES.errored;\n      this.joinPush.reset();\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n  join(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n    } else {\n      this.timeout = timeout;\n      this.joinedOnce = true;\n      this.rejoin();\n      return this.joinPush;\n    }\n  }\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n  onError(callback) {\n    return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));\n  }\n  on(event, callback) {\n    let ref = this.bindingRef++;\n    this.bindings.push({ event, ref, callback });\n    return ref;\n  }\n  off(event, ref) {\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n    });\n  }\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n  push(event, payload, timeout = this.timeout) {\n    payload = payload || {};\n    if (!this.joinedOnce) {\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\n    }\n    let pushEvent = new Push(this, event, function() {\n      return payload;\n    }, timeout);\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  leave(timeout = this.timeout) {\n    this.rejoinTimer.reset();\n    this.joinPush.cancelTimeout();\n    this.state = CHANNEL_STATES.leaving;\n    let onClose = () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, \"leave\");\n    };\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n    leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n    leavePush.send();\n    if (!this.canPush()) {\n      leavePush.trigger(\"ok\", {});\n    }\n    return leavePush;\n  }\n  onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  isMember(topic, event, payload, joinRef) {\n    if (this.topic !== topic) {\n      return false;\n    }\n    if (joinRef && joinRef !== this.joinRef()) {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", \"dropping outdated message\", { topic, event, payload, joinRef });\n      return false;\n    } else {\n      return true;\n    }\n  }\n  joinRef() {\n    return this.joinPush.ref;\n  }\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return;\n    }\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  trigger(event, payload, ref, joinRef) {\n    let handledPayload = this.onMessage(event, payload, ref, joinRef);\n    if (payload && !handledPayload) {\n      throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n    }\n    let eventBindings = this.bindings.filter((bind) => bind.event === event);\n    for (let i = 0; i < eventBindings.length; i++) {\n      let bind = eventBindings[i];\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\n    }\n  }\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n};\n\n// js/phoenix/ajax.js\nvar Ajax = class {\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n    if (global.XDomainRequest) {\n      let req = new global.XDomainRequest();\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n    } else {\n      let req = new global.XMLHttpRequest();\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n    }\n  }\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n    req.timeout = timeout;\n    req.open(method, endPoint);\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText);\n      callback && callback(response);\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.onprogress = () => {\n    };\n    req.send(body);\n  }\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n    req.open(method, endPoint, true);\n    req.timeout = timeout;\n    req.setRequestHeader(\"Content-Type\", accept);\n    req.onerror = () => {\n      callback && callback(null);\n    };\n    req.onreadystatechange = () => {\n      if (req.readyState === XHR_STATES.complete && callback) {\n        let response = this.parseJSON(req.responseText);\n        callback(response);\n      }\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.send(body);\n  }\n  static parseJSON(resp) {\n    if (!resp || resp === \"\") {\n      return null;\n    }\n    try {\n      return JSON.parse(resp);\n    } catch (e) {\n      console && console.log(\"failed to parse JSON response\", resp);\n      return null;\n    }\n  }\n  static serialize(obj, parentKey) {\n    let queryStr = [];\n    for (var key in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        continue;\n      }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n      let paramVal = obj[key];\n      if (typeof paramVal === \"object\") {\n        queryStr.push(this.serialize(paramVal, paramKey));\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n      }\n    }\n    return queryStr.join(\"&\");\n  }\n  static appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    return `${url}${prefix}${this.serialize(params)}`;\n  }\n};\n\n// js/phoenix/longpoll.js\nvar LongPoll = class {\n  constructor(endPoint) {\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.onopen = function() {\n    };\n    this.onerror = function() {\n    };\n    this.onmessage = function() {\n    };\n    this.onclose = function() {\n    };\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    this.poll();\n  }\n  normalizeEndpoint(endPoint) {\n    return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n  }\n  endpointURL() {\n    return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n  }\n  closeAndRetry() {\n    this.close();\n    this.readyState = SOCKET_STATES.connecting;\n  }\n  ontimeout() {\n    this.onerror(\"timeout\");\n    this.closeAndRetry();\n  }\n  poll() {\n    if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n      return;\n    }\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), (resp) => {\n      if (resp) {\n        var { status, token, messages } = resp;\n        this.token = token;\n      } else {\n        status = 0;\n      }\n      switch (status) {\n        case 200:\n          messages.forEach((msg) => {\n            setTimeout(() => {\n              this.onmessage({ data: msg });\n            }, 0);\n          });\n          this.poll();\n          break;\n        case 204:\n          this.poll();\n          break;\n        case 410:\n          this.readyState = SOCKET_STATES.open;\n          this.onopen();\n          this.poll();\n          break;\n        case 403:\n          this.onerror();\n          this.close();\n          break;\n        case 0:\n        case 500:\n          this.onerror();\n          this.closeAndRetry();\n          break;\n        default:\n          throw new Error(`unhandled poll status ${status}`);\n      }\n    });\n  }\n  send(body) {\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), (resp) => {\n      if (!resp || resp.status !== 200) {\n        this.onerror(resp && resp.status);\n        this.closeAndRetry();\n      }\n    });\n  }\n  close(_code, _reason) {\n    this.readyState = SOCKET_STATES.closed;\n    this.onclose();\n  }\n};\n\n// js/phoenix/presence.js\nvar Presence = class {\n  constructor(channel, opts = {}) {\n    let events = opts.events || { state: \"presence_state\", diff: \"presence_diff\" };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function() {\n      },\n      onLeave: function() {\n      },\n      onSync: function() {\n      }\n    };\n    this.channel.on(events.state, (newState) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      this.joinRef = this.channel.joinRef();\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach((diff) => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel.on(events.diff, (diff) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n  list(by) {\n    return Presence.list(this.state, by);\n  }\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\n  }\n  static syncState(currentState, newState, onJoin, onLeave) {\n    let state = this.clone(currentState);\n    let joins = {};\n    let leaves = {};\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key];\n      if (currentPresence) {\n        let newRefs = newPresence.metas.map((m) => m.phx_ref);\n        let curRefs = currentPresence.metas.map((m) => m.phx_ref);\n        let joinedMetas = newPresence.metas.filter((m) => curRefs.indexOf(m.phx_ref) < 0);\n        let leftMetas = currentPresence.metas.filter((m) => newRefs.indexOf(m.phx_ref) < 0);\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n  }\n  static syncDiff(state, diff, onJoin, onLeave) {\n    let { joins, leaves } = this.clone(diff);\n    if (!onJoin) {\n      onJoin = function() {\n      };\n    }\n    if (!onLeave) {\n      onLeave = function() {\n      };\n    }\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key];\n      state[key] = this.clone(newPresence);\n      if (currentPresence) {\n        let joinedRefs = state[key].metas.map((m) => m.phx_ref);\n        let curMetas = currentPresence.metas.filter((m) => joinedRefs.indexOf(m.phx_ref) < 0);\n        state[key].metas.unshift(...curMetas);\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      let refsToRemove = leftPresence.metas.map((m) => m.phx_ref);\n      currentPresence.metas = currentPresence.metas.filter((p) => {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  }\n  static list(presences, chooser) {\n    if (!chooser) {\n      chooser = function(key, pres) {\n        return pres;\n      };\n    }\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence);\n    });\n  }\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n  }\n  static clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n// js/phoenix/serializer.js\nvar serializer_default = {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: { push: 0, reply: 1, broadcast: 2 },\n  encode(msg, callback) {\n    if (msg.payload.constructor === ArrayBuffer) {\n      return callback(this.binaryEncode(msg));\n    } else {\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n      return callback(JSON.stringify(payload));\n    }\n  },\n  decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this.binaryDecode(rawPayload));\n    } else {\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n      return callback({ join_ref, ref, topic, event, payload });\n    }\n  },\n  binaryEncode(message) {\n    let { join_ref, ref, event, topic, payload } = message;\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n    let view = new DataView(header);\n    let offset = 0;\n    view.setUint8(offset++, this.KINDS.push);\n    view.setUint8(offset++, join_ref.length);\n    view.setUint8(offset++, ref.length);\n    view.setUint8(offset++, topic.length);\n    view.setUint8(offset++, event.length);\n    Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    var combined = new Uint8Array(header.byteLength + payload.byteLength);\n    combined.set(new Uint8Array(header), 0);\n    combined.set(new Uint8Array(payload), header.byteLength);\n    return combined.buffer;\n  },\n  binaryDecode(buffer) {\n    let view = new DataView(buffer);\n    let kind = view.getUint8(0);\n    let decoder = new TextDecoder();\n    switch (kind) {\n      case this.KINDS.push:\n        return this.decodePush(buffer, view, decoder);\n      case this.KINDS.reply:\n        return this.decodeReply(buffer, view, decoder);\n      case this.KINDS.broadcast:\n        return this.decodeBroadcast(buffer, view, decoder);\n    }\n  },\n  decodePush(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let topicSize = view.getUint8(2);\n    let eventSize = view.getUint8(3);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: joinRef, ref: null, topic, event, payload: data };\n  },\n  decodeReply(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let refSize = view.getUint8(2);\n    let topicSize = view.getUint8(3);\n    let eventSize = view.getUint8(4);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n    offset = offset + refSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    let payload = { status: event, response: data };\n    return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };\n  },\n  decodeBroadcast(buffer, view, decoder) {\n    let topicSize = view.getUint8(1);\n    let eventSize = view.getUint8(2);\n    let offset = this.HEADER_LENGTH + 2;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: null, ref: null, topic, event, payload: data };\n  }\n};\n\n// js/phoenix/socket.js\nvar Socket = class {\n  constructor(endPoint, opts = {}) {\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || global.WebSocket || LongPoll;\n    this.establishedConnections = 0;\n    this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n    this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n    this.closeWasClean = false;\n    this.binaryType = opts.binaryType || \"arraybuffer\";\n    this.connectClock = 1;\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n    let awaitingConnectionOnPageShow = null;\n    if (phxWindow && phxWindow.addEventListener) {\n      phxWindow.addEventListener(\"pagehide\", (_e) => {\n        if (this.conn) {\n          this.disconnect();\n          awaitingConnectionOnPageShow = this.connectClock;\n        }\n      });\n      phxWindow.addEventListener(\"pageshow\", (_e) => {\n        if (awaitingConnectionOnPageShow === this.connectClock) {\n          awaitingConnectionOnPageShow = null;\n          this.connect();\n        }\n      });\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n    this.rejoinAfterMs = (tries) => {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries);\n      } else {\n        return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n      }\n    };\n    this.reconnectAfterMs = (tries) => {\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries);\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n      }\n    };\n    this.logger = opts.logger || null;\n    this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n    this.params = closure(opts.params || {});\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.vsn = opts.vsn || DEFAULT_VSN;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect());\n    }, this.reconnectAfterMs);\n  }\n  replaceTransport(newTransport) {\n    this.disconnect();\n    this.transport = newTransport;\n  }\n  protocol() {\n    return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n  }\n  endPointURL() {\n    let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });\n    if (uri.charAt(0) !== \"/\") {\n      return uri;\n    }\n    if (uri.charAt(1) === \"/\") {\n      return `${this.protocol()}:${uri}`;\n    }\n    return `${this.protocol()}://${location.host}${uri}`;\n  }\n  disconnect(callback, code, reason) {\n    this.connectClock++;\n    this.closeWasClean = true;\n    this.reconnectTimer.reset();\n    this.teardown(callback, code, reason);\n  }\n  connect(params) {\n    this.connectClock++;\n    if (params) {\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n      this.params = closure(params);\n    }\n    if (this.conn) {\n      return;\n    }\n    this.closeWasClean = false;\n    this.conn = new this.transport(this.endPointURL());\n    this.conn.binaryType = this.binaryType;\n    this.conn.timeout = this.longpollerTimeout;\n    this.conn.onopen = () => this.onConnOpen();\n    this.conn.onerror = (error) => this.onConnError(error);\n    this.conn.onmessage = (event) => this.onConnMessage(event);\n    this.conn.onclose = (event) => this.onConnClose(event);\n  }\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  hasLogger() {\n    return this.logger !== null;\n  }\n  onOpen(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.open.push([ref, callback]);\n    return ref;\n  }\n  onClose(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.close.push([ref, callback]);\n    return ref;\n  }\n  onError(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.error.push([ref, callback]);\n    return ref;\n  }\n  onMessage(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.message.push([ref, callback]);\n    return ref;\n  }\n  onConnOpen() {\n    if (this.hasLogger())\n      this.log(\"transport\", `connected to ${this.endPointURL()}`);\n    this.closeWasClean = false;\n    this.establishedConnections++;\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.resetHeartbeat();\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n  }\n  heartbeatTimeout() {\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      if (this.hasLogger()) {\n        this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n      }\n      this.abnormalClose(\"heartbeat timeout\");\n    }\n  }\n  resetHeartbeat() {\n    if (this.conn && this.conn.skipHeartbeat) {\n      return;\n    }\n    this.pendingHeartbeatRef = null;\n    clearTimeout(this.heartbeatTimer);\n    setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n  }\n  teardown(callback, code, reason) {\n    if (!this.conn) {\n      return callback && callback();\n    }\n    this.waitForBufferDone(() => {\n      if (this.conn) {\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n      }\n      this.waitForSocketClosed(() => {\n        if (this.conn) {\n          this.conn.onclose = function() {\n          };\n          this.conn = null;\n        }\n        callback && callback();\n      });\n    });\n  }\n  waitForBufferDone(callback, tries = 1) {\n    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1);\n    }, 150 * tries);\n  }\n  waitForSocketClosed(callback, tries = 1) {\n    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1);\n    }, 150 * tries);\n  }\n  onConnClose(event) {\n    let closeCode = event && event.code;\n    if (this.hasLogger())\n      this.log(\"transport\", \"close\", event);\n    this.triggerChanError();\n    clearTimeout(this.heartbeatTimer);\n    if (!this.closeWasClean && closeCode !== 1e3) {\n      this.reconnectTimer.scheduleTimeout();\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n  }\n  onConnError(error) {\n    if (this.hasLogger())\n      this.log(\"transport\", error);\n    let transportBefore = this.transport;\n    let establishedBefore = this.establishedConnections;\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\n      callback(error, transportBefore, establishedBefore);\n    });\n    if (transportBefore === this.transport || establishedBefore > 0) {\n      this.triggerChanError();\n    }\n  }\n  triggerChanError() {\n    this.channels.forEach((channel) => {\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n        channel.trigger(CHANNEL_EVENTS.error);\n      }\n    });\n  }\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return \"connecting\";\n      case SOCKET_STATES.open:\n        return \"open\";\n      case SOCKET_STATES.closing:\n        return \"closing\";\n      default:\n        return \"closed\";\n    }\n  }\n  isConnected() {\n    return this.connectionState() === \"open\";\n  }\n  remove(channel) {\n    this.off(channel.stateChangeRefs);\n    this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());\n  }\n  off(refs) {\n    for (let key in this.stateChangeCallbacks) {\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n        return refs.indexOf(ref) === -1;\n      });\n    }\n  }\n  channel(topic, chanParams = {}) {\n    let chan = new Channel(topic, chanParams, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  push(data) {\n    if (this.hasLogger()) {\n      let { topic, event, payload, ref, join_ref } = data;\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n    }\n    if (this.isConnected()) {\n      this.encode(data, (result) => this.conn.send(result));\n    } else {\n      this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));\n    }\n  }\n  makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  sendHeartbeat() {\n    if (this.pendingHeartbeatRef && !this.isConnected()) {\n      return;\n    }\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef });\n    this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n  }\n  abnormalClose(reason) {\n    this.closeWasClean = false;\n    if (this.isConnected()) {\n      this.conn.close(WS_CLOSE_NORMAL, reason);\n    }\n  }\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback());\n      this.sendBuffer = [];\n    }\n  }\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, (msg) => {\n      let { topic, event, payload, ref, join_ref } = msg;\n      if (ref && ref === this.pendingHeartbeatRef) {\n        clearTimeout(this.heartbeatTimer);\n        this.pendingHeartbeatRef = null;\n        setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n      }\n      if (this.hasLogger())\n        this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i];\n        if (!channel.isMember(topic, event, payload, join_ref)) {\n          continue;\n        }\n        channel.trigger(event, payload, ref, join_ref);\n      }\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        let [, callback] = this.stateChangeCallbacks.message[i];\n        callback(msg);\n      }\n    });\n  }\n  leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));\n    if (dupChannel) {\n      if (this.hasLogger())\n        this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n      dupChannel.leave();\n    }\n  }\n};\nexport {\n  Channel,\n  LongPoll,\n  Presence,\n  serializer_default as Serializer,\n  Socket\n};\n//# sourceMappingURL=phoenix.esm.js.map\n","import { Socket } from \"phoenix\";\n\nlet configs = {\n  RETICULUM_SOCKET_SERVER_PORT: \"443\",\n  RETICULUM_SOCKET_SERVER: \"alphahub.aptero.co\", //TODO\n  RETICULUM_SOCKET_PROTOCOL: \"wss:\",\n};\n\nexport function createHubChannelParams(\n  authToken: string | null = null,\n  permsToken: string | null = null\n) {\n  /*{\n        \"profile\": {\n        \"avatarId\": \"https://hub.aptero.co/data/avatar/A031/base.glb\",\n            \"displayName\": \"Pierre\"\n    },\n        \"push_subscription_endpoint\": null,\n        \"auth_token\": \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJyZXQiLCJleHAiOjE2MjM2Nzc4NzUsImlhdCI6MTYxNjQyMDI3NSwiaXNzIjoicmV0IiwianRpIjoiMTBkMWFkZmYtYjBlMi00N2RkLWFiMTgtMjY3MGY0ZDVhMTFkIiwibmJmIjoxNjE2NDIwMjc0LCJzdWIiOiI2NDA0MDcwNTA5NjYyNjk5NjEiLCJ0eXAiOiJhY2Nlc3MifQ.qp29Ip4AKkpRPtVVOUikytL1u-lGPJidUglsWlW8H9izgdRsoH_c0yZuA04Miwi6K2iN-GsoCr8Kd1fTH0yp2g\",\n        \"perms_token\": null,\n        \"context\": {\n        \"mobile\": false,\n            \"embed\": true\n    },\n        \"hub_invite_id\": null\n    }*/\n  const params = {\n    profile: {\n      avatarId: \"\",\n      displayName: \"\",\n    },\n    push_subscription_endpoint: null,\n    auth_token: null,\n    perms_token: null,\n    bot_access_key: null,\n    context: {\n      mobile: false,\n      embed: true,\n    },\n    hub_invite_id: null,\n  };\n\n  return params;\n}\n\nexport async function load(\n  hubid\n): Promise<{ data: any; hubPhxChannel: any; vapiddata: any }> {\n  const socket = await connectToReticulum();\n  socket.onClose((e) => {\n    console.error(e);\n  });\n\n  const { data, hubPhxChannel, vapiddata } = await new Promise(\n    (resolve, reject) => {\n      // Reticulum global channel\n      let retChannel = socket.channel(`ret`, { hub_id: hubid });\n      retChannel\n        .join()\n        .receive(\"ok\", (vapiddata) => {\n          const hubPhxChannel = socket.channel(\n            `hub:` + hubid,\n            createHubChannelParams()\n          );\n          hubPhxChannel\n            .join()\n            .receive(\"ok\", async (data) => {\n              resolve({ data, hubPhxChannel, vapiddata });\n            })\n            .receive(\"error\", (res) => {\n              reject(res);\n            });\n        })\n        .receive(\"error\", (res) => {\n          reject(res);\n        });\n    }\n  );\n  return { data, hubPhxChannel, vapiddata };\n}\n\nlet reticulumMeta: any = null;\nlet invalidatedReticulumMetaThisSession = false;\n\nlet directReticulumHostAndPort;\n\nasync function refreshDirectReticulumHostAndPort() {\n  const qs = new URLSearchParams(location.search);\n  let host = qs.get(\"phx_host\");\n  host = host || configs.RETICULUM_SOCKET_SERVER;\n  const port = configs.RETICULUM_SOCKET_SERVER_PORT;\n  directReticulumHostAndPort = { host, port };\n}\n\nexport async function invalidateReticulumMeta() {\n  invalidatedReticulumMetaThisSession = true;\n  reticulumMeta = null;\n}\n\n//TODO important function\nexport async function connectToReticulum(\n  debug = false,\n  params = null,\n  socketClass = Socket\n) {\n  const qs = new URLSearchParams(location.search);\n\n  const getNewSocketUrl = async () => {\n    await refreshDirectReticulumHostAndPort();\n    const { host, port } = directReticulumHostAndPort;\n    const protocol =\n      qs.get(\"phx_protocol\") ||\n      configs.RETICULUM_SOCKET_PROTOCOL ||\n      (document.location.protocol === \"https:\" ? \"wss:\" : \"ws:\");\n\n    return `${protocol}//${host}${port ? `:${port}` : \"\"}`;\n  };\n\n  const socketUrl = await getNewSocketUrl();\n  console.log(`Phoenix Socket URL: ${socketUrl}`);\n\n  const socketSettings: any = {};\n\n  if (debug) {\n    socketSettings.logger = (kind, msg, data) => {\n      console.log(`${kind}: ${msg}`, data);\n    };\n  }\n\n  if (params) {\n    socketSettings.params = params;\n  }\n\n  const socket = new socketClass(`${socketUrl}/socket`, socketSettings);\n  socket.connect();\n  socket.onError(async () => {\n    // On error, underlying reticulum node may have died, so rebalance by\n    // fetching a new healthy node to connect to.\n    invalidateReticulumMeta();\n\n    const endPointPath = new URL(socket.endPoint).pathname;\n    const newSocketUrl = await getNewSocketUrl();\n    const newEndPoint = `${newSocketUrl}${endPointPath}`;\n    console.log(`Socket error, changed endpoint to ${newEndPoint}`);\n    socket.endPoint = newEndPoint;\n  });\n\n  return socket;\n}\n\nexport function getPresenceEntryForSession(presences, sessionId) {\n  const entry =\n    Object.entries(presences || {}).find(([k]) => k === sessionId) || [];\n  const presence: any = entry[1];\n  return (presence && presence.metas && presence.metas[0]) || {};\n}\n\nexport function getPresenceContextForSession(presences, sessionId) {\n  return (getPresenceEntryForSession(presences, sessionId) || {}).context || {};\n}\n\nexport function getPresenceProfileForSession(presences, sessionId) {\n  return (getPresenceEntryForSession(presences, sessionId) || {}).profile || {};\n}\n\nfunction migrateBindings(oldChannel, newChannel) {\n  const doNotDuplicate = [\n    \"phx_close\",\n    \"phx_error\",\n    \"phx_reply\",\n    \"presence_state\",\n    \"presence_diff\",\n  ];\n  const shouldDuplicate = (event) => {\n    return !event.startsWith(\"chan_reply_\") && !doNotDuplicate.includes(event);\n  };\n  for (let i = 0, l = oldChannel.bindings.length; i < l; i++) {\n    const item = oldChannel.bindings[i];\n    if (shouldDuplicate(item.event)) {\n      newChannel.bindings.push(item);\n    }\n  }\n  newChannel.bindingRef = oldChannel.bindingRef;\n}\n\n// Takes the given channel, and creates a new channel with the same bindings\n// with the given socket, joins it, and leaves the old channel after joining.\n//\n// NOTE: This function relies upon phoenix channel object internals, so this\n// function will need to be reviewed if/when we ever update phoenix.js\nexport function migrateChannelToSocket(oldChannel, socket, params) {\n  const channel = socket.channel(oldChannel.topic, params || oldChannel.params);\n\n  migrateBindings(oldChannel, channel);\n\n  for (let i = 0, l = oldChannel.pushBuffer.length; i < l; i++) {\n    const item = oldChannel.pushBuffer[i];\n    channel.push(item.event, item.payload, item.timeout);\n  }\n\n  const oldJoinPush = oldChannel.joinPush;\n  const joinPush = channel.join();\n\n  for (let i = 0, l = oldJoinPush.recHooks.length; i < l; i++) {\n    const item = oldJoinPush.recHooks[i];\n    joinPush.receive(item.status, item.callback);\n  }\n\n  return new Promise((resolve) => {\n    joinPush.receive(\"ok\", () => {\n      // Clear all event handlers first so no duplicate messages come in.\n      oldChannel.bindings = [];\n      resolve(channel);\n    });\n  });\n}\n\nexport function migrateToChannel(oldChannel, newChannel) {\n  migrateBindings(oldChannel, newChannel);\n\n  return new Promise((resolve, reject) => {\n    newChannel\n      .join()\n      .receive(\"ok\", (data) => {\n        oldChannel.leave();\n        oldChannel.bindings = [];\n        resolve(data);\n      })\n      .receive(\"error\", (data) => {\n        newChannel.leave();\n        reject(data);\n      });\n  });\n}\n\nexport function discordBridgesForPresences(presences: any[]) {\n  const channels = [];\n  for (const p of Object.values(presences)) {\n    for (const m of p.metas) {\n      if (m.profile && m.profile.discordBridges) {\n        Array.prototype.push.apply(\n          channels,\n          m.profile.discordBridges.map((b) => b.channel.name)\n        );\n      }\n    }\n  }\n  return channels;\n}\n\nexport function hasEmbedPresences(presences: any[]) {\n  for (const p of Object.values(presences)) {\n    for (const m of p.metas) {\n      if (m.context && m.context.embed) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function denoisePresence({ onJoin, onLeave, onChange }) {\n  return {\n    rawOnJoin: (key, beforeJoin, afterJoin) => {\n      if (beforeJoin === undefined) {\n        onJoin(key, afterJoin.metas[0]);\n      }\n    },\n    rawOnLeave: (key, remaining, removed) => {\n      if (remaining.metas.length === 0) {\n        onLeave(key, removed.metas[0]);\n      } else {\n        onChange(\n          key,\n          removed.metas[removed.metas.length - 1],\n          remaining.metas[remaining.metas.length - 1]\n        );\n      }\n    },\n  };\n}\n\nexport function presenceEventsForHub(events) {\n  const onJoin = (key, meta) => {\n    events.trigger(`hub:join`, { key, meta });\n  };\n  const onLeave = (key, meta) => {\n    events.trigger(`hub:leave`, { key, meta });\n  };\n  const onChange = (key, previous, current) => {\n    events.trigger(`hub:change`, { key, previous, current });\n  };\n  return {\n    onJoin,\n    onLeave,\n    onChange,\n  };\n}\n","import Component from \"@aptero/axolotis-player/build/types/modules/core/ecs/Component\";\nimport { WebpackLazyModule } from \"@aptero/axolotis-player/build/types/modules/core/loader/WebpackLoader\";\nimport { ComponentFactory } from \"@aptero/axolotis-player/build/types/modules/core/ecs/ComponentFactory\";\nimport { WorldEntity } from \"@aptero/axolotis-player/build/types/modules/core/ecs/WorldEntity\";\n//import { ServiceEntity } from \"@aptero/axolotis-player/build/types/modules/core/service/ServiceEntity\";\nimport { ServiceEntity } from \"@aptero/axolotis-player\";\nimport SceneLoader from \"@root/lib/modules/spoke/SceneLoader\";\nimport { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\nimport { PlayerService } from \"@root/lib/modules/controller/PlayerService\";\nimport { load } from \"@root/lib/modules/spoke/PhoenixUtils\";\n\nexport class SpokeRoomLoader implements Component {\n  public sceneLoader: SceneLoader | null = null;\n\n  constructor(private threeLib: ThreeLib) {}\n\n  async loadRoom(hubid) {\n    const { data, hubPhxChannel, vapiddata } = await load(hubid);\n    const sceneURL = data.hubs[0].scene.model_url.replace(\".bin\", \".glb\");\n    this.sceneLoader = new SceneLoader();\n    await this.sceneLoader.loadScene(sceneURL, this.threeLib);\n  }\n\n  getType(): string {\n    return SpokeRoomLoader.name;\n  }\n}\n\nexport class Factory\n  implements WebpackLazyModule, ComponentFactory<SpokeRoomLoader>\n{\n  async createComponent(\n    world: WorldEntity,\n    config: any\n  ): Promise<SpokeRoomLoader> {\n    let services = world.getFirstComponentByType<ServiceEntity>(\n      ServiceEntity.name\n    );\n    let three = await services.getService<ThreeLib>(\n      \"@aptero/axolotis-core-plugins/modules/three/ThreeLib\"\n    );\n    let playerService = await services.getService<PlayerService>(\n      \"@aptero/axolotis-core-plugins/modules/controller/PlayerService\"\n    );\n    let spokeRoomLoader = new SpokeRoomLoader(three);\n    await spokeRoomLoader.loadRoom(config.room);\n    if (spokeRoomLoader.sceneLoader) {\n      playerService\n        .getCurrentPlayer()\n        .declareNavMesh(spokeRoomLoader.sceneLoader.navMesh);\n    }\n    return spokeRoomLoader;\n  }\n}\n\n/*\nHave to connect to the phoenix websocket\nand get scene url from message from\n[\"2\", \"2\", \"hub:yUXD7A2\", \"phx_reply\", {\n    \"response\": {\n        \"hub_requires_oauth\": false,\n        \"hubs\": [{\n            \"allow_promotion\": true,\n            \"description\": null,\n            \"embed_token\": \"c223b27b9e6f48c5591b4b140fe7de6f\",\n            \"entry_code\": 180429,\n            \"entry_mode\": \"allow\",\n            \"host\": \"dedicatedwebrtc3.aptero.co\",\n            \"hub_id\": \"yUXD7A2\",\n            \"lobby_count\": 0,\n            \"member_count\": 0,\n            \"member_permissions\": {\n                \"fly\": true,\n                \"pin_objects\": true,\n                \"spawn_and_move_media\": true,\n                \"spawn_camera\": true,\n                \"spawn_drawing\": true,\n                \"spawn_emoji\": true\n            },\n            \"name\": \"Lightweight Empty Room\",\n            \"port\": \"443\",\n            \"room_size\": 50,\n            \"scene\": {\n                \"account_id\": null,\n                \"allow_promotion\": false,\n                \"allow_remixing\": false,\n                \"attribution\": null,\n                \"attributions\": { \"content\": [], \"creator\": \"\" },\n                \"description\": null,\n                \"model_url\": \"https://alphahub.aptero.co/files/598eeed3-0768-408a-a75b-b0fcb8e907af.bin\",\n                \"name\": \"Museum\",\n                \"parent_scene_id\": null,\n                \"project_id\": \"wwDyQ8t\",\n                \"scene_id\": \"br4pVT2\",\n                \"screenshot_url\": \"https://alphahub.aptero.co/files/38473f11-615f-487d-b20b-f3b6558abea6.jpg\",\n                \"type\": \"scene\",\n                \"url\": \"https://alphahub.aptero.co/scenes/br4pVT2/museum\"\n            },\n            \"slug\": \"lightweight-empty-room\",\n            \"turn\": {\n                \"credential\": \"CWBiIUroBx9x7OITbxMrm54HiJw=\",\n                \"enabled\": true,\n                \"transports\": [{ \"port\": 5349 }],\n                \"username\": \"1636140736:coturn\"\n            },\n            \"user_data\": null\n        }],\n        \"perms_token\": \"eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJhY2NvdW50X2lkIjoiNjQwNDA3MDUwOTY2MjY5OTYxIiwiYW1wbGlmeV9hdWRpbyI6dHJ1ZSwiYXVkIjoicmV0X3Blcm1zIiwiY2xvc2VfaHViIjp0cnVlLCJjcmVhdGVfaHViIjp0cnVlLCJlbWJlZF9odWIiOnRydWUsImV4cCI6MTYzNjE0MDkxNiwiZmx5Ijp0cnVlLCJodWJfaWQiOiJ5VVhEN0EyIiwiaWF0IjoxNjM2MTQwNjE2LCJpc3MiOiIiLCJqb2luX2h1YiI6dHJ1ZSwianRpIjoiZjhkNGU2MDMtMWE0NC00MWRmLTg5NWMtNjE3ZGVhYzc5ZDI4Iiwia2lja191c2VycyI6dHJ1ZSwibXV0ZV91c2VycyI6dHJ1ZSwibmJmIjoxNjM2MTQwNjE1LCJwaW5fb2JqZWN0cyI6dHJ1ZSwicG9zdGdyZXN0X3JvbGUiOiJyZXRfYWRtaW4iLCJzcGF3bl9hbmRfbW92ZV9tZWRpYSI6dHJ1ZSwic3Bhd25fY2FtZXJhIjp0cnVlLCJzcGF3bl9kcmF3aW5nIjp0cnVlLCJzcGF3bl9lbW9qaSI6dHJ1ZSwic3ViIjoiNjQwNDA3MDUwOTY2MjY5OTYxX3lVWEQ3QTIiLCJ0d2VldCI6ZmFsc2UsInR5cCI6ImFjY2VzcyIsInVwZGF0ZV9odWIiOnRydWUsInVwZGF0ZV9odWJfcHJvbW90aW9uIjp0cnVlLCJ1cGRhdGVfcm9sZXMiOnRydWV9.qlNJloKYDmc2wSTaKF1eVYKKV_lCuuwzfdRnq3Jc-OP9P5uhKiFzo1i9N6rHBCIfITEwp8fJouD7TNOrBvpwFgxR1JHTgOpgWTdD6ltxRGspbtJRMJQ7qa66WTrVxKup4fI1ah70dFIsHu26GNdUaaNp8503VYuo41Dzs0XnTT1bLjbNM0ugJ_ZaF_d24b1m_7dLKdAn0-aZkoTQSCl3wzNDKLE90B2FJT6Mc7hqeo8d0mhr3yNQSRyJ4xLS0TBG4fvFZQL5H_bRD4Fk-q17jeMAgIAvtquElbs1cYRnQFE3g-PcsRYYRsejWaz4PEJUlZ5MM5tbohM5XoVHdRT8ZA\",\n        \"session_id\": \"a3c750b8-6446-4a1e-a638-c516073d8861\",\n        \"session_token\": \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJyZXRfc2Vzc2lvbiIsImV4cCI6MTYzNjIyNzAxNiwiaWF0IjoxNjM2MTQwNjE2LCJpc3MiOiIiLCJqdGkiOiIzNDk4Yjg4OC01NjA0LTQxYzctYWFmZC0xMjI5NmU4YmNlYTIiLCJuYmYiOjE2MzYxNDA2MTUsInNlc3Npb25faWQiOiJhM2M3NTBiOC02NDQ2LTRhMWUtYTYzOC1jNTE2MDczZDg4NjEiLCJzdWIiOiJhM2M3NTBiOC02NDQ2LTRhMWUtYTYzOC1jNTE2MDczZDg4NjEiLCJ0eXAiOiJhY2Nlc3MifQ.EbEzkgwNJ8_H4g8vxFI-ch9HprbzNh12xkfj-OrUOkUqTF-j-qEpsF-XFIZozSlCU2cwJVD7RLuxNOuqDVF76g\",\n        \"subscriptions\": { \"favorites\": true, \"web_push\": null }\n    }, \"status\": \"ok\"\n}];\n\n */\n"],"names":["SceneLoader","constructor","sceneUrl","threeLib","this","scene","mesh","loadAssets","traverse","node","isMesh","name","navMesh","add","closure","value","globalSelf","self","phxWindow","window","global","SOCKET_STATES","CHANNEL_STATES","CHANNEL_EVENTS","TRANSPORTS","XHR_STATES","Push","channel","event","payload","timeout","receivedResp","timeoutTimer","recHooks","sent","resend","reset","send","hasReceived","startTimeout","socket","push","topic","ref","join_ref","joinRef","receive","status","callback","response","cancelRefEvent","refEvent","matchReceive","_ref","filter","h","forEach","off","cancelTimeout","clearTimeout","makeRef","replyEventName","on","setTimeout","trigger","Timer","timerCalc","timer","tries","scheduleTimeout","Ajax","static","method","endPoint","accept","body","ontimeout","XDomainRequest","req","xdomainRequest","XMLHttpRequest","xhrRequest","open","onload","parseJSON","responseText","onprogress","setRequestHeader","onerror","onreadystatechange","readyState","resp","JSON","parse","e","console","log","obj","parentKey","queryStr","key","Object","prototype","hasOwnProperty","call","paramKey","paramVal","serialize","encodeURIComponent","join","url","params","keys","length","prefix","match","LongPoll","token","skipHeartbeat","onopen","onmessage","onclose","pollEndpoint","normalizeEndpoint","poll","replace","RegExp","endpointURL","appendParams","closeAndRetry","close","request","bind","messages","msg","data","Error","_code","_reason","serializer_default","HEADER_LENGTH","META_LENGTH","KINDS","reply","broadcast","encode","ArrayBuffer","binaryEncode","stringify","decode","rawPayload","binaryDecode","message","metaLength","header","view","DataView","offset","setUint8","Array","from","char","charCodeAt","combined","Uint8Array","byteLength","set","buffer","kind","getUint8","decoder","TextDecoder","decodePush","decodeReply","decodeBroadcast","joinRefSize","topicSize","eventSize","slice","refSize","Socket","opts","stateChangeCallbacks","error","channels","sendBuffer","transport","WebSocket","establishedConnections","defaultEncoder","defaultDecoder","closeWasClean","binaryType","connectClock","awaitingConnectionOnPageShow","addEventListener","_e","conn","disconnect","connect","heartbeatIntervalMs","rejoinAfterMs","reconnectAfterMs","logger","longpollerTimeout","vsn","heartbeatTimer","pendingHeartbeatRef","reconnectTimer","teardown","replaceTransport","newTransport","protocol","location","endPointURL","uri","charAt","host","code","reason","onConnOpen","onConnError","onConnMessage","onConnClose","hasLogger","onOpen","onClose","onError","onMessage","flushSendBuffer","resetHeartbeat","heartbeatTimeout","abnormalClose","sendHeartbeat","waitForBufferDone","waitForSocketClosed","bufferedAmount","closeCode","triggerChanError","transportBefore","establishedBefore","isErrored","isLeaving","isClosed","connectionState","isConnected","remove","stateChangeRefs","c","refs","indexOf","chanParams","chan","state","bindings","bindingRef","joinedOnce","joinPush","pushBuffer","rejoinTimer","rejoin","pushEvent","isJoining","canPush","isJoined","leave","leavePush","_event","isMember","leaveOpenTopic","handledPayload","eventBindings","i","result","newRef","toString","rawMessage","dupChannel","find","configs","async","load","hubid","debug","socketClass","qs","URLSearchParams","search","getNewSocketUrl","refreshDirectReticulumHostAndPort","port","directReticulumHostAndPort","get","document","socketUrl","socketSettings","invalidateReticulumMeta","endPointPath","URL","pathname","newSocketUrl","newEndPoint","connectToReticulum","hubPhxChannel","vapiddata","Promise","resolve","reject","hub_id","profile","avatarId","displayName","push_subscription_endpoint","auth_token","perms_token","bot_access_key","context","mobile","embed","hub_invite_id","res","reticulumMeta","invalidatedReticulumMetaThisSession","SpokeRoomLoader","sceneURL","hubs","model_url","sceneLoader","loadScene","getType","Factory","world","config","services","getFirstComponentByType","ServiceEntity","three","getService","playerService","spokeRoomLoader","loadRoom","room","getCurrentPlayer","declareNavMesh"],"sourceRoot":""}